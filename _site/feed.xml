<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LawooTrip</title>
    <description>龟龟的个人博客-乐物旅行</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 22 Nov 2017 11:36:55 +0000</pubDate>
    <lastBuildDate>Wed, 22 Nov 2017 11:36:55 +0000</lastBuildDate>
    <generator>Jekyll v3.5.2</generator>
    
      <item>
        <title>Ubuntu搭建Shadowsocks原来这么简单！！</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Vue.js 放弃中…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;目录:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#0&quot;&gt;一、简述&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#1&quot;&gt;二、基本环境&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#2&quot;&gt;三、配置文件&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#3&quot;&gt;四、配置自动运行&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#4&quot;&gt;五、常用命令&lt;/a&gt;&lt;/p&gt;

&lt;p id=&quot;0&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;一简述&quot;&gt;一、简述&lt;/h2&gt;

&lt;p&gt;本教程旨在提供简明的Ubuntu 16.04下安装服务器端Shadowsocks。不同于Ubuntu 16.04之前的教程，本文抛弃initd，转而使用Ubuntu 16.04支持的Systemd管理Shadowsocks的启动与停止，显得更为便捷。优化部分包括BBR、TCP Fast Open以及吞吐量优化。&lt;/p&gt;

&lt;p&gt;本教程仅适用于Ubuntu 16.04及之后的版本，基于Python 3，支持IPv6。&lt;/p&gt;

&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;二基本环境&quot;&gt;二、基本环境&lt;/h2&gt;

&lt;p&gt;本教程使用Python 3为载体，因Python 3对应的包管理器&lt;code class=&quot;highlighter-rouge&quot;&gt;pip3&lt;/code&gt;并未预装，首先安装&lt;code class=&quot;highlighter-rouge&quot;&gt;pip3&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt install python3-pip
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;因Shadowsocks作者不再维护pip中的Shadowsocks（定格在了2.8.2），我们使用下面的命令来安装最新版的Shadowsocks：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip3 install https://github.com/shadowsocks/shadowsocks/archive/master.zip
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装完成后可以使用下面这个命令查看Shadowsocks版本：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo ssserver --version
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;目前会显示“Shadowsocks 3.0.0”。&lt;/p&gt;

&lt;p id=&quot;2&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;三配置文件&quot;&gt;三、配置文件&lt;/h2&gt;

&lt;p&gt;创建Shadowsocks配置文件所在文件夹：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo mkdir /etc/shadowsocks
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后创建配置文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo nano /etc/shadowsocks/config.json
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;复制粘贴如下内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;server&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;your_server_ip&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//注意：这里指本地IP或云服务器内网IP;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;server_port&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8388&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;local_address&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;127.0.0.1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;local_port&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1080&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;password&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;mypassword&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//注意修改密码“password”;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;timeout&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;method&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;aes-256-cfb&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;fast_open&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后按Ctrl + O保存文件，Ctrl + X退出。&lt;/p&gt;

&lt;p&gt;测试下Shadowsocks能不能正常工作了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssserver -c /etc/shadowsocks/config.json
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在Shadowsocks客户端添加服务器，如果你使用的是我提供的那个配置文件的话，地址填写你的IPv4地址或IPv6地址，端口号为8388，加密方法为aes-256-cfb，密码为你设置的密码。然后设置客户端使用全局模式，浏览器登录Google试试应该能直接打开了。&lt;/p&gt;

&lt;p&gt;这时浏览器登录http://ip138.com/就会显示Shadowsocks服务器的IP啦！&lt;/p&gt;

&lt;p&gt;测试完毕，按Ctrl + C关闭Shadowsocks。&lt;/p&gt;

&lt;p id=&quot;3&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;四配置自动运行&quot;&gt;四、配置自动运行&lt;/h2&gt;

&lt;p&gt;新建Shadowsocks管理文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo nano /etc/systemd/system/shadowsocks-server.service
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;复制粘贴：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[Unit]
Description=Shadowsocks Server
After=network.target

[Service]
ExecStart=/usr/local/bin/ssserver -c /etc/shadowsocks/config.json
Restart=on-abort

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Ctrl + O保存文件，Ctrl + X退出。&lt;/p&gt;

&lt;p&gt;启动Shadowsocks：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl start shadowsocks-server
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;设置开机启动Shadowsocks：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl enable shadowsocks-server
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;至此，Shadowsock服务器端的基本配置已经全部完成了！&lt;/p&gt;

&lt;p id=&quot;4&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;常用命令&quot;&gt;&lt;strong&gt;常用命令：&lt;/strong&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;systemctl start shadowsocks //启动SS
systemctl enable shadowsocks //停止SS
systemctl status shadowsocks//查看SS状态
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;厉害的一个命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tcpdump -i any -nn 'port 8338' -vv -X //监听端口数据
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;-i interface，网卡的名称，后面可以跟具体的网卡名称(ifconfig后者tcpdump -D)获取，笔者的电脑上看到any，似乎是指所有的网卡&lt;/p&gt;

  &lt;p&gt;-nn 监听host或者port名，这个网上解释有一大堆，什么src host，dist host  ，比如我要抓，ip地址为127.0.0.1，端口为9002的服务器的数据包，那么命令可以写成-nn ‘src host 127.0.0.1 and &amp;gt;port 9002’.不过实际来讲，端口肯定是被一个ip地址使用的，而且对于我来说，服务器抓包比较有意义，所以，其实有没有ip地址，似乎显得不那么重要，有端口就可以。&lt;/p&gt;

  &lt;p&gt;-vv 详细信息&lt;/p&gt;

  &lt;p&gt;-X 以16进制的格式输出&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;附加题优化吞吐量&quot;&gt;附加题、优化吞吐量&lt;/h2&gt;

&lt;p&gt;新建配置文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo nano /etc/sysctl.d/local.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;复制粘贴：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# max open files
fs.file-max = 51200
# max read buffer
net.core.rmem_max = 67108864
# max write buffer
net.core.wmem_max = 67108864
# default read buffer
net.core.rmem_default = 65536
# default write buffer
net.core.wmem_default = 65536
# max processor input queue
net.core.netdev_max_backlog = 4096
# max backlog
net.core.somaxconn = 4096

# resist SYN flood attacks
net.ipv4.tcp_syncookies = 1
# reuse timewait sockets when safe
net.ipv4.tcp_tw_reuse = 1
# turn off fast timewait sockets recycling
net.ipv4.tcp_tw_recycle = 0
# short FIN timeout
net.ipv4.tcp_fin_timeout = 30
# short keepalive time
net.ipv4.tcp_keepalive_time = 1200
# outbound port range
net.ipv4.ip_local_port_range = 10000 65000
# max SYN backlog
net.ipv4.tcp_max_syn_backlog = 4096
# max timewait sockets held by system simultaneously
net.ipv4.tcp_max_tw_buckets = 5000
# turn on TCP Fast Open on both client and server side
net.ipv4.tcp_fastopen = 3
# TCP receive buffer
net.ipv4.tcp_rmem = 4096 87380 67108864
# TCP write buffer
net.ipv4.tcp_wmem = 4096 65536 67108864
# turn on path MTU discovery
net.ipv4.tcp_mtu_probing = 1

net.ipv4.tcp_congestion_control = bbr
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sysctl --system
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;编辑之前的shadowsocks-server.service文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo nano /etc/systemd/system/shadowsocks-server.service
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecStart&lt;/code&gt;前插入一行，内容为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ExecStartPre=/bin/sh -c 'ulimit -n 51200'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;即修改后的shadowsocks-server.service内容为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[Unit]
Description=Shadowsocks Server
After=network.target

[Service]
ExecStartPre=/bin/sh -c 'ulimit -n 51200'
ExecStart=/usr/local/bin/ssserver -c /etc/shadowsocks/config.json
Restart=on-abort

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Ctrl + O保存文件，Ctrl + X退出。&lt;/p&gt;

&lt;p&gt;重载shadowsocks-server.service：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl daemon-reload
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重启Shadowsocks：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl restart shadowsocks-server
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;TCP Fast Open可以降低Shadowsocks服务器和客户端的延迟。实际上在上一步已经开启了TCP Fast Open，现在只需要在Shadowsocks配置中启用TCP Fast Open。&lt;/p&gt;

&lt;p&gt;编辑config.json：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo nano /etc/shadowsocks/config.json
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将fast_open的值由false修改为true。Ctrl + O保存文件，Ctrl + X退出。&lt;/p&gt;

&lt;p&gt;重启Shadowsocks：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl restart shadowsocks-server

注意：TCP Fast Open同时需要客户端的支持，即客户端Linux内核版本为3.7.1及以上；你可以在Shadowsocks客户端中启用TCP Fast Open。

至此，Shadowsock服务器端的优化已经全部完成了！
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://www.polarxiong.com/archives/Ubuntu-16-04%E4%B8%8BShadowsocks%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BC%98%E5%8C%96.html&quot;&gt;启蒙教程&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Tue, 14 Nov 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/11/14/shadowsocks-ubuntu/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/11/14/shadowsocks-ubuntu/</guid>
        
        <category>笔记</category>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Ubuntu下Nginx配置笔记</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Vue.js 放弃中…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;阿里云双十一活动还算良心,赶紧买个服务器自己玩.&lt;/p&gt;

&lt;p&gt;本着日后方便科学上网的原则,买了2核4G,1M带宽的香港节点3年,搭载Ubuntu 16.0402系统镜像.&lt;/p&gt;

&lt;p&gt;本地环境:MAC OS Sierra 10.12.3&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本文分四个部分:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#0&quot;&gt;一、使用SSH通过MAC同Ubuntu建立连接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#1&quot;&gt;二、Ubuntu服务器基本设置&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#2&quot;&gt;三、环境搭建&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#3&quot;&gt;四、配置多个站点&lt;/a&gt;&lt;/p&gt;

&lt;p id=&quot;0&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一使用ssh通过mac同ubuntu建立连接&quot;&gt;一、使用SSH通过MAC同Ubuntu建立连接&lt;/h3&gt;

&lt;h4 id=&quot;1ubuntu端&quot;&gt;1.Ubuntu端&lt;/h4&gt;

&lt;p&gt;在ubuntu终端上输入&lt;code class=&quot;highlighter-rouge&quot;&gt;root@ubuntu:~$ sudo apt-get install openssh-server&lt;/code&gt;命令安装openssh-server.(阿里云生成的系统登陆后,默认是root角色)&lt;/p&gt;

&lt;p&gt;一般报错有两个可能的原因,一个是apt版本过老,办法是update一下;另一个是apt的lists损坏,办法是用如下命令来删除已经损坏的lists.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`root@ubuntu:~$ sudo rm /var/lib/apt/lists/* -vf`
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2mac端&quot;&gt;2.MAC端&lt;/h4&gt;

&lt;p&gt;在终端上输入&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh root@your_server_ip
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;跟着指引输入服务器密码即可,是不是敲简单.&lt;/p&gt;

&lt;p&gt;如果不想每次输入IP,可以在 /.ssh/config 里进行配置,🌰如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Host mylinux
    HostName ***.***.***.***
    Port 22
    User root
    IdentityFile /Users/***/.ssh/mylinux \\这里是ssh私钥的路径,不作不用动
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;像上面这样配置后,每次只需要在终端敲入:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh mylinux
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;即可!&lt;/p&gt;

&lt;p&gt;找不到&lt;code class=&quot;highlighter-rouge&quot;&gt;/Users/***/.ssh&lt;/code&gt;文件夹?
用下面的命令可以显示MAC隐藏文件.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;defaults write com.apple.finder AppleShowAllFiles -bool true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;二ubuntu服务器基本设置&quot;&gt;二、Ubuntu服务器基本设置&lt;/h3&gt;

&lt;h4 id=&quot;使用root登录服务器&quot;&gt;使用root登录服务器&lt;/h4&gt;

&lt;p&gt;首先我们需要使用刚刚配置好的root用户ssh登录服务器:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;local$ ssh root@SERVER_IP_ADDRESS
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;前面的local$表示是在本地机器操作,在服务器端,该提示符会类似&lt;code class=&quot;highlighter-rouge&quot;&gt;root@my-remote-server:~$&lt;/code&gt;这种形式,后边会看到。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Tips: 如果使用的是腾讯云，其初始登录默认使用的是用户ubuntu，并不是root。因此，使用ssh ubuntu@your_server_ip登录之后可以修改下root的密码，然后就可以切换到用户root了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;修改密码命令如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ubuntu@VM-42-158-ubuntu:~$ sudo passwd root
Enter new UNIX password:
Retype new UNIX password:
passwd: password updated successfully
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有可能还需要编辑配置文件/etc/ssh/sshd_config中的PermitRootLogin的设置。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;buntu@VM-42-158-ubuntu:~$ su
Password:
root@VM-42-158-ubuntu:/#
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;新增超级用户权限用户&quot;&gt;新增超级用户权限用户&lt;/h4&gt;

&lt;p&gt;root用户虽然强大,但是正是由于太强大了,所以显得不够安全,因此通常情况下我们需要创建一个新的用户,然后给他设置超级用户(superuser)权限,这样就可以安全的进行各种操作了。&lt;/p&gt;

&lt;p&gt;使用root用户登录,做如下操作:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@my-remote-server:~$ adduser dennis
root@my-remote-server:~$ usermod -aG sudo dennis
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里就将新创建的用户加入了sudo用户组,就具有了超级用户的权限。更详细的信息可以参考&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-edit-the-sudoers-file-on-ubuntu-and-centos&quot;&gt;这个教程&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;然后我们就可以以新创建的用户登录了:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@my-remote-server:~# su - dennis
dennis@my-remote-server:~$
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p id=&quot;2&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;三环境搭建&quot;&gt;三、环境搭建&lt;/h3&gt;

&lt;h4 id=&quot;安装nginx&quot;&gt;安装Nginx&lt;/h4&gt;

&lt;p&gt;在ubuntu上安装软件很简单,使用apt-get即可。注意由于权限问题,需要在前面加sudo。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get update
sudo apt-get install nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;踩坑提醒&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;安装nginx时出现错误&quot;&gt;安装Nginx时出现错误&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dennis@my-remote-server:~$ sudo apt-get install nginx
Reading package lists... Done
Building dependency tree
Reading state information... Done
nginx is already the newest version (1.10.0-0ubuntu0.16.04.2).
0 upgraded, 0 newly installed, 0 to remove and 42 not upgraded.
2 not fully installed or removed.
After this operation, 0 B of additional disk space will be used.
Do you want to continue? [Y/n]
Setting up nginx-core (1.10.0-0ubuntu0.16.04.2) ...
Job for nginx.service failed because the control process exited with error code. See &quot;systemctl status nginx.service&quot; and &quot;journalctl -xe&quot; for details.
invoke-rc.d: initscript nginx, action &quot;start&quot; failed.
dpkg: error processing package nginx-core (--configure):
 subprocess installed post-installation script returned error exit status 1
dpkg: dependency problems prevent configuration of nginx:
 nginx depends on nginx-core (&amp;gt;= 1.10.0-0ubuntu0.16.04.2) | nginx-full (&amp;gt;= 1.10.0-0ubuntu0.16.04.2) | nginx-light (&amp;gt;= 1.10.0-0ubuntu0.16.04.2) | nginx-extras (&amp;gt;= 1.10.0-0ubuntu0.16.04.2); however:
  Package nginx-core is not configured yet.
  Package nginx-full is not installed.
  Package nginx-light is not installed.
  Package nginx-extras is not installed.
 nginx depends on nginx-core (&amp;lt;&amp;lt; 1.10.0-0ubuntu0.16.04.2.1~) | nginx-full (&amp;lt;&amp;lt; 1.10.0-0ubuntu0.16.04.2.1~) | nginx-light (&amp;lt;&amp;lt; 1.10.0-0ubuntu0.16.04.2.1~) | nginx-extras (&amp;lt;&amp;lt; 1.10.0-0ubuntu0.16.04.2.1~); however:
  Package nginx-core is not configured yet.
  Package nginx-full is not installed.
  Package nginx-light is not installed.
  Package nginx-extras is not installed.
dpkg: error processing package nginx (--configure):
 dependency problems - leaving unconfigured
Errors were encountered while processing:
 nginx-core
 nginx
E: Sub-process /usr/bin/dpkg returned an error code (1)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;原因分析&lt;/p&gt;

&lt;p&gt;Google了一下,发现出现这种错误,一般应该是由于其他应用占用了80端口。可以这样来看下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dennis@myserver:~$ sudo netstat -nlp
sudo: unable to resolve host myserver
[sudo] password for dennis:
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      132/rpcbind
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      332/apache2
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      269/sshd
tcp        0      0 0.0.0.0:25              0.0.0.0:*               LISTEN      454/master
tcp6       0      0 :::111                  :::*                    LISTEN      132/rpcbind
tcp6       0      0 :::22                   :::*                    LISTEN      269/sshd
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;果然80端口被默认安装的apache给占掉了,所以需要干掉占用80端口的apache2：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo kill -9 332
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行apt-get命令更新或安装软件出现Setting locale failed错误&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
	LANGUAGE = (unset),
	LC_ALL = (unset),
	LC_CTYPE = &quot;en_US.UTF-8&quot;,
	LANG = &quot;en_US.UTF-8&quot;
    are supported and installed on your system.
perl: warning: Falling back to the standard locale (&quot;C&quot;).
locale: Cannot set LC_CTYPE to default locale: No such file or directory
locale: Cannot set LC_MESSAGES to default locale: No such file or directory
locale: Cannot set LC_ALL to default locale: No such file or directory
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;解决办法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo ap-get update
apt-get install language-pack-en
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;nginx-常用目录&quot;&gt;Nginx 常用目录&lt;/h5&gt;

&lt;p&gt;内容&lt;/p&gt;

&lt;p&gt;/var/www/html: 保存web网页内容的默认目录&lt;/p&gt;

&lt;p&gt;服务器配置&lt;/p&gt;

&lt;p&gt;/etc/nginx: nginx 配置目录。所有Nginx相关的配置文件都在这里。
/etc/nginx/nginx.conf: Nginx主配置文件,进行全局默认设置。
/etc/nginx/sites-available: 针对每个”server blocks”独立的配置文件。这里的配置文件并不被直接使用,只有软连接到site-enabled的配置才会真正生效。
/etc/nginx/sites-enabled/: 针对每个”server blocks”独立的配置文件。由sites-available链接过来。
/etc/nginx/snippets: 一些配置脚本片段。&lt;/p&gt;

&lt;p&gt;服务器日志&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/nginx/access.log: &lt;/code&gt;默认保存所有与web服务交互的请求。
&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/nginx/error.log: &lt;/code&gt;Nginx的错误日志&lt;/p&gt;

&lt;h4 id=&quot;顺便安装一下mysql&quot;&gt;顺便安装一下MySQL&lt;/h4&gt;

&lt;h5 id=&quot;安装&quot;&gt;安装&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get update
sudo apt-get install mysql-server
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;配置&quot;&gt;配置&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo mysql_secure_installation
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;查看mysql的版本&quot;&gt;查看MySQL的版本：&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql --version
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;初始化&quot;&gt;初始化&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo mysqld --initialize
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果是如上面那样通过apt-get安装的，这一步通常已经被做了。因此会有如下错误提示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[ERROR] --initialize specified but the data directory has files in it. Aborting.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;mysql的启动和停止&quot;&gt;MySQL的启动和停止&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo /etc/init.d/mysql start
sudo /etc/init.d/mysql stop
sudo /etc/init.d/mysql restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo start mysql
sudo stop mysql
sudo restart mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;测试连接&quot;&gt;测试连接&lt;/h5&gt;

&lt;p&gt;可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;mysqladmin -p -u root version&lt;/code&gt;命令来测试一下mysql连接是否正常。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dennis@my-remote-server:/var/www/html$ mysqladmin -p -u root version
Enter password:
mysqladmin  Ver 8.42 Distrib 5.7.13, for Linux on x86_64
Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Server version		5.7.13-0ubuntu0.16.04.2
Protocol version	10
Connection		Localhost via UNIX socket
UNIX socket		/var/run/mysqld/mysqld.sock
Uptime:			19 min 14 sec
Threads: 1  Questions: 8  Slow queries: 0  Opens: 115  Flush tables: 1  Open tables: 34  Queries per second avg: 0.006
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;创建数据库及新的数据库用户&quot;&gt;创建数据库及新的数据库用户&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql -u root -p
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;用密码登录成功之后执行下面的sql语句创建一个数据库，名叫lawootrip&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE DATABASE lawootrip DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安全起见，我们为这个数据库创建一个单独的用户：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GRANT ALL ON wordpress.* TO 'lawootripuser'@'localhost' IDENTIFIED BY 'password';
FLUSH PRIVILEGES;
EXIT;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在外网通过IP直接访问操作数据库&lt;/p&gt;

&lt;p&gt;默认情况下,我们只能在服务器上通过localhost访问MySQL,如果需要通过IP从外网访问,需要进行相应的设置。&lt;/p&gt;

&lt;p&gt;1) 修改授权&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GRANT ALL ON lawootrip.* TO 'lawootripuser'@'%' IDENTIFIED BY 'password';
FLUSH PRIVILEGES;
EXIT;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果需要,还可以指定特定的IP地址(替换上面的%即可)。&lt;/p&gt;

&lt;p&gt;或者可以直接修改表:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql -u root -p
mysql&amp;gt; use mysql;
mysql&amp;gt; update user set host = '%' where user = 'root';
mysql&amp;gt; select user, host from user;
+------------------+-----------+
| user             | host      |
+------------------+-----------+
| mysql.sys        | localhost |
| root             | localhost |
| wordpressuser    | %         |
+------------------+-----------+
3 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2) 修改配置文件&lt;/p&gt;

&lt;p&gt;配置文件位置为/etc/mysql/mysql.conf.d/mysqld.cnf,注释掉其中一行:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bind-address  =127.0.0.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重启MySQL即可:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo service mysql restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;配置nginx&quot;&gt;配置Nginx&lt;/h5&gt;

&lt;p&gt;打开配置文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo vim /etc/nginx/sites-available/default
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;作如下修改（具体可以参考&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-install-wordpress-with-lemp-on-ubuntu-16-04&quot;&gt;这里的说明&lt;/a&gt;）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
    . . .
    location = /favicon.ico { log_not_found off; access_log off; }
    location = /robots.txt { log_not_found off; access_log off; allow all; }
    location ~* \.(css|gif|ico|jpeg|jpg|js|png)$ {
        expires max;
        log_not_found off;
    }
    . . .
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对try_files做如下修改：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
    . . .
    location / {
        #try_files $uri $uri/ =404;
        try_files $uri $uri/ /index.php$is_args$args;
    }
    . . .
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后检查配置文件的正确性，并重启Nginx：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo nginx -t
//If no errors were reported, reload Nginx by typing:
sudo systemctl reload nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p id=&quot;3&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;四配置多个站点&quot;&gt;四、配置多个站点&lt;/h3&gt;

&lt;p&gt;通常情况下我们需要在Web服务器上部署多个站点,使用多个不同的域名。&lt;/p&gt;

&lt;h4 id=&quot;设置新的文档目录&quot;&gt;设置新的文档目录&lt;/h4&gt;

&lt;p&gt;默认情况下,在Ubuntu上的Nginx已经默认创建了一个server block,其文档目录为/var/www/html(我们在上面安装wordpress的时候使用的就是这个默认的server block)。&lt;/p&gt;

&lt;p&gt;如果我们需要部署多个站点,那么就需要创建多个不同的server block。假如我们需要部署两个网站:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lawootrip.com
lawoo.cn
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样我们就需要设置两个新的文档目录。为统一起见,我们使用xxx.com/html这种目录结构形式:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo mkdir -p /var/www/lawootrip.com/html
sudo mkdir -p /var/www/lawoo.cn/html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;修改一下这两个文档目录的权限:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo chown -R $USER:$USER /var/www/lawootrip.com/html
sudo chown -R $USER:$USER /var/www/lawoo.cn/html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里用到了环境变量&lt;code class=&quot;highlighter-rouge&quot;&gt;$USER&lt;/code&gt;,请确保没有使用root账号进行操作。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dennis@my-remote-server:~$ echo $USER
dennis
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;至此文档目录应该配置好了。如果需要,我们可以通过下面的命令设置一下上层目录的权限:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo chmod -R 755 /var/www
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要提醒的是,暂时不需要担心这两个测试域名是否可以访问的问题,后边我们会介绍在本地浏览器如何访问这两个测试域名。&lt;/p&gt;

&lt;h4 id=&quot;为每个站点创建测试文件&quot;&gt;为每个站点创建测试文件&lt;/h4&gt;

&lt;p&gt;创建文件/var/www/lawootrip.com/html/index.html&lt;/p&gt;

&lt;p&gt;创建文件/var/www/lawoo.cn/html/index.html&lt;/p&gt;

&lt;h4 id=&quot;为每个站点创建server-block文件&quot;&gt;为每个站点创建server block文件&lt;/h4&gt;

&lt;p&gt;如前所述,默认情况下Nginx已经配置了一个默认的server block,因此我们可以将默认的server block配置文件拷贝过来稍作修改:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo cp /etc/nginx/sites-available/default /etc/nginx/sites-available/lawootrip.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;打开文件:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo vim /etc/nginx/sites-available/lawootrip.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
        listen 80 default_server;
        listen [::]:80 default_server;
        root /var/www/html;
        index index.html index.htm index.nginx-debian.html;
        server_name _;
        location / {
                try_files $uri $uri/ =404;
        }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对其内容稍作修改,修改之后内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
        listen 80;
        listen [::]:80;
        root /var/www/lawootrip.com/html;
        index index.html index.htm index.nginx-debian.html;
        server_name lawootrip.com www.lawootrip.com;
        location / {
                try_files $uri $uri/ =404;
        }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;主要修改了几个地方:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;去掉了default_server字眼。一台服务器上只能有一个default_server的配置,因此我们保留系统最初的设置为默认设置。&lt;/li&gt;
  &lt;li&gt;修改root目录.&lt;/li&gt;
  &lt;li&gt;修改server_name.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;针对第二个站点lawoo.cn也做类似修改。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo cp /etc/nginx/sites-available/lawoo.cn /etc/nginx/sites-available/lawoo.cn
sudo vim /etc/nginx/sites-available/lawoo.cn
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;激活两个站点的server-block&quot;&gt;激活两个站点的server block&lt;/h4&gt;

&lt;p&gt;使用如下命令:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo ln -s /etc/nginx/sites-available/lawootrip.com /etc/nginx/sites-enabled/
sudo ln -s /etc/nginx/sites-available/lawoo.cn /etc/nginx/sites-enabled/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样这些文件(链接)就位于激活的目录内了。到目前为止我们有3个激活了的server block了。服务器根据listen指令和server_name来确定该访问那个目录。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;lawootrip.com: 响应来自lawootrip.com以及www.lawootrip.com的请求&lt;/li&gt;
  &lt;li&gt;lawoo.cn: 响应来自lawoo.cn以及www.lawoo.cn的请求&lt;/li&gt;
  &lt;li&gt;default: 响应没有匹配到上面两个规则的80端口的请求。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后检查下nginx配置文件的正确性:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo nginx -t
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;**重启一下nginx使修改生效:**&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl restart nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;关于Nginx更多的指令介绍可以参考&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/understanding-nginx-server-and-location-block-selection-algorithms&quot;&gt;这个教程&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;配置二级子域名及代理访问&quot;&gt;配置二级子域名及代理访问&lt;/h4&gt;

&lt;p&gt;举例来说，比如我们在我的服务器上有两个web程序，一个是之前的 lawootrip.com，另一个程序是python应用，使用端口5555，需要映射到二级域名 demo.lawootrip.com。我们应该如何设置呢？&lt;/p&gt;

&lt;h5 id=&quot;1添加域名解析&quot;&gt;1）添加域名解析&lt;/h5&gt;

&lt;p&gt;这个步骤不多说了，在域名服务提供商网站添加一条A记录，设置域名demo.lawootrip.com。&lt;/p&gt;

&lt;h5 id=&quot;2修改nginx配置文件&quot;&gt;2）修改Nginx配置文件&lt;/h5&gt;

&lt;p&gt;就是我们上面提到的文件&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/nginx/sites-available/lawootrip.com&lt;/code&gt;,添加如下内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
    listen 80;
    server_name demo.example.com;
    location / {
        proxy_set_header   X-Real-IP $remote_addr;
        proxy_set_header   Host      $http_host;
        proxy_pass         http://127.0.0.1:5555;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后重启Nginx即可。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl restart nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Tips 阿里云特供&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ubuntu 在每次执行命令的时候，会报如下错误：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo
sudo: unable to resolve host iZj6cfyvsfiajdiy47qddhZ
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;iZj6cfyvsfiajdiy47qddhZ是阿里云创建服务器默认的hostname，错误其实没有什么影响，但看起来很不爽，解决方式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vim /etc/hostname
iZj6cfyvsfiajdiy47qddhZ
$ vim /etc/hosts
127.0.0.1       localhost iZj6cfyvsfiajdiy47qddhZ
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结尾处增加hostname.搞定.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://foofish.net/https-free-for-lets-encrypt.html&quot;&gt;免费HTTPS证书Let’s Encrypt安装教程&lt;/a&gt;
&lt;a href=&quot;http://tengine.taobao.org/book/chapter_02.html&quot;&gt;nginx平台初探(100%)&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a href=&quot;https://linghucong.js.org/2016/08/18/ubuntu_1604_web_server_config_LEMP/&quot;&gt;主要参考教程&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 02 Nov 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/11/02/mylinux-virginnight/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/11/02/mylinux-virginnight/</guid>
        
        <category>笔记</category>
        
        <category>服务器</category>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>用Charles在iOS上抓包</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Vue.js 放弃中…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;来总结一下用Charles在iOS上抓包的方法。&lt;/p&gt;

&lt;p&gt;本文分三个部分：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#0&quot;&gt;一、Mac客户端 下载安装激活&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#1&quot;&gt;二、Mac/iPhone证书 下载安装信任&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#2&quot;&gt;三、抓&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我是看不见的分割线&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p id=&quot;0&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一mac客户端-下载安装激活&quot;&gt;一、Mac客户端 下载安装激活&lt;/h2&gt;

&lt;p&gt;首先安装一枚Charles Mac版，俗称花瓶的抓包神器。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.charlesproxy.com/&quot;&gt;官网下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-10-17-1.png&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;如图所示下载最新版本&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;下载并安装后打开并激活,Charles提供15天的免费试用，购买正价为30$。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;顺便说一句，破解版Charles偶发中文乱码，抓包数据不显示等问题,而且更新也不及时，建议购买正版神器。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;打开Charles后，点击菜单栏的Proxy-&amp;gt;Proxy Settings…&lt;/p&gt;

&lt;p&gt;勾选：HTTP Proxy，并设置Port为8888。&lt;/p&gt;

&lt;p&gt;如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-10-17-2.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;http://image.lawootrip.com/2017-10-17-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;二iphone证书-下载安装信任&quot;&gt;二、iPhone证书 下载安装信任&lt;/h2&gt;

&lt;p&gt;安装好Mac客户端，就拿起手机开始配置iPhone了。&lt;/p&gt;

&lt;h3 id=&quot;先用mac建立同iphone的代理通道&quot;&gt;先用Mac建立同iPhone的代理通道&lt;/h3&gt;

&lt;p&gt;打开自己电脑的系统偏好设置-&amp;gt;网络-&amp;gt;选中现在连着的wifi,以查到自己这个电脑在现在这个wifi里的IP地址，比如我现在这个就是192.168.0.115（建议最好用私人或普通开放网络，用公司内网可能会有限制会出现代理失败的问题）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2155136-404b2e0bea921839.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后确保手机也连接了同一个wifi，然后进入手机的wifi配置(wifi名称右边的蓝色“i”图标)，将http代理改为:192.168.0.115；端口：8888。点击左上角返回。返回后系统会自动设置代理重新连接。&lt;/p&gt;

&lt;p&gt;这时候你的手机上网的过程中就要经过你的电脑了。刚用手机打开一个联网的程序，你的电脑上应该会显示一个弹窗问你【allow】还是【deny】肯定不能拒绝啊就点allow吧。这个只有第一次才弹窗。点了同意之后你手机发出的每一个请求都会被拦截出痕迹。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2469183-8630cf0087d20187.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2469183-874a256420dcae1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;注意：开启花瓶代理后，要关闭所有其他形式的代理，如爱国SS、爱国VPN等。&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;再安装ssl证书到手机设备&quot;&gt;再安装SSL证书到手机设备&lt;/h3&gt;

&lt;p&gt;点击 Help -&amp;gt; SSL Proxying -&amp;gt; Install Charles Root Certificate on a Mobile Device&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2469183-8f47a1b1c1540ef7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2469183-c7f6ad4a204b0bd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;出现弹窗得到地址&lt;a href=&quot;chls.pro/ssl&quot;&gt;chls.pro/ssl&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;在手机Safari浏览器输入地址 chls.pro/ssl，出现证书安装页面，点击安装
手机设置有密码的输入密码进行安装&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2469183-7ed4a5c8c2a36217.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;注意：安装信任证书需保持电脑对手机的代理状态&lt;/code&gt;&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;iOS 10.3及以上的系统，需要在 设置→通用→关于本机→证书信任设置 里面启用完全信任Charles证书&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-10-17-4.png&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;图示为iOS11界面&lt;/small&gt;&lt;/p&gt;

&lt;h3 id=&quot;最后charles设置proxy&quot;&gt;最后Charles设置Proxy&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2469183-2c460b4652797ccf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;Proxy -&amp;gt; SSL Proxying Settings…&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2469183-11eb2be75eae13fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;勾选Enable SSL Proxying,点击Add&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Host填写：*&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Port填写：443&lt;/code&gt;&lt;/p&gt;

&lt;p id=&quot;2&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;三抓&quot;&gt;三、抓&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;大

功

告

成

！
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;让手机重新发送https请求，可看到抓包&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2469183-5f1b21912781d466.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;注意：不抓包请关闭手机HTTP代理，否则断开与电脑连接后会连不上网&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Charles还有不少好玩的网络调试功能，等我放弃Vue了再来说说。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Tue, 17 Oct 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/10/17/charles-ssl/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/10/17/charles-ssl/</guid>
        
        <category>笔记</category>
        
        <category>效率</category>
        
        <category>前端</category>
        
        
      </item>
    
      <item>
        <title>Mac下重置MySQL的权限、密码</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Vue.js 放弃中…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;每次重启Mac后，我的Navicat都会提示本地的MySQL服务密码不对。&lt;/p&gt;

&lt;p&gt;每次都需要用sudo刷新MySQL权限才可以正常连接，即使重置密码，再次重启MySQL服务后，又提示密码不对。&lt;/p&gt;

&lt;p&gt;所以暂时先把命令行强行重置MySQL密码的方法记录如下，日后再研究如何彻底解决。&lt;/p&gt;

&lt;h2 id=&quot;mysql的三个基本命令&quot;&gt;MySQL的三个基本命令&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    sudo /usr/local/mysql/support-files/mysql.server start //启动

    sudo /usr/local/mysql/support-files/mysql.server stop //停止

    sudo /usr/local/mysql/support-files/mysql.server restart //重启

    sudo pkill -9 mysql //强制关闭进程
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;-三步重置mysql权限和密码&quot;&gt;* 三步重置MySQL权限和密码&lt;/h2&gt;

&lt;h4 id=&quot;第一步&quot;&gt;第一步&lt;/h4&gt;

&lt;p&gt;停止 mysql server.  通常是在 ‘系统偏好设置’ &amp;gt; MySQL &amp;gt; ‘Stop MySQL Server’&lt;/p&gt;

&lt;p&gt;也可以在命令行中用上面的命令终止MySQL。&lt;/p&gt;

&lt;h4 id=&quot;第二步&quot;&gt;第二步&lt;/h4&gt;

&lt;p&gt;新开一个终端，输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    sudo /usr/local/mysql/bin/mysqld_safe --skip-grant-tables
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此时MySQl应该又重新启动了。&lt;/p&gt;

&lt;h4 id=&quot;第三步&quot;&gt;第三步&lt;/h4&gt;

&lt;p&gt;再新开一个终端，依次输入并回车：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    sudo /usr/local/mysql/bin/mysql -u root

    UPDATE mysql.user SET authentication_string=PASSWORD('新密码') WHERE User='root';

　　 FLUSH PRIVILEGES;

 　　\q
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重启MySQL即可&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/WX20170812-125719@2x.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;清爽&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/08/12/mysql-psw/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/12/mysql-psw/</guid>
        
        <category>笔记</category>
        
        <category>MySQL</category>
        
        <category>数据库</category>
        
        
      </item>
    
      <item>
        <title>Web缓存的一些细碎02</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Vue.js 放弃中…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。&lt;/p&gt;

&lt;p&gt;本次从三个方面对学习进行小结。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#0&quot;&gt;一、H5缓存机制介绍&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#1&quot;&gt;二、H5缓存机制原理分析&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#2&quot;&gt;三、移动端Web加载性能（缓存）优化&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我是看不见的分割线&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p id=&quot;0&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一web缓存的作用&quot;&gt;一、web缓存的作用&lt;/h2&gt;

&lt;p&gt;H5，即 HTML5，是新一代的 HTML 标准，加入很多新的特性。离线存储（也可称为缓存机制）是其中一个非常重要的特性。H5 引入的离线存储，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。&lt;/p&gt;

&lt;p&gt;H5 应用程序缓存为应用带来三个优势：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;离线浏览，用户可以在无网络时使用产品&lt;/li&gt;
  &lt;li&gt;速度，已缓存的资源加载的更快&lt;/li&gt;
  &lt;li&gt;负载优化，浏览器只从服务器下载更新过或更改过的资源&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;H5目前的6种缓存机制在&lt;a href=&quot;http://www.lawootrip.com/2017/07/17/web-localstorage-Volume01/&quot;&gt;前一篇文章&lt;/a&gt;有提及。&lt;/p&gt;

&lt;p&gt;下面将首先分析各种缓存机制的原理、用法及特点；然后针对 Anroid 移动端 Web 性能加载优化的需求，看如果利用适当缓存机制来提高 Web 的加载性能。&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;二h5-缓存机制原理&quot;&gt;二、H5 缓存机制原理&lt;/h2&gt;

&lt;h3 id=&quot;21-浏览器缓存机制详解&quot;&gt;2.1 浏览器缓存机制详解&lt;/h3&gt;

&lt;p&gt;浏览器缓存机制是指通过 HTTP 协议头里的 Cache-Control（或 Expires）和 Last-Modified（或 Etag）等字段来控制文件缓存的机制。这应该是 WEB 中最早的缓存机制了，是在 HTTP 协议中实现的，有点不同于 Dom Storage、AppCache 等缓存机制，但本质上是一样的。可以理解为，一个是协议层实现的，一个是应用层实现的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cache-Control&lt;/strong&gt; 用于控制文件在本地缓存有效时长。最常见的，比如服务器回包：Cache-Control:max-age=600 表示文件在本地应该缓存，且有效时长是600秒（从发出请求算起）。在接下来600秒内，如果有请求这个资源，浏览器不会发出 HTTP 请求，而是直接使用本地缓存的文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Last-Modified&lt;/strong&gt; 是标识文件在服务器上的最新更新时间。下次请求时，如果文件缓存过期，浏览器通过 If-Modified-Since 字段带上这个时间，发送给服务器，由服务器比较时间戳来判断文件是否有修改。如果没有修改，服务器返回304告诉浏览器继续使用缓存；如果有修改，则返回200，同时返回最新的文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cache-Control&lt;/strong&gt; 通常与 Last-Modified 一起使用。一个用于控制缓存有效时间，一个在缓存失效后，向服务查询是否有更新。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cache-Control&lt;/strong&gt; 还有一个同功能的字段：Expires。Expires 的值一个绝对的时间点，如：Expires: Thu, 10 Nov 2015 08:45:11 GMT，表示在这个时间点之前，缓存都是有效的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Expires&lt;/strong&gt; 是 HTTP1.0 标准中的字段，Cache-Control 是 HTTP1.1 标准中新加的字段，功能一样，都是控制缓存的有效时间。当这两个字段同时出现时，Cache-Control 是高优化级的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Etag&lt;/strong&gt; 也是和 Last-Modified 一样，对文件进行标识的字段。不同的是，Etag 的取值是一个对文件进行标识的特征字串。在向服务器查询文件是否有更新时，浏览器通过 If-None-Match 字段把特征字串发送给服务器，由服务器和文件最新特征字串进行匹配，来判断文件是否有更新。没有更新回包304，有更新回包200。Etag 和 Last-Modified 可根据需求使用一个或两个同时使用。两个同时使用时，只要满足基中一个条件，就认为文件没有更新。&lt;/p&gt;

&lt;p&gt;另外有两种特殊的情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;手动刷新页面（F5)，浏览器会直接认为缓存已经过期（可能缓存还没有过期），在请求中加上字段：&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache-Control:max-age=0&lt;/code&gt;，发包向服务器查询是否有文件是否有更新。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;强制刷新页面（Ctrl+F5)，浏览器会直接忽略本地的缓存（有缓存也会认为本地没有缓存），在请求中加上字段：&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache-Control:no-cache&lt;/code&gt;（或 &lt;code class=&quot;highlighter-rouge&quot;&gt;Pragma:no-cache&lt;/code&gt;），发包向服务重新拉取文件。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面是通过 Google Chrome 浏览器（用其他浏览器+抓包工具也可以）自带的开发者工具，对一个资源文件不同情况请求与回包的截图。&lt;/p&gt;

&lt;p&gt;首次请求：200&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/241/923/2419230919-56fdeab9a8ba6_articlex&quot; alt=&quot;200&quot; /&gt;&lt;/p&gt;

&lt;p&gt;缓存有效期内请求：200(from cache)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/122/114/1221141305-56fdeaba76fb8_articlex&quot; alt=&quot;200 from cache&quot; /&gt;&lt;/p&gt;

&lt;p&gt;缓存过期后请求：304（Not Modified)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/135/686/135686075-56fdeabb2c2bc_articlex&quot; alt=&quot;304 from cache&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一般浏览器会将缓存记录及缓存文件存在本地 Cache 文件夹中。Android 下 App 如果使用 Webview，缓存的文件记录及文件内容会存在当前 app 的 data 目录中。&lt;/p&gt;

&lt;p&gt;分析：Cache-Control 和 Last-Modified 一般用在 Web 的静态资源文件上，如 JS、CSS 和一些图像文件。通过设置资源文件缓存属性，对提高资源文件加载速度，节省流量很有意义，特别是移动网络环境。但问题是：缓存有效时长该如何设置？如果设置太短，就起不到缓存的使用；如果设置的太长，在资源文件有更新时，浏览器如果有缓存，则不能及时取到最新的文件。&lt;/p&gt;

&lt;p&gt;Last-Modified 需要向服务器发起查询请求，才能知道资源文件有没有更新。虽然服务器可能返回304告诉没有更新，但也还有一个请求的过程。对于移动网络，这个请求可能是比较耗时的。有一种说法叫“消灭304”，指的就是优化掉304的请求。&lt;/p&gt;

&lt;p&gt;抓包发现，带 if-Modified-Since 字段的请求，如果服务器回包304，回包带有 Cache-Control:max-age 或 Expires 字段，文件的缓存有效时间会更新，就是文件的缓存会重新有效。304回包后如果再请求，则又直接使用缓存文件了，不再向服务器查询文件是否更新了，除非新的缓存时间再次过期。&lt;/p&gt;

&lt;p&gt;另外，Cache-Control 与 Last-Modified 是浏览器内核的机制，一般都是标准的实现，不能更改或设置。以 QQ 浏览器的 X5为例，Cache-Control 与 Last-Modified 缓存不能禁用。缓存容量是12MB，不分HOST，过期的缓存会最先被清除。如果都没过期，应该优先清最早的缓存或最快到期的或文件大小最大的；过期缓存也有可能还是有效的，清除缓存会导致资源文件的重新拉取。&lt;/p&gt;

&lt;p&gt;还有，浏览器，如 X5，在使用缓存文件时，是没有对缓存文件内容进行校验的，这样缓存文件内容被修改的可能。&lt;/p&gt;

&lt;p&gt;分析发现，浏览器的缓存机制还不是非常完美的缓存机制。完美的缓存机制应该是这样的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;缓存文件没更新，尽可能使用缓存，不用和服务器交互；&lt;/li&gt;
  &lt;li&gt;缓存文件有更新时，第一时间能使用到新的文件；&lt;/li&gt;
  &lt;li&gt;缓存的文件要保持完整性，不使用被修改过的缓存文件；&lt;/li&gt;
  &lt;li&gt;缓存的容量大小要能设置或控制，缓存文件不能因为存储空间限制或过期被清除。以X5为例，第1、2条不能同时满足，第3、4条都不能满足。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在实际应用中，为了解决 Cache-Control 缓存时长不好设置的问题，以及为了”消灭304“，Web前端采用的方式是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在要缓存的资源文件名中加上版本号或文件 MD5值字串，如 common.d5d02a02.js，common.v1.js，同时设置 Cache-Control:max-age=31536000，也就是一年。在一年时间内，资源文件如果本地有缓存，就会使用缓存；也就不会有304的回包。&lt;/li&gt;
  &lt;li&gt;如果资源文件有修改，则更新文件内容，同时修改资源文件名，如 common.v2.js，html页面也会引用新的资源文件名。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过这种方式，实现了：缓存文件没有更新，则使用缓存；缓存文件有更新，则第一时间使用最新文件的目的。即上面说的第1、2条。第3、4条由于浏览器内部机制，目前还无法满足。&lt;/p&gt;

&lt;h3 id=&quot;22-dom-storage-存储机制&quot;&gt;2.2 Dom Storage 存储机制&lt;/h3&gt;

&lt;p&gt;DOM 存储是一套在 Web Applications 1.0 规范中首次引入的与存储相关的特性的总称，现在已经分离出来，单独发展成为独立的 W3C Web 存储规范。 DOM 存储被设计为用来提供一个更大存储量、更安全、更便捷的存储方法，从而可以代替掉将一些不需要让服务器知道的信息存储到 cookies 里的这种传统方法。&lt;/p&gt;

&lt;p&gt;上面一段是对 Dom Storage 存储机制的官方表述。看起来，Dom Storage 机制类似 Cookies，但有一些优势。&lt;/p&gt;

&lt;p&gt;Dom Storage 是通过存储字符串的 Key/Value 对来提供的，并提供 5MB （不同浏览器可能不同，分 HOST)的存储空间（Cookies 才 4KB)。另外 Dom Storage 存储的数据在本地，不像 Cookies，每次请求一次页面，Cookies 都会发送给服务器。&lt;/p&gt;

&lt;p&gt;DOM Storage 分为 sessionStorage 和 localStorage。localStorage 对象和 sessionStorage 对象使用方法基本相同，它们的区别在于作用的范围不同。sessionStorage 用来存储与页面相关的数据，它在页面关闭后无法使用。而 localStorage 则持久存在，在页面关闭后也可以使用。&lt;/p&gt;

&lt;p&gt;Dom Storage 提供了以下的存储接口：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface Storage { 
readonly attribute unsigned long length; 
[IndexGetter] DOMString key(in unsigned long index); 
[NameGetter] DOMString getItem(in DOMString key); 
[NameSetter] void setItem(in DOMString key, in DOMString data); 
[NameDeleter] void removeItem(in DOMString key); 
void clear();
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;sessionStorage 是个全局对象，它维护着在页面会话(page session)期间有效的存储空间。只要浏览器开着，页面会话周期就会一直持续。当页面重新载入(reload)或者被恢复(restores)时，页面会话也是一直存在的。每在新标签或者新窗口中打开一个新页面，都会初始化一个新的会话。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
// 当页面刷新时，从sessionStorage恢复之前输入的内容
window.onload = function(){
  if (window.sessionStorage) {
      var name = window.sessionStorage.getItem(&quot;name&quot;);
      if (name != &quot;&quot; || name != null){
          document.getElementById(&quot;name&quot;).value = name;
      }
  }
};

// 将数据保存到sessionStorage对象中
function saveToStorage() {
  if (window.sessionStorage) {
     var name = document.getElementById(&quot;name&quot;).value;
     window.sessionStorage.setItem(&quot;name&quot;, name);
     window.location.href=&quot;session_storage.html&quot;;
 }
}
 &amp;lt;/script&amp;gt;

&amp;lt;form action=&quot;./session_storage.html&quot;&amp;gt;
  &amp;lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot;/&amp;gt;
  &amp;lt;input type=&quot;button&quot; value=&quot;Save&quot; onclick=&quot;saveToStorage()&quot;/&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当浏览器被意外刷新的时候，一些临时数据应当被保存和恢复。sessionStorage 对象在处理这种情况的时候是最有用的。比如恢复我们在表单中已经填写的数据。&lt;/p&gt;

&lt;p&gt;把上面的代码复制到 session_storage.html（也可以从附件中直接下载）页面中，用 Google Chrome 浏览器的不同 PAGE 或 WINDOW 打开，在输入框中分别输入不同的文字，再点击“Save”，然后分别刷新。每个 PAGE 或 WINDOW 显示都是当前PAGE输入的内容，互不影响。关闭 PAGE，再重新打开，上一次输入保存的内容已经没有了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/220/256/2202563205-56fe424093728_articlex&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/935/566/93556648-56fe423f1827f_articlex&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Local Storage 的接口、用法与 Session Storage 一样，唯一不同的是：Local Storage 保存的数据是持久性的。当前 PAGE 关闭（Page Session 结束后），保存的数据依然存在。重新打开PAGE，上次保存的数据可以获取到。另外，Local Storage 是全局性的，同时打开两个 PAGE 会共享一份存数据，在一个PAGE中修改数据，另一个 PAGE 中是可以感知到的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;
  //通过localStorage直接引用key, 另一种写法，等价于：
  //localStorage.getItem(&quot;pageLoadCount&quot;);
  //localStorage.setItem(&quot;pageLoadCount&quot;, value);
  if (!localStorage.pageLoadCount)
localStorage.pageLoadCount = 0;
     localStorage.pageLoadCount = parseInt(localStorage.pageLoadCount) + 1;
     document.getElementById('count').textContent = localStorage.pageLoadCount;
&amp;lt;/script&amp;gt;

&amp;lt;p&amp;gt;
    You have viewed this page
    &amp;lt;span id=&quot;count&quot;&amp;gt;an untold number of&amp;lt;/span&amp;gt;
    time(s).
&amp;lt;/p&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将上面代码复制到 local_storage.html 的页面中，用浏览器打开，pageLoadCount 的值是1；关闭 PAGE 重新打开，pageLoadCount 的值是2。这是因为第一次的值已经保存了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/202/620/2026209678-56fe4241451ef_articlex&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/836/137/836137524-56fe424228af7_articlex&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用两个 PAGE 同时打开 local_storage.html，并分别交替刷新，发现两个 PAGE 是共享一个 pageLoadCount 的。&lt;/p&gt;

&lt;p&gt;分析：Dom Storage 给 Web 提供了一种更录活的数据存储方式，存储空间更大（相对 Cookies)，用法也比较简单，方便存储服务器或本地的一些临时数据。&lt;/p&gt;

&lt;p&gt;从 DomStorage 提供的接口来看，DomStorage 适合存储比较简单的数据，如果要存储结构化的数据，可能要借助 JASON了，将要存储的对象转为 JASON 字串。不太适合存储比较复杂或存储空间要求比较大的数据，也不适合存储静态的文件等。&lt;/p&gt;

&lt;h4 id=&quot;23-web-sql-database存储机制&quot;&gt;2.3 Web SQL Database存储机制&lt;/h4&gt;

&lt;p&gt;H5 也提供基于 SQL 的数据库存储机制，用于存储适合数据库的结构化数据。根据官方的标准文档，Web SQL Database 存储机制不再推荐使用，将来也不再维护，而是推荐使用 AppCache 和 IndexedDB。&lt;/p&gt;

&lt;p&gt;现在主流的浏览器（点击查看浏览器支持情况）都还是支持 Web SQL Database 存储机制的。Web SQL Database 存储机制提供了一组 API 供 Web App 创建、存储、查询数据库。&lt;/p&gt;

&lt;p&gt;下面通过简单的例子，演示下 Web SQL Database 的使用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;
    if(window.openDatabase){
      //打开数据库，如果没有则创建
      var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024);

       //通过事务，创建一个表，并添加两条记录
      db.transaction(function (tx) {
           tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)');
           tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, &quot;foobar&quot;)');
           tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, &quot;logmsg&quot;)');
       });

      //查询表中所有记录，并展示出来
     db.transaction(function (tx) {
         tx.executeSql('SELECT * FROM LOGS', [], function (tx, results) {
             var len = results.rows.length, i;
             msg = &quot;&amp;lt;p&amp;gt;Found rows: &quot; + len + &quot;&amp;lt;/p&amp;gt;&quot;;
             for(i=0; i&amp;lt;len; i++){
                 msg += &quot;&amp;lt;p&amp;gt;&quot; + results.rows.item(i).log + &quot;&amp;lt;/p&amp;gt;&quot;;
             }
             document.querySelector('#status').innerHTML =  msg;
             }, null);
      });
}

&amp;lt;/script&amp;gt;

&amp;lt;div id=&quot;status&quot; name=&quot;status&quot;&amp;gt;Status Message&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将上面代码复制到 sql_database.html 中，用浏览器打开，可看到下面的内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/204/236/2042368915-56fe438fbfd26_articlex&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;官方建议浏览器在实现时，对每个 HOST 的数据库存储空间作一定限制，建议默认是 5MB（分 HOST）的配额；达到上限后，可以申请更多存储空间。另外，现在主流浏览器 SQL Database 的实现都是基于 SQLite。&lt;/p&gt;

&lt;p&gt;分析：SQL Database 的主要优势在于能够存储结构复杂的数据，能充分利用数据库的优势，可方便对数据进行增加、删除、修改、查询。由于 SQL 语法的复杂性，使用起来麻烦一些。SQL Database 也不太适合做静态文件的缓存。&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;2&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;三移动端-web-加载性能缓存优化&quot;&gt;三、移动端 Web 加载性能（缓存）优化&lt;/h2&gt;

&lt;p&gt;分析完 H5提供的各种缓存机制，回到移动端（针对 Android，可能也适用于 iOS）的场景。现在 Android App大多嵌入了 Webview 的组件（系统 Webview 或 QQ 游览器的 X5组件），通过内嵌Webview 来加载一些H5的运营活动页面或资讯页。这样可充分发挥Web前端的优势：快速开发、发布，灵活上下线。但 Webview 也有一些不可忽视的问题，比较突出的就是加载相对较慢，会相对消耗较多流量。&lt;/p&gt;

&lt;p&gt;通过对一些 H5页面进行调试及抓包发现，每次加载一个 H5页面，都会有较多的请求。除了 HTML 主 URL 自身的请求外，HTML外部引用的 JS、CSS、字体文件、图片都是一个独立的 HTTP 请求，每一个请求都串行的（可能有连接复用）。这么多请求串起来，再加上浏览器解析、渲染的时间，Web 整体的加载时间变得较长；请求文件越多，消耗的流量也会越多。我们可综合使用上面说到几种缓存机制，来帮助我们优化 Web 的加载性能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/129/554/1295547036-56fe42e54e817_articlex&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;结论：综合各种缓存机制比较，对于静态文件，如 JS、CSS、字体、图片等，适合通过浏览器缓存机制来进行缓存，通过缓存文件可大幅提升 Web 的加载速度，且节省流量。但也有一些不足：缓存文件需要首次加载后才会产生；浏览器缓存的存储空间有限，缓存有被清除的可能；缓存的文件没有校验。要解决这些不足，可以参考手 Q 的离线包，它有效的解决了这些不足。&lt;/p&gt;

&lt;p&gt;对于 Web 在本地或服务器获取的数据，可以通过 Dom Storage 和 IndexedDB 进行缓存。也在一定程度上减少和 Server 的交互，提高加载速度，同时节省流量。&lt;/p&gt;

&lt;p&gt;当然 Web 的性能优化，还包括选择合适的图片大小，避免 JS 和 CSS 造成的阻塞等。这就需要 Web 前端的同事根据一些规范和一些调试工具进行优化了。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt; 
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Tue, 18 Jul 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/07/18/web-localstorage-Volume02/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/18/web-localstorage-Volume02/</guid>
        
        <category>笔记</category>
        
        <category>Web前端</category>
        
        
      </item>
    
      <item>
        <title>Web缓存的一些细碎01</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Vue.js 放弃中…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。&lt;/p&gt;

&lt;p&gt;本次从三个方面对学习进行小结。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#0&quot;&gt;一、web缓存的作用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#1&quot;&gt;二、web缓存的类型&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#2&quot;&gt;三、浅析web缓存在浏览器端工作原理&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#3&quot;&gt;四、小结&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我是看不见的分割线&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p id=&quot;0&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一web缓存的作用&quot;&gt;一、web缓存的作用&lt;/h2&gt;

&lt;p&gt;主要三个方面：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;减少网络带宽消耗（当Web缓存副本被使用时，只会产生极小的网络流量，可以有效的降低运营成本。）&lt;/li&gt;
  &lt;li&gt;降低服务器压力（给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，间接降低服务器的压力。同时，搜索引擎的爬虫机器人也能根据过期机制降低爬取的频率，也能有效降低服务器的压力。）&lt;/li&gt;
  &lt;li&gt;减少网络延迟，加开页面打开速度。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;二web缓存的类型&quot;&gt;二、web缓存的类型&lt;/h2&gt;

&lt;p&gt;在Web应用领域，Web缓存大致可以分为以下几种类型：&lt;/p&gt;

&lt;h3 id=&quot;21-数据库数据缓存&quot;&gt;2.1 数据库数据缓存&lt;/h3&gt;

&lt;p&gt;web应用，特别是SNS类型的应用，往往关系比较复杂，数据库表繁多，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，会将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。比如常用的缓存方案有&lt;a href=&quot;http://www.runoob.com/Memcached/Memcached-tutorial.html&quot;&gt;memcached&lt;/a&gt; 等。&lt;/p&gt;

&lt;h3 id=&quot;22-服务器端缓存&quot;&gt;2.2 服务器端缓存&lt;/h3&gt;

&lt;p&gt;服务器端缓存包含代理服务器缓存和CDN缓存:&lt;/p&gt;

&lt;h4 id=&quot;221-代理服务器缓存&quot;&gt;2.2.1 代理服务器缓存&lt;/h4&gt;

&lt;p&gt;代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。可以把它理解为一个共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少相应时间和带宽使用方面很有效，同一个副本会被重用多次。常见代理服务器缓存解决方案有&lt;a href=&quot;http://www.phpfans.net/manu/Squid/&quot;&gt;Squid&lt;/a&gt; 等，这里不再详述。&lt;/p&gt;

&lt;h4 id=&quot;222-cdn缓存&quot;&gt;2.2.2 CDN缓存&lt;/h4&gt;

&lt;p&gt;CDN（Content delivery networks）缓存，也叫网关缓存、反向代理缓存。CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。虽然这种架构负载均衡源服务器之间的缓存没法共享，但却拥有更好的处扩展性。从浏览器角度来看，整个CDN就是一个源服务器。&lt;/p&gt;

&lt;h2 id=&quot;23-浏览器端缓存&quot;&gt;2.3 浏览器端缓存&lt;/h2&gt;

&lt;p&gt;浏览器缓存（Browser Caching）是浏览器端保存数据用于快速读取或避免重复资源请求的优化机制，有效的缓存使用可以避免重复的网络请求和浏览器快速地读取本地数据，整体上加速网页展示给用户。&lt;/p&gt;

&lt;h2 id=&quot;24-web应用层缓存&quot;&gt;2.4 Web应用层缓存&lt;/h2&gt;

&lt;p&gt;应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据，页面，图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;下面着重从浏览器端来看缓存工作机制和原理。&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;2&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;三浅析web缓存在浏览器端工作原理&quot;&gt;三、浅析web缓存在浏览器端工作原理&lt;/h2&gt;

&lt;p&gt;根据标准，到目前为止，H5 一共有6种缓存机制，有些是之前已有，有些是 H5 才新加入的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;浏览器缓存机制；&lt;/li&gt;
    &lt;li&gt;Dom Storgage 存储机制；&lt;/li&gt;
    &lt;li&gt;Web SQL Database 存储机制；&lt;/li&gt;
    &lt;li&gt;ApplicationCach（APPCache）机制；&lt;/li&gt;
    &lt;li&gt;Indexed Database (IndexdDB);&lt;/li&gt;
    &lt;li&gt;File System API;&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;31-浏览器缓存机制&quot;&gt;3.1 浏览器缓存机制&lt;/h3&gt;

&lt;h4 id=&quot;311-非http协议定义的缓存机制&quot;&gt;3.1.1 非HTTP协议定义的缓存机制&lt;/h4&gt;

&lt;p&gt;浏览器缓存机制，其实主要就是HTTP协议定义的缓存机制（如： Expires； Cache-control等）。但是也有非HTTP协议定义的缓存机制，如使用HTML Meta 标签，Web开发者可以在HTML页面的&amp;lt;head&amp;gt;节点中加入&lt;meta /&gt;标签，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;META HTTP-EQUIV=&quot;Pragma&quot; CONTENT=&quot;no-cache&quot;&amp;gt;

&amp;lt;META HTTP-EQUIV=&quot;Expires&quot; CONTENT=&quot;0&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为代理不解析HTML内容本身。下面主要介绍HTTP协议定义的缓存机制。&lt;/p&gt;

&lt;h4 id=&quot;312-http协议定义的缓存机制&quot;&gt;3.1.2 HTTP协议定义的缓存机制&lt;/h4&gt;

&lt;p&gt;通过 HTTP 协议头里的 Cache-Control（或 Expires）和 Last-Modified（或 Etag）等字段来控制文件缓存的机制。这应该是 WEB 中最早的缓存机制了，是在 HTTP 协议中实现的，有点不同于 Dom Storage、AppCache 等缓存机制，但本质上是一样的。可以理解为，一个是协议层实现的，一个是应用层实现的。&lt;/p&gt;

&lt;h4 id=&quot;313-http10时代缓存字段详解&quot;&gt;3.1.3 HTTP1.0时代缓存字段详解&lt;/h4&gt;

&lt;p&gt;2个字段：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Pragma：设置页面是否缓存，为Pragma则缓存，no-cache则不缓存。&lt;/li&gt;
  &lt;li&gt;Expires：有了Pragma来禁用缓存，自然也需要有个东西来启用缓存和定义缓存时间，对HTTP1.0而言，Expires就是做这件事的首部字段。Expires的值对应一个GMT（格林尼治时间），比如Mon, 22 Jul 2002 11:12:01 GMT来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。&lt;br /&gt;
如果Pragma头部和Expires头部同时存在，则起作用的会是Pragma，需要注意的是，响应报文中Expires所定义的缓存时间是相对服务器上的时间而言的，其定义的是资源“失效时刻”，如果客户端上的时间跟服务器上的时间不一致（特别是用户修改了自己电脑的系统时间），那缓存时间可能就没啥意义了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;314-http11-时代缓存字段详解&quot;&gt;3.1.4 HTTP1.1 时代缓存字段详解&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Cache-Control： 针对上述的“Expires时间是相对服务器而言，无法保证和客户端时间统一”的问题，http1.1新增了 Cache-Control 来定义缓存过期时间。&lt;strong&gt;注意：若报文中同时出现了 Expires 和 Cache-Control，则以 Cache-Control 为准。&lt;/strong&gt;
(1) 最常见的，比如服务器回包：Cache-Control:max-age=600 表示文件在本地应该缓存，且有效时长是600秒（从发出请求算起）。在接下来600秒内，如果有请求这个资源，浏览器不会发出 HTTP 请求，而是直接使用本地缓存的文件。
(2) Cache-Control: no-cache；这个很容易让人产生误解，使人误以为是响应不被缓存。实际上她是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。 
(3) Cache-Control: no-store；这个才是响应不被缓存的意思。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Last-Modified/If-Modified-Since：
(1) Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。 
(2) If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Etag/If-None-Match：Etag/If-None-Match也要配合Cache-Control使用。
(1) Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器觉得）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。
(2) If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;既生Last-Modified何生Etag？
你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题： 
(1) Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间。
(2) 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存。
(3) 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。
Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小结&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/web2017-07-17-01.png&quot; alt=&quot;浏览器第一次请求01&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;浏览器第一次请求&lt;/small&gt;
&lt;br /&gt;
&lt;img src=&quot;http://image.lawootrip.com/web-2017-07-17-02.png&quot; alt=&quot;浏览器第一次请求02&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;浏览器第二次请求&lt;/small&gt;&lt;/p&gt;

&lt;h4 id=&quot;32dom-storage-存储机制&quot;&gt;3.2Dom Storage 存储机制&lt;/h4&gt;

&lt;p&gt;DOM Storage 是指 HTML5 的本地存储 API sessionStorage 和 localStorage。在介绍HTML5本地存储之前，先来看一看前面几个存储方式的概念。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/391/641/3916412705-59312d0fceb14_articlex&quot; alt=&quot;Dom Storage&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;HTTP Cookie: Cookie是为了解决HTTP无状态的特性而出现的，也可以叫用户识别机制。常用的用户识别机制包括：
    &lt;ul&gt;
      &lt;li&gt;承载用户信息的HTTP首部&lt;/li&gt;
      &lt;li&gt;客户端IP地址追踪技术，通过用户的IP地址对其进行识别&lt;/li&gt;
      &lt;li&gt;用户登录，用认证机制来识别用户&lt;/li&gt;
      &lt;li&gt;胖URL，一种在URL中嵌入识别信息的技术&lt;/li&gt;
      &lt;li&gt;cookie，一种强大且高效的持久身份识别技术&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于购物网站而言，cookie是非常重要的，为了实现购物车功能，把已选物品加入cookie，可以实现不同页面之间数据的同步，同时在提交订单的时候又会把这些cookie传到后台，大大方便了前后端开发。设置cookie:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function setCookie(name, value, options) {
  var expires = options.expires;
  var path = options.path;
  var domain = options.domain;
  var secure = options.secure;

  // 缓存时间转为日期对象
  if (typeof expires === 'number') {
    expires = new Date(new Date().getTime() + expires * 864e+5); // 缓存时间单位：天
  }
    document.cookie =
    name + '=' + escape(value) +
    (expires ? '; expires=' + expires.toUTCString() : '') +
    (path ? '; path=' + path : '') +
    (domain ? '; domain=' + domain : '') +
    (secure ? '; secure' : '');

  return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;获取cookie:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function getCookie(name) {
  var arr = document.cookie.match(new RegExp('(^| )' + name + '=([^;]*)(;|$)'));
  if (arr !== null) {
    return unescape(arr[2]);
  }

  // return null;
  return '';
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;userData是微软在上世纪90年代的浏览器大战时推出的本地存储方案，借助DHTML的behaviour属性来存储本地数据， 允许每个页面最多存储64K数据，每个站点最多640K数据，userData的缺点显而易见，它不是Web标准的一部分，除非你的程序只需要支持IE， 否则它基本没什么用处。&lt;/li&gt;
  &lt;li&gt;Flash cookie的名字有些误导，它实际上和HTTP cookie并不是一回事，或许它的名字应该叫做”Flash本地存储”，Flash cookie默认允许每个站点存储不超过100K的数据，如果超出了，Flash会自动向用户请求更大的存储空间，借助Flash的 ExternalInterface接口，你可以很轻松地通过Javascript操作Flash的本地存储。Flash的问题很简单，就是因为它是 Flash。&lt;/li&gt;
  &lt;li&gt;Gears是Google在07年发布的一个开源浏览器插件，旨在改进各大浏览器的兼容性，Gears内置了一个基于SQLite的嵌入式 SQL数据库，并提供了统一API对数据库进行访问，在取得用户授权之后，每个站点可以在SQL数据库中存储不限大小的数据，Gears的问题就是 Google自己都已经不用它了。&lt;/li&gt;
  &lt;li&gt;HTML5 的本地存储 API sessionStorage 和 localStorage
Dom Storage 是通过存储字符串的 Key/Value 对来提供的，并提供 5MB （不同浏览器可能不同，分 HOST)的存储空间（Cookies 才 4KB)。另外 Dom Storage 存储的数据在本地，不像 Cookies，每次请求一次页面，Cookies 都会发送给服务器。
DOM Storage 分为 sessionStorage 和 localStorage。localStorage 对象和 sessionStorage 对象使用方法基本相同，它们的区别在于作用的范围不同。sessionStorage 用来存储与页面相关的数据，它在页面关闭后无法使用。而 localStorage 则持久存在，在页面关闭后也可以使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;简单用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var name = sessionStorage.setItem(&quot;name&quot;,&quot;wangjuan&quot;);
alert(sessionStorage.getItem(&quot;name&quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;并不是所有的浏览器都支持这两个对象。在没有原生支持localStorage的浏览器中使用时，MDN给出了兼容代码&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Guide/API/DOM/Storage#localStorage&quot;&gt;戳这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;不同浏览器对于这两种用法的差异的兼容代码可参考:&lt;a href=&quot;https://github.com/mortzdk/localStorage&quot;&gt;戳这里&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;33-web-sql存储机制&quot;&gt;3.3 Web SQL存储机制&lt;/h4&gt;

&lt;p&gt;H5 也提供基于 SQL 的数据库存储机制，用于存储适合数据库的结构化数据。根据官方的标准文档，Web SQL Database 存储机制不再推荐使用，将来也不再维护，而是推荐使用 AppCache 和 IndexedDB。
查看更多：&lt;a href=&quot;http://www.runoob.com/html/html5-web-sql.html&quot;&gt;戳这里&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;34-application-cache-机制&quot;&gt;3.4 Application Cache 机制&lt;/h4&gt;

&lt;p&gt;Application Cache（简称 AppCache)似乎是为支持 Web App 离线使用而开发的缓存机制。它的缓存机制类似于浏览器的缓存（Cache-Control 和 Last-Modified）机制，都是以文件为单位进行缓存，且文件有一定更新机制。但 AppCache 是对浏览器缓存机制的补充，不是替代。
AppCache 的原理有两个关键点：manifest 属性和 manifest 文件。
W3C 官方的一个例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/515/220/515220078-59315a8c9c8a6_articlex&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面 HTML 文档，引用外部一个 JS 文件和一个 GIF 图片文件，在其 HTML 头中通过 manifest 属性引用了一个 appcache 结尾的文件（即manifest文件）。
缓存的结果是：我们在 Google Chrome 浏览器中打开这个 HTML 链接，JS 功能正常，图片也显示正常。禁用网络，关闭浏览器重新打开这个链接，发现 JS 工作正常，图片也显示正常。当然也有可能是浏览缓存起的作用，我们可以在文件的浏览器缓存过期后，禁用网络再试，发现 HTML 页面也是正常的。
manifest 文件就是以 appcache 结尾的文件，是一个普通文件文件，列出了需要缓存的文件。
完整的 manifest 文件，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CACHE MANIFEST
# 2012-02-21 v1.0.0
/theme.css
/logo.gif
/main.js

NETWORK:
login.asp

FALLBACK:
/html/ /offline.html 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;了解更多：&lt;a href=&quot;http://www.cnblogs.com/lovesong/p/5021992.html?utm_medium=referral&quot;&gt;戳我&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;35-indexed-database&quot;&gt;3.5 Indexed Database&lt;/h4&gt;

&lt;p&gt;IndexedDB 也是一种数据库的存储机制，但不同于已经不再支持的 Web SQL Database。IndexedDB 不是传统的关系数据库，indexedDB中没有表的概念，类似于 Dom Storage 的 key-value 的存储方式，但功能更强大，且存储空间更大。它的特点是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;以key-value 的方式存取对象，可以是任何类型值或对象，包括二进制。&lt;/li&gt;
  &lt;li&gt;可以对对象任何属性生成索引，方便查询。&lt;/li&gt;
  &lt;li&gt;较大的存储空间，默认推荐250MB(分 HOST)，比 Dom Storage 的5MB要大的多。&lt;/li&gt;
  &lt;li&gt;通过数据库的事务（tranction）机制进行数据操作，保证数据一致性。&lt;/li&gt;
  &lt;li&gt;异步的 API 调用，避免造成等待而影响体验。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;了解更多：&lt;a href=&quot;http://www.cnblogs.com/dolphinX/p/3415761.html&quot;&gt;戳1&lt;/a&gt;和&lt;a href=&quot;http://www.cnblogs.com/dolphinX/p/3416889.html&quot;&gt;戳2&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;36-file-system-api&quot;&gt;3.6 File System API&lt;/h4&gt;

&lt;p&gt;File System API 是 H5 新加入的存储机制。它为 Web App 提供了一个虚拟的文件系统，就像 Native App 访问本地文件系统一样。由于安全性的考虑，这个虚拟文件系统有一定的限制。Web App 在虚拟的文件系统中，可以进行文件（夹）的创建、读、写、删除、遍历等操作。&lt;/p&gt;

&lt;p&gt;File System API 也是一种可选的缓存机制，和前面的 SQLDatabase、IndexedDB 和 AppCache 等一样。File System API 有自己的一些特定的优势：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以满足大块的二进制数据（ large binary blobs）存储需求。&lt;/li&gt;
  &lt;li&gt;可以通过预加载资源文件来提高性能。&lt;/li&gt;
  &lt;li&gt;可以直接编辑文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p id=&quot;3&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;四小结&quot;&gt;四、小结&lt;/h3&gt;

&lt;p&gt;反正我在放弃中，前端水深请小心。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://jixianqianduan.com/frontend-javascript/2015/12/28/nine-browser-cache-methods.html&quot;&gt;九种浏览器端缓存机制知多少&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/wangpenghui522/p/5498427.html#top&quot;&gt;浏览器缓存原理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.alloyteam.com/2012/03/web-cache-1-web-cache-overview/&quot;&gt;Web缓存机制系列
&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000002701423&quot;&gt;Web 前端实现本地存储&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.lawootrip.com/2017/07/18/web-localstorage-Volume02/&quot;&gt;H5 缓存机制浅析 - 移动端 Web 加载性能优化&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html&quot;&gt;浏览器缓存机制&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://mangguo.org/browser-cache-mechanism-detailed/&quot;&gt;浏览器缓存机制详解&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/skylar/p/browser-http-caching.html&quot;&gt;透过浏览器看HTTP缓存&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/vajoy/p/5341664.html&quot;&gt;浅谈浏览器http的缓存机制&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/zichi/p/4685822.html&quot;&gt;浏览器缓存机制浅析&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt; 
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Mon, 17 Jul 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/07/17/web-localstorage-Volume01/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/17/web-localstorage-Volume01/</guid>
        
        <category>笔记</category>
        
        <category>Web前端</category>
        
        
      </item>
    
      <item>
        <title>关于DNS解析优化的一些细碎</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;DNS优化，从入门到放弃。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;前段时间掉进了网站加载缓慢，数据还会丢包的大坑。&lt;/p&gt;

&lt;p&gt;在产品其他方面加紧优化的基础上，又赶紧研究了一下DNS的工作原理以及通常使用的优化技巧。&lt;/p&gt;

&lt;p&gt;现在从坑里爬出来了。&lt;/p&gt;

&lt;p&gt;喘口气&lt;/p&gt;

&lt;p&gt;本文将从以下六个方面对DNS优化进行了一些细碎的小结。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#0&quot;&gt;一、域名DNS解析原理和过程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#1&quot;&gt;二、浏览器加载网页的基本过程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#2&quot;&gt;三、合理利用DNS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#3&quot;&gt;四、合理使用DNS-prefetch让DNS预读取&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#4&quot;&gt;五、DNS域名解析拆分为多个域名增加并行下载量&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#5&quot;&gt;六、加快域名DNS解析速度方法小结&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;我是看不见的分割线&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p id=&quot;0&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一域名dns解析原理和过程&quot;&gt;一、域名DNS解析原理和过程&lt;/h3&gt;

&lt;h5 id=&quot;dns是怎么来的&quot;&gt;DNS是怎么来的?&lt;/h5&gt;

&lt;p&gt;DNS 是域名系统 (Domain Name System) 的缩写。在Internet上域名与IP地址之间是一对一(或者多对一)的，域名虽然便于人们记忆，但机器之间只能互相认识IP地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS就是进行域名解析的服务器。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-05-15-structure.PNG&quot; alt=&quot;DNS服务结构&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;DNS的树形结构&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，DNS服务器类型主要有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;内部 DNS ：位于内网中，提供内网 DNS 服务，也具备 Internet DNS 缓存与转发能力&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;外部 DNS：位于 Internet 中，提供 Internet 的 DNS 服务（包括 DNS 缓存与转发）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;主 DNS：提供 DNS 服务（包括查询，缓存写入）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;辅 DNS：只提供 DNS 查询服务，与主 DNS 同步数据库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;唯缓存 DNS：自身不具备 DNS 解析能力，但具有 DNS 缓存数据库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;转发 DNS：具备转发特性，能将 DNS 请求转发给其他 DNS 服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;权威 DNS： 自身数据库中存在与 DNS 请求相对应的映射&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;非权威 DNS：不存在相对应的映射，而存在对应缓存查询结果&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-05-15-DNS-process.png&quot; alt=&quot;DNS服务进程&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;DNS解析进程&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;上图的DNS解析过程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;龟龟(192.168.1.1) 在浏览器访问 http://www.lawootrip.com&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;192.168.1.1 检查本地 hosts 文件中是否存在 www.lawootrip.com 对应的 IP&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;若无，192.168.1.1 继续检查本地 DNS 缓存中是否存在 www.lawootrip.com 对应的 IP&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;若无， 192.168.1.1 向本地 DNS 服务器发起 DNS 查询请求&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;路由器接收到 DNS 查询请求后，检查路由器 DNS 缓存&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;若无，路由器以外网地址 202.202.202.202 向本地 DSN 服务器 （ISP DNS）发起 DNS 查询请求&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ISP DNS 接收到 DNS 查询请求后，发现自己不是权威 DNS ，且无对应的缓存数据，于是将请求转发给 其他 DNS 服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其他 DNS 服务器 接收到请求后，一样发现自己不是权威 DNS，且无对应的缓存数据，于是开始进行 DNS 迭代查询：将请求发送给根域名服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;根域名服务器接收到请求后，将顶级域名服务器 (.com) IP 发送给其他 DNS 服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其他 DNS 服务器根据 IP 将 DNS 查询请求发送给 顶级域名服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;顶级域名服务器接收到请求后，将 二级域名服务器 (jianshu.com) IP 发送给其他 DNS 服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其他域名服务器根据 IP 将 DNS 查询请求发送给二级域名服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;二级域名服务器 接收到请求后，发现自己是权威 DNS 服务器，于是将 www.lawootrip.com 映射的 IP 151.101.72.133 发送给其他域名服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其他域名服务器 接收到解析结果后，将 151.101.72.133 逐层返回传递下去，最终直至 192.168.1.1&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;15.192.168.1.1 接收到 www.lawootrip.com 解析结果 151.101.72.133 ，根据 IP 与 www.lawootrip.com 建立 TCP 连接，然后发起 HTTP 请求主页内容&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;二浏览器加载网页的基本过程&quot;&gt;二、浏览器加载网页的基本过程&lt;/h3&gt;

&lt;p&gt;1、从浏览器地址栏的请求链接开始，浏览器通过DNS解析查到域名映射的IP地址，成功之后浏览器端向此IP地址取得连接，成功连接之后，浏览器端将请求头信息通过HTTP协议向此IP地址所在服务器发起请求，服务器接受到请求之后等待处理。&lt;/p&gt;

&lt;p&gt;2、览器加载显示html的顺序是：从上到下，渲染的顺序也是从上到下，下载和渲染是同时进行的。如果遇到语义解释性的标签嵌入文件(JS脚本，CSS 下载过程会启用单独连接进行下载，并且在下载后进行解析，解析过程中，停止页面所有往下元素的下载。&lt;/p&gt;

&lt;p&gt;3、什么原因会导致网页加载过慢?浏览器可以在下载CSS资源的同时，并行解析HTML文件，但是，一旦发现有脚本文件的引用，则必须等待脚本文件完成下载并且执行后才能继续解析。内容下载时间主要取决于用户带宽、服务器带宽、文件大小、文件数量等。一般来说，将静态文件挂在CDN上，甚至全站CDN，往往能较好的解决这类问题。&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;2&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;三合理利用dns-ttl值-增加域名的缓存命中率&quot;&gt;三、合理利用DNS TTL值 增加域名的缓存命中率&lt;/h3&gt;

&lt;p&gt;1、DNS 服务器采用递归或迭代来处理客户端查询时，它们将发现并获得大量有关 DNS 命名空间的重要信息。然后这些信息由服务器缓存。缓存为 DNS 解析流行名称的后续查询提供了加速性能的方法，同时大大减少了网络上与 DNS 相关的查询通信量。&lt;/p&gt;

&lt;p&gt;2、TTL(Time-To-Live)即一条域名解析记录在DNS服务器上缓存时间。当信息缓存时，生存时间 (TTL) 值适用于所有缓存的 RR。只要缓存 RR 的 TTL 没有到期，DNS 服务器就可继续缓存并再次使用 RR 来应答与这些 RR 相匹配的客户端提出的查询。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-05-15-TTL.png&quot; alt=&quot;DNS服务进程&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;TTL设置&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;3、适当地增大TTL值可以让DNS Server缓存该域名更长时间，增加缓存的命中率。TTL一般默认为一小时，可以根据实际情况设为一天甚至一周以上。当然，如果你域名的IP经常变化，则TTL不应过大，否则各地的DNS Server会暂时无法获得新的正确的IP地址。&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;3&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;四合理使用dns-prefetch让dns预读取&quot;&gt;四、合理使用DNS-prefetch让DNS预读取&lt;/h3&gt;

&lt;p&gt;1、从上面浏览器加载网页的过程可以看出，网页的请求是可以多任务同时进行的，对于网页有多个DNS请求的情况，可以让浏览器在后台先把要使用的DNS请求默默地完成，这样当用户在打开新的网页时，就可以节省DNS查询的时间了。&lt;/p&gt;

&lt;p&gt;2、控制浏览器的DNS预读取就是DNS-prefetch标签了，DNS Prefetch应该尽量的放在网页的前面，&lt;/p&gt;

&lt;p&gt;格式类似是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;link rel=&quot;dns-prefetch&quot; href=&quot;//img.lawootrip.com&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;　
很多网站都使用使用百度广告联盟代码，使用这个就可以预读取DNS了。&lt;/p&gt;

&lt;p&gt;3、默认情况下浏览器会有隐式的DNS Prefetch，即会对页面中和当前域名(正在浏览网页的域名)不在同一个域的域名进行预获取，并且缓存结果，我们可以通过下面的标签禁止隐式的DNS Prefetch：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;meta http-equiv=”x-dns-prefetch-control” content=”off”&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4、需要注意的就是，DNS Prefetch只需要在用户在第一次打开网站时使用即可，没有必要每个页面都使用DNS Prefetch，否则就是重复DNS读取了，反而还无形中增加了DNS查询的次数，效果适得其反。&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;4&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;五dns域名解析拆分为多个域名增加并行下载量&quot;&gt;五、DNS域名解析拆分为多个域名增加并行下载量&lt;/h3&gt;

&lt;p&gt;1、一般来说网页的内容加载时会发生多个域名请求服务，如果你的网站JS、CSS、图片等非常多的话，建议将这些文件分别放在不同的域名上，这样浏览器在打开某一个页面时就可以同时向这些域名发送DNS解析请求了，能在一定程度上减少DNS时间。&lt;/p&gt;

&lt;p&gt;2、网页的内容越多，分析的域名应该尽量多一些。例如html、htm，js、css，jpg、png、gif，php、asp都可以放在不同的域名上。在实际应用上，使用全站CDN或者是静态文件CDN就可以实现上述效果，并且结合css sprite一起来使用的。&lt;/p&gt;

&lt;p&gt;3、css sprite(雪碧图)的作用恰恰相反，它不是增加域名请求，而减少域名DNS请求，主要是用在图片上。它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，这样一来，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;5&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;六加快域名dns解析速度方法小结&quot;&gt;六、加快域名DNS解析速度方法小结&lt;/h3&gt;

&lt;p&gt;1、以上就是一些简单的优化DNS小技巧，即时对个人开发者来说也没有什么门槛和技术难度，但是对提升网站的响应速度却有着明显的功效，大家不妨一试。&lt;/p&gt;

&lt;p&gt;2、除了从网站本身的DNS解析来加快访问速度外，我们平常在选择DNS服务时尽量使用那些稳定可靠的DNS服务，这样的DNS服务响应速度和缓存率都是非常不错的。假如自己的网站分拆了多个二级域名，不妨好好用用CNAME，设置好TTL时间，保证网站的第一次解析，可以直接从运营商的DNS缓存中拿到。&lt;/p&gt;

&lt;p&gt;此处顺便推荐三个神器，两个神服务。&lt;/p&gt;

&lt;p&gt;“DNSpod”作为NS服务商，免费稳定专业。&lt;/p&gt;

&lt;p&gt;“七牛云CDN”作为CDN服务商，免费稳定专业。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-05-15-shenqi.png&quot; alt=&quot;Chrles+Dig+微信web工具&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;Chrles+Dig+微信web工具&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;MAC环境下，推荐 &lt;strong&gt;Charles&lt;/strong&gt;用来进行数据抓包，网络通讯分析；&lt;strong&gt;Dig&lt;/strong&gt;用来检测DNS，GUI界面，简单直观好用；&lt;strong&gt;微信web工具&lt;/strong&gt;作为辅助，尤其是你的产品需要在微信内打开时，必备工具。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt; 
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Mon, 15 May 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/05/15/DNS-optimization/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/05/15/DNS-optimization/</guid>
        
        <category>笔记</category>
        
        <category>DNS</category>
        
        
      </item>
    
      <item>
        <title>浅析微信扫码登陆</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;实现微信登录，不一定要认证微信开放平台。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;话不多说，直接上图。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/25s.png&quot; alt=&quot;25s&quot; /&gt;&lt;/p&gt;

&lt;p&gt;先看登录二维码的分析，可以清楚看到页面先后加载了网页、图片、CSS、Javascript等资源文件，包括二维码图片。&lt;/p&gt;

&lt;p&gt;然后仔细观察会发现，网页会一直在异步请求一个链接，这个链接其实就是在监听服务器，如果有人用微信客户端授权成功，则会返回成功的信息然后跳转；否则继续监听。&lt;/p&gt;

&lt;p&gt;这个过程就是整个网页最重要的部分了，通过不断请求来监听状态。所以需要重点分析此请求。&lt;/p&gt;

&lt;p&gt;从图中我们还可以看到，右侧，每个请求都是用了25s左右。为什么要这么长时间呢？&lt;/p&gt;

&lt;p&gt;由于监听和登录操作肯定是短时间内必须完成的，比如我扫完二维码确认登录了，这个页面就要在短时间内做出响应。如果要做到这样，最简单的方法就是通过Javascript定时器，每隔几秒请求服务器并获取状态（事实上我同时也研究过新浪微博的扫二维码登录，它就是这样做的，每隔3-4秒左右请求一次）。然而这样会直接导致的问题就是，服务器会产生非常高的并发，小用户级别的服务器还没什么，但是像微信这种需要服务庞大用户群的服务器，就必须做这方面的优化。&lt;/p&gt;

&lt;p&gt;所以微信的采用的做法就是减少请求并增加响应时间，实现的原理大概就是在服务器端接收到请求后，内部加个定时器不断检查用户授权的状态，如果检测到用户授权则马上响应给网页端；否则继续检查；当时间累积到25秒左右，不论成不成功都终止检测并立即响应给网页端。&lt;/p&gt;

&lt;p&gt;好了，我们接下来继续观察这个请求的参数：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/17-04-26-query.png&quot; alt=&quot;query&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到总共有五个参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;loginicon ：布尔值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;uuid：字符串&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;tip ：正整数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;r：负整数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;_：正整数&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从字面上来理解的话，&lt;/p&gt;

&lt;p&gt;第一个参数大概意思是，是否要有登录图标（true=&amp;gt;要，false=&amp;gt;不要）；&lt;/p&gt;

&lt;p&gt;第二个参数，是指二维码的值，随便测试下就知道了；&lt;/p&gt;

&lt;p&gt;第三个参数，应该是指是否要提示（1=&amp;gt;要，0=&amp;gt;不要）；&lt;/p&gt;

&lt;p&gt;第四个参数，应该是一个随机数（random）；&lt;/p&gt;

&lt;p&gt;第五个参数，不难看出这是个Unix时间戳。随机数和时间戳跟安全机制有关吧，防止相关的攻击，如重放攻击。&lt;/p&gt;

&lt;p&gt;这几个参数当中，最重要的是当然是uuid了，因为这是用来向服务器请求授权状态的凭借。并且这个uuid必须是唯一不重复的，不然试想下，两个人在不同的电脑下浏览到了同一个二维码，有人授权登录了，可能会是在另一个人电脑上登录微信的网页版。所以说这个唯一的uuid是专门用来绑定一个微信账号的授权的。&lt;/p&gt;

&lt;p&gt;因为uuid一般是随机生成的，但是像这里的这串字符，观察最后两个字符“==”，又像是经过某个加密算法产生的，不过这并不太重要，确保到uuid的唯一不重复性就行了。至于r这个参数，我个人猜测这是个随机数。最后一个参数是用来做超时验证操作的，确保一个uuid只在短时间内有效，如果你仔细观察，会发现二维码登录页在几分钟内不登录，那么它会自动刷新然后更新过另外一个二维码。最后利用这三个进行某种算法之后生成签名（下面提到的ticket值）返回给客户端。&lt;/p&gt;

&lt;p&gt;接下来我们看看这个请求的返回值：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/17-04-26-response.png&quot; alt=&quot;response&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从图中我们可以看到返回的是一条Javascript语句，有个状态码408，这个就是表示用户还没有用微信客户端APP授权，需要继续请求监听状态。如果是授权成功，则返回200，然后登录页会跳转到后台：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;window.code=200;
window.redirect_uri=&quot;https://wx.qq.com/cgi-bin/mmwebwx-bin/webwxnewloginpage?ticket=AV09Uzr8oDEF1xoAcaOdNUi@articket_0&amp;amp;uuid=wdBJJLlfaQ==&amp;amp;lang=zh_CN&amp;amp;scan=1431123223&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;ticket值就是服务器生成的用户签名，理解为access_token即可。&lt;/p&gt;

&lt;p&gt;再来看看微信客户端APP扫描二维码后的页面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/17-04-26-app.PNG&quot; alt=&quot;app&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当扫描成功二维码后，会弹出授权窗口，询问是否授权登录。&lt;/p&gt;

&lt;p&gt;换个二维码扫描软件可以得到登录时候的二维码字符串实际值如图。经过多次试验可以知道前半段不变的，只有后面的参数会变（&lt;strong&gt;即uuid值&lt;/strong&gt;）。&lt;/p&gt;

&lt;p&gt;所以分析得到微信客户端的步骤是这样的：&lt;/p&gt;

&lt;p&gt;1.扫描二维码（扫一扫）&lt;/p&gt;

&lt;p&gt;2.如果字符串前半段是https://login.weixin.qq.com/l/，则弹出授权窗口&lt;/p&gt;

&lt;p&gt;3.如果点击确定，再向服务器请求改变这个uuid的状态&lt;/p&gt;

&lt;p&gt;完整的流程图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/17-04-26-flow-chart.jpg&quot; alt=&quot;flow-chart&quot; /&gt;&lt;/p&gt;

&lt;p&gt;至此，整个的扫二维码登录流程就完成了。&lt;/p&gt;

&lt;p&gt;至于如何利用在此剖析的原理进行二次开发和利用，就尽情发挥你的聪明才智吧。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt; 
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

</description>
        <pubDate>Wed, 26 Apr 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/04/26/https-con/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/26/https-con/</guid>
        
        <category>笔记</category>
        
        <category>微信</category>
        
        
      </item>
    
      <item>
        <title>各种加密代理协议的简单对比</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;目前我们常用的加密代理有协议有 HTTPS，SOCKS5-TLS 和 shadowsocks,此文从各个角度简单分析各个协议的优劣，以帮助各位选择合适的协议。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本文将从&lt;a href=&quot;#0&quot;&gt;性能&lt;/a&gt;、&lt;a href=&quot;#1&quot;&gt;数据安全性&lt;/a&gt;、&lt;a href=&quot;#2&quot;&gt;抗识别&lt;/a&gt;、&lt;a href=&quot;#3&quot;&gt;部署难度&lt;/a&gt;、&lt;a href=&quot;#4&quot;&gt;功能&lt;/a&gt;，五个方面对各类协议进行对比阐述。&lt;/p&gt;

&lt;p&gt;先简单说些背景知识，以上协议都是基于 TCP 的代理协议，代理协议（Proxy Procotol）与 VPN 不同，仅可被用于通过代理服务器转发 TCP 连接（shadowsocks 支持代理 UDP），而 VPN 可被用于 IP 层上的所有协议，如 TCP、UDP、ICMP 等。所以在使用代理时，ping 等 ICMP 应用是不可以被代理的。&lt;/p&gt;

&lt;p&gt;然后简单解释一下什么是 TLS，TLS 又名 SSL，是针对数据流的安全传输协议。简单来说，一个 TCP 链接，把其中原本要传输的数据，按照 TLS 协议去进行加密传输，那么即可保证其中传输的数据安全。这个安全至少体现在以下几个方面：&lt;/p&gt;

&lt;p&gt;数据被加密，任何可以截取到 TCP 数据流的人，无法解密出原始数据；
数据不可被篡改，一旦篡改会导致解密失败，连接断开；
服务器身份验证，基于 X509 的证书体系去确认目标服务器是否为真实的服务器。
明文的 HTTP 套上一层 TLS，也就变成了 HTTPS，SOCKS5 套上 TLS，就变成了 SOCKS5-TLS。TLS 协议是整个互联网安全的基石，几乎所有需要安全传输的地方都使用了 TLS，如银行、政府等等。&lt;/p&gt;

&lt;p&gt;当被用作代理协议时，HTTP 层和 SOCKS5 层去进行具体的代理连接控制，如进行身份验证、告知需要转发的目标主机名等。所以不需要 TLS 他们也可以用作代理，只不过所有数据都是明文传输，不具备安全性。加上 TLS 后，由 TLS 去保证安全。而 shadowsocks 协议则融合了代理控制和安全保证。所以后文的很多对比实际上是 shadowsocks 和 TLS 的对比。&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;0&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;性能&quot;&gt;性能&lt;/h1&gt;

&lt;p&gt;TLS 协议由于承担了一项额外的功能，需要验证目标服务器身份，导致其握手时会比较复杂。&lt;/p&gt;

&lt;p&gt;ping 的时间表示，一个 IP 层数据包从本地发出，到服务器再返回的来回时间，即 RTT（round-trip time）。&lt;/p&gt;

&lt;p&gt;在发起代理连接时，首先我们需要进行 TCP 3 次握手，耗时为 1 个 RTT。（此处把最后的 ACK 直接并入后续的数据传输部分）。&lt;/p&gt;

&lt;p&gt;然后进行 TLS 握手，因为服务端和客户端需要进行身份验证并协商协议版本号、加密方式等细节，第一次连接时需要 2 个 RTT。当然 TLS 的制定者也发现这太慢了，于是引入了 TLS Session Resumption，当服务端和客户端服务器连接过一次后，之后的连接可以直接复用先前的协商结果，使得 RTT 降低到 1 个 RTT。但这需要服务器和客户端的支持。（这是为什么 Surge benchmark 时，对于 TLS 代理第一次的测试结果可能较慢的原因之一）&lt;/p&gt;

&lt;p&gt;对于 HTTPS 协议，当 TLS 连接建立后，客户端通过 HTTP 层发起代理请求，服务端回应连接建立，此后进入正常的代理通讯环节，再耗费 1 个 RTT。&lt;/p&gt;

&lt;p&gt;对于 SOCKS5-TLS 协议，当 TLS 连接建立后，如果没有验证的环节，那么需要再耗费 1 个 RTT，如果有验证（用户名密码），那么需要耗费 2 个 RTT。&lt;/p&gt;

&lt;p&gt;而对于 shadowsocks，由于使用的是预共享密钥（pre-shared key, PSK），加密方式也是预先约定好的，所以不需要进行协商，只需要在 TCP 建立之后，再耗费一个 1 个 RTT 告知目标主机名。&lt;/p&gt;

&lt;p&gt;总结如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTPS（TLS Session Resumption）：3 个 RTT

SOCKS5-TLS 无验证：3 个 RTT

SOCKS5-TLS 有验证：4 个 RTT

shadowsocks：2 个 RTT
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;（注：最后一个 RTT 并不严谨，因为客户端可以在最后一个 RTT 产生响应前，直接开始后续传输。另外如果使用了 TCP Fast Open，可以看作 TCP 阶段 RTT 为 0。）&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;对于日常使用，最影响性能的就是握手速度，后续传输过程中的加解密性能，对于现代 CPU 来说基本都不会构成瓶颈。 shadowsocks 由于有 PSK 的特点，在 TCP 协议基础上已经达到极限，不可能有协议能再低于 2 个 RTT。&lt;/p&gt;

&lt;p&gt;所以，同等网络环境下，shadowsocks 是明显快于 HTTPS 的。（体现在延迟上，而不是带宽）&lt;/p&gt;

&lt;p&gt;另外，最新的 TLS 1.3 协议正力图解决这个问题，由于目前还处于草案阶段，各种工具链不完善，现在不太好评估实际效果。&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;数据安全性&quot;&gt;数据安全性&lt;/h1&gt;

&lt;p&gt;（此处说的数据安全性，指的是加密后的流量是否会被截取并破解的问题。）&lt;/p&gt;

&lt;p&gt;对于 TLS，作为个人用户，丝毫不用担心，TLS 协议如果真的不安全了，世界早就乱套了…&lt;/p&gt;

&lt;p&gt;对于 shadowsocks，使用的加密方法也都是工业上成熟的算法，从数据安全性角度考虑也基本不用担心。&lt;/p&gt;

&lt;hr /&gt;

&lt;p id=&quot;2&quot;&gt;&lt;/p&gt;

&lt;h1 id=&quot;抗识别&quot;&gt;抗识别&lt;/h1&gt;

&lt;p&gt;这个问题有两个角度需要考虑：&lt;/p&gt;

&lt;p&gt;观察一段数据流量，是否能判别这是一个代理协议的流量；
对于一个仅暴露出 TCP 端口的黑箱，能否判断这个端口提供了代理服务。
对于 shadowsocks 协议，在第一点上，观察者只能判定这个数据流为未知的协议。而第二点，shadowsocks 的几次修改，都是因为在这出了问题，目前最新的 AEAD 加密方式，应该已经解决了这个问题，但还需要时间去检验。&lt;/p&gt;

&lt;p&gt;对于 HTTPS 协议，在第一点上，观察者是无法去区分这是一个代理还是一个标准的 HTTPS 网页访问的。而第二点，在妥善配置的情况下，也是完全无法判别。&lt;/p&gt;

&lt;p&gt;但在实践中，大部分 HTTPS 代理服务器为了兼容浏览器行为，在直接被当做 HTTPS Web 服务器访问时，会返回代理错误页或者 407 Proxy authentication required，直接暴露了自己是一个代理，如果要抗击第二点，可以将服务端的行为修改为，如果请求的 Header 中，不包含一个有效的 Auth，那么就返回一个标准的 200 页面，这样从理论上杜绝了被嗅探的可能。&lt;/p&gt;

&lt;p&gt;总结一下，最新的 shadowsocks 已经能满足抗识别的两个要求，但是观察者得到结论是“未知协议”。而使用 HTTPS，观察者无法判断这是一个 HTTPS 代理还是 HTTPS Web 服务器，这是更优的结果。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hiding true identities inside a seemingly ordinary. — Person of Interest S03E23&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;p id=&quot;3&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;部署难度&quot;&gt;部署难度&lt;/h1&gt;

&lt;p&gt;HTTPS 协议使用广泛，有众多成熟的工业级工具，如 squid，haproxy，nghttp2 等等，但是由于 HTTPS 协议本身比较复杂，配置起来参数众多，有很多性能相关参数需要自己调优，所以一般用户配置起来会有难度。&lt;/p&gt;

&lt;p&gt;shadowsocks 经过多年发展，目前也已经有众多的软件支持，但是对于不同特性的支持度不一。由于参数简单，部署配置起来极其方便。&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;4&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;功能&quot;&gt;功能&lt;/h1&gt;

&lt;p&gt;shadowsocks 目前还存在一些功能上的缺陷：&lt;/p&gt;

&lt;p&gt;1.shadowsocks 没有设计错误回报机制，对于以下错误，客户端看到的行为都是服务器主动断开 TCP 连接：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;密钥或者加密方法错误&lt;/li&gt;
  &lt;li&gt;目标主机名 DNS 解析失败&lt;/li&gt;
  &lt;li&gt;目标主机不可达&lt;/li&gt;
  &lt;li&gt;目标主机拒绝连接&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2.这使得客户端没办法根据不同的错误采取进一步的动作，只能简单的向用户返回 Socket closed by remote 错误。&lt;/p&gt;

&lt;p&gt;3.shadowsocks 没有考虑用户鉴别，使得服务端 ACL 或者流量统计等功能无法实现，主流的 workaround 是通过不同的端口号去识别不同的用户，但这极其浪费资源且很不优雅。
部分 ISP 对于非 HTTP 和 TLS 的未知流量，会进行降速限制，这个可以通过配置 obfs 解决。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt; 
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Tue, 18 Apr 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/04/18/https-con/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/18/https-con/</guid>
        
        <category>笔记</category>
        
        <category>代理协议</category>
        
        
      </item>
    
      <item>
        <title>美国《消费者报告》简史</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;CR知多少&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;几百年前很少有人因选东西而烦恼，产品种类少，构造简单，短时间上手就能判断好坏。近代科学技术的爆发改变了一切。企业和品牌喷涌而出，商品市场如雨林般繁复，很多产品的微妙区别已经超出普通人的辨识范围。&lt;/p&gt;

&lt;p&gt;选购之时我们常说这个好、那个坏，产品好坏究竟指什么？性能、安全性、可靠性，还是多种指标的综合？如果是性能，有哪些指标，哪个是核心指标？如果是可靠性，用什么来衡量？&lt;/p&gt;

&lt;p&gt;当你想要了解商品知识时，离你最近的是喧嚣的媒体和广告——请仔细思量：广告是什么？广告是企业发明出来蛊惑人心的玩意儿，绝大部分混杂着诡计和套路。对选购来说，它们是迷宫，是泥沼，是错误的路标。&lt;/p&gt;

&lt;p&gt;然而在很长一段时间里，人们只能以流言和广告为基础，凭感觉进行选购。面对狡猾的企业，绝大部分消费者像猴子一样无知。&lt;/p&gt;

&lt;p&gt;直到二十世纪初，形势才稍有改善。当时的美国，强国气象已现，新玩意儿层出不穷，少数人不甘心被大众媒体愚弄，一种组织应运而生。&lt;/p&gt;

&lt;p&gt;1927 年，消费者历史上一本重要的书诞生了：《Your Money’s Worth》，作者便是日后消费者运动的两员大将：Frederick J. Schlink（富理德里克·J·施林克） 和 Stuart Chase（斯图尔特·蔡斯） 。
&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-2.png&quot; alt=&quot;2&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;《Your Money’s Worth》封面，来源：raretradingbooks&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;这本书详细介绍了食品、医药、汽车、家电等领域的诡计陷阱和过度广告。大获成功之后，施林克和斯图尔特趁热打铁创立了 Consumer Club（消费者俱乐部），经过两年的呼吁和准备， 1929 年又成立了 Consumers Research（消费者研究）。
&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-3.png&quot; alt=&quot;3&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;施林克和消费者研究实验室，来源：consumersresearch.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;这是一个什么样的组织？它致力于测试各式产品，发布商品指南，指导人们选购。&lt;/p&gt;

&lt;p&gt;它是一个非营利性组织，也是世界上第一个消费者组织。自此之后，消费者组织在美国和世界各地陆续出现，并由消费者研究确立了两大原则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;独立于企业，不接受企业送测和资助。&lt;/li&gt;
  &lt;li&gt;无商业广告，资金主要来自消费者订阅和捐赠。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;到了 1933 年，消费者研究已经有了 42000 名订阅者，但没过多久，消费者运动历史上最大的转折出现了。&lt;/p&gt;

&lt;p&gt;1933 年， 施林克决定把总部从纽约搬到华盛顿乡村，这一举动引发了不满。因工作时间长、工资低，几名员工要求加薪，但被施林克立刻拒绝。1935 年，三名员工组建了工会，施林克知道后炒了他们。此举激怒了众人，大家决定罢工，要求恢复解聘者职位并提高工资。&lt;/p&gt;

&lt;p&gt;施林克怎么回应？他拒绝调解和仲裁，雇人进行报复，还指控罢工者是共产主义者。这实在是一件很讽刺的事情，一个号称维护公共利益的组织，却掉过头来对付自己的员工。&lt;/p&gt;

&lt;p&gt;罢工者和支持者们都很愤怒，遂决定另起炉灶。1936 年，在 Arthur Kallet（阿瑟·卡莱特）、Colston Warne（科尔斯顿·沃恩）等人的带领下， Consumers Union（消费者联盟）成立了，并出版一份叫 Consumers Union Reports（消费者联盟报告）的杂志 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-4.png&quot; alt=&quot;4&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;左为阿瑟·卡莱特，右为科尔斯顿·沃恩，来源：Consumer Reports - Kevin P. Manion&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;此时的消费者联盟报告，就是日后消费者运动中神祇一般的存在——Consumer Reports（消费者报告）。（PS：下文统称为 CR）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-5.png&quot; alt=&quot;5&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;1936 年 5 月，第一期 CR 出版，评测了肥皂、丝袜、牛奶等产品，来源：consumerreports.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;CR 从一诞生就受到多方夹击：&lt;/p&gt;

&lt;p&gt;一面是同行的抵制， 曾有 60 多种出版物拒绝刊登 CR 的募捐广告。 Reader’s Digest （读者文摘） 认为 CR 想给经济体系抹黑，Good Housekeeping（好管家） 谴责 CR 通过打破大众对广告组织的信任，延长了大萧条（PS：当时大萧条刚结束不久）。&lt;/p&gt;

&lt;p&gt;一面是消费者研究的打压，施林克不断指控消费者联盟是共产主义组织，终于在 1939 年，消费者联盟被 HUAC（非美活动调查委员会）列入 Subversive Organizations（颠覆性组织）名单，直到 1954 年才从名单中去除。&lt;/p&gt;

&lt;p&gt;最初，CR 的订阅量只有 4000，到了1936 年底，订阅量已经超过了 37000 。由于资金短缺，早期只能评测牛奶、丝袜、热水瓶、收音机、风扇等等便宜货。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-6.png&quot; alt=&quot;6&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;30年代，CR探讨了过度广告、维生素过度补充、吸烟危害等问题，来源：consumerreports.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;今人或许难以想象，二十世纪初的美国，避孕用品仍被视为「淫秽物品」， 1873 年通过的禁止淫秽作品和不道德物品的《康斯托克法》，在当时仍然有效。&lt;/p&gt;

&lt;p&gt;1937 年 ，CR 出版了《避孕用品报告》，却被邮局告知禁止寄送。CR 随即把邮局告上法庭，历时七年，法院最终否决了该禁令。&lt;/p&gt;

&lt;p&gt;1939 年，CR 的订阅量达到到 85000，然而第二次世界大战改变了一切。战争时期，制造业集中生产军用品，民众对评测的需求变小，市面上也没多少商品可供评测。&lt;/p&gt;

&lt;p&gt;到 1942 年 ，CR 的订阅量下滑到 1939 年的一半。这一年，Consumers Union Reports（消费者联盟报告）改名为 Consumer Reports（消费者报告）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-7.png&quot; alt=&quot;7&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;上世纪 40 年代，CR 批评利用战时产品短缺谋取高利的企业，揭露无用的「科学」助眠产品，并在战后给出汽车选购建议，来源：consumerreports.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;二战结束，人们继续买买买， CR 迎来大发展。1946 年的订阅量达到 10  万，1950 年，订阅量到达 40 万。&lt;/p&gt;

&lt;p&gt;1947 年，CR 测试了自动洗衣机，1952 年，发布第一份汽车维修频率表，1954 年，发布第一份彩色电视评测，1958 年，抨击用低电压刺激肌肉的减肥产品。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-8.png&quot; alt=&quot;8&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;上世纪 50 年代，CR 呼吁安全带应当成为汽车标配，来源：consumerreports.orgg&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;1954 年，CR 董事会决定把总部从纽约市搬到纽约州弗农山，办公室和试验室得以扩大，并添置了新的测试设备。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-9.png&quot; alt=&quot;9&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;1954 年，CR 迁到新总部，来源：Consumer Reports - Kevin P. Manion&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;迁到新家之后，CR 决定不再只是评测商品，开始更多介入消费者相关的事务。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-10.png&quot; alt=&quot;10&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;1954 年，读者参观 CR 的实验室，来源：Consumer Reports - Kevin P. Manion&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;50 年代末，CR 的实力更加强大，开始向其他消费者组织援助，并致力于领导世界范围内的消费者运动，协助成立了 IOCU（国际消费者联盟），即现在的 CI（国际消费者协会）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-11.png&quot; alt=&quot;11&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;1960 年，IOCU 成立，来源：Consumer Reports - Kevin P. Manion&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;在 50 年代末 60 年代初，CR 进行了几项核试验对日常饮食影响的研究（如 1959 年对牛奶的调查），促使政府加强对核辐射灰尘的监测，并赢得公众对禁止核试验条约的支持。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-12.png&quot; alt=&quot;12&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;1961 年的核辐射避难所宣传图，来源：invisiblethemepark&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;有趣的是，冷战期间很多读者请求 CR 发布「核辐射避难所」指南，但由于其中的复杂变量和未知因素太多，消费者报告拒绝评测。为了照顾读者，最终分享了一位科学家的个人建造经验。&lt;/p&gt;

&lt;p&gt;1962 年，CR 发布了第一份汽车保险报告，并推动车险改革。1965 年， Ralph Nader 出版著名图书《Unsafe at Any Speed》，随后 CR 邀请他加入董事会，为汽车评测提供建议。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-13.png&quot; alt=&quot;13&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;上世纪 60 年代，汽车数量增加，CR 呼吁错开上班时间，增加公共交通工具，来源：consumerreports.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;在 Ralph Nader 的影响下，CR 评测汽车的流程和方法越来越专业。当时 CR 汽车评测的影响力有多大？1965 年， CR 把  Toyota（丰田）Corona 评为「特别适合长途驾驶」， 1975 年，Corona 成了美国汽车市场进口最多的一款车型。&lt;/p&gt;

&lt;p&gt;CR 历史上长期关注过几类产品，有汽车、儿童用品，以及香烟。&lt;/p&gt;

&lt;p&gt;在二十世纪早期，吸烟危害并未成为共识，并且在烟草行业的鼓吹下，吸烟被认为是一件尊贵、性感和潇洒的事情：&lt;/p&gt;

&lt;p&gt;一个著名的契斯特菲尔德牌香烟广告给出这样一幅场景：一位优雅的男士和一位迷人的女士浪漫地坐在海边，男人正在点燃一根卷烟，旁白是： 「呼出我的风格。」来源：钓愚：操纵与欺骗的经济学 - 乔治·阿克洛夫、罗伯特·席勒&lt;/p&gt;

&lt;p&gt;从 1953 到 1964 年，CR 不断发文探讨吸烟危害，揭露烟草行业的诡计，并在 1963  年出版《消费者联盟关于吸烟与公共利益的报告》。&lt;/p&gt;

&lt;p&gt;1964 年，美国卫生总署《吸烟与健康》 出台，以政府立场明确了吸烟危害，文中引用了 CR 的报告。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-14.png&quot; alt=&quot;14&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;1968 年 11 月，CR 评测了电动玩具，来源：consumerreports.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;1968 年，CR 测试了多款电动玩具，发现其中四分之一存在风险，将它们评为「不可接受」。1969 年，在这项测试的促进下，《保护儿童和玩具安全法案》通过。&lt;/p&gt;

&lt;p&gt;1972 年，在 CR 的推动下，《消费者产品安全法》通过，美国 CPSC （消费品安全委员会）成立。同一年 ，CR 第一次测试儿童安全座椅，把 17 款中的 12 款评为「不可接受」，随后致力于推动更严格的安全标准出台。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-15.png&quot; alt=&quot;15&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;上世纪 70 年代，CR 研究了微波产品的辐射泄漏问题，来源：consumerreports.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;1974 年，CR 发布了一系列关于美国水污染的文章，并给出详细的清理建议。为此，CR 获得了当年的 National Magazine Awards（国家杂志奖），在这之后，又获得三次该奖项。&lt;/p&gt;

&lt;p&gt;80 年代， CR 在新内容上进行了多方面的尝试，比如一系列旅游和健康方面的刊物。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-16.png&quot; alt=&quot;16&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;Penny Power 封面，来源：Consumer Reports - Kevin P. Manion&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;1980 年，CR 出版儿童杂志 Penny Power（后来改为 Zillions ）。1983 年，CR 发表了一篇 28 页的电脑选购建议，评测了包括苹果在内的 17 款个人电脑。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-17.png&quot; alt=&quot;17&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;上世纪 80 年代的，CR 抨击保健品行业，来源：consumerreports.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;在这篇文章里，CR 作出预测：到 2000 年，电脑会像电视一样普及。&lt;/p&gt;

&lt;p&gt;1986 年，CR 董事会决定在 Connecticut（康涅狄格州）的 East Haddam（东哈德姆）买一条跑道，并将其改造成当时最先进的汽车测试场。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-18.png&quot; alt=&quot;18&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;CR 位于东哈德姆的汽车测试跑道，来源：wikipedia.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;这一年，也是 CR/CU 的 50 岁生日。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-19.png&quot; alt=&quot;19&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;CR 位于东哈德姆的汽车测试跑道，来源：wikipedia.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;1988 年，在这个汽车测试场地，CR 测试发现 Suzuki（铃木）的 Samurai（武士） 容易翻车，将它评为「不可接受」。&lt;/p&gt;

&lt;p&gt;报告一出，该车销量急速下降，几年后退出美国市场，并于 1995 年停售。铃木公司很不高兴，在 1996 年将 CR 告上法庭，这场官司一打就是 8 年，最终以「庭外和解」结束。&lt;/p&gt;

&lt;p&gt;到 2010 年为止，CR 和厂商打了 16 次产品诽谤的官司，但没有一次输过或赔款。面对 CR 对自己不利的评测结果，大部分公司选择接受并改进。&lt;/p&gt;

&lt;p&gt;如 2010 年的苹果 iPhone 4 的天线问题（通过派发保护套解决），雷克萨斯的 GX460 SUV 的安全问题（通过召回解决），以及前不久苹果  MacBook Pro 的电池问题（通过软件更新解决）。&lt;/p&gt;

&lt;p&gt;90 年代以后，CR 顺应潮流以多种形式发布信息，包括光盘、电视节目、网站等等，还成立了图书出版部门。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-20.png&quot; alt=&quot;20&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;上世纪 90 年代的 CR，来源：consumerreports.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;1991 年，CR 将总部从弗农山迁至附近的扬克斯。1992 年，CR 的订阅会员达到 200 万。随后几年，CR 向医疗保健行业发起挑战。&lt;/p&gt;

&lt;p&gt;1994 年，CR 促使加州的医疗保健公司从非营利性转为营利性，并将收回来的资金用于公共利益，这一转换计划后来扩展到其他几十个州。1995年，CR 起诉加州的一家医疗保健公司，批评它的营销方式，并阻止其在加州销售。&lt;/p&gt;

&lt;p&gt;同一年，订阅量到达 470 万，进入付费订阅杂志前十名。1996 年底，出版业估计 CR 的读者（包括图书馆和传阅的读者）超过 1800 万，是当时美国最流行的杂志之一。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-21.png&quot; alt=&quot;21&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;为保护消费者利益，CR 会出面反对一些公司的合并，来源：consumerreports.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;CR 不仅爱打官司， 还好管「闲事」。为保护消费者利益，2011 年，CR 出面反对通讯公司 AT&amp;amp;T  收购 T-Mobile ，2015 年，又反对 Comcast（康卡斯特） 收购 Time Warner（时代华纳）。&lt;/p&gt;

&lt;p&gt;但是，步入新世纪以后，CR 遇到新的问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;读者群体老龄化：2010 年时，网络会员平均年龄 56 岁，杂志会员的平均年龄 65 岁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了吸引年轻人，CR 进行了多方面的尝试：2006 年收购针对年轻女性的购物杂志「ShopSmart」，2008年收购读者较年轻的消费资讯博客 「Consumerist」。&lt;/p&gt;

&lt;p&gt;去年是 CR 八十年周年，网站大改版，以绿色为基调，设计更年轻化。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-22.png&quot; alt=&quot;22&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;最近几年的 CR，来源：consumerreports.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;除了有来自外界的挑战，CR 还要应对内部的失误，以下是部分负面消息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;90 年代，CR 发现其财务总监在采购中收取回扣，随后停止了他的工作，并将他告上法庭。&lt;/li&gt;
  &lt;li&gt;2002 年，CR 因质量问题召回汽车仪表板上的用的储物箱，它们之前被作为赠品送给订阅者。&lt;/li&gt;
  &lt;li&gt;2007 年，CR 犯了创立以来最大的错误。在当年的一份评测报告中，CR表示大多数儿童安全座椅在侧面撞击中都不安全。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2007 年的文章引发了恐慌和怀疑，几天后杂志撤回了这一报告，向读者道歉，并用四页的篇幅解释了错误的发生。&lt;/p&gt;

&lt;p&gt;这一事件对消费者报告的声誉产生了影响，但其回应方式某种程度上增强了公众对它的信赖。2008 年，订阅量不降反升，达到 800 万的巅峰。&lt;/p&gt;

&lt;p&gt;新世纪以来，CR 采取了一些有争议的举措：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;网站评测旁附有电商链接，部分产品有返利。&lt;/li&gt;
  &lt;li&gt;与亚马逊合作，允许其部分产品页面显示 CR 的选购指南。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基于多年累积的信誉，大多认为这些举措对其独立性影响不大。&lt;/p&gt;

&lt;p&gt;话说回来， 当年的消费者研究（Consumers Research）上哪去了？多年以来，消费者研究一边测试商品，一边打压 CR 。随着两个 CR 的差距越来越大， 80 年代，消费者研究被卖给私人，最终在 1983 年，正式关闭实验室。自此，消费者研究只关注消费领域的政策和资讯，不再测试产品。&lt;/p&gt;

&lt;p&gt;正如斯图尔特 蔡斯为 CR 二十五周年（1961 年）写的短文中所说：&lt;/p&gt;

&lt;p&gt;某种意义上，（独立的）消费者测试是一种必然的、对受大众媒体裹挟而困惑的消费者的回应。&lt;/p&gt;

&lt;p&gt;80 余年，无广告，拒绝送测，不受企业资助，仅靠捐赠和订阅生存，消费者报告战胜了老东家的诽谤，同行的排斥，企业的敌视，熬过了二战的低迷，每年评测数千种产品，在商品市场正视听、拨云雾，帮助消费决策，推动消费立法，领导消费者运动，最终成为消费者中神祇一般的存在。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-22.png&quot; alt=&quot;23&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;CR 不同年代的产品测试场景，来源：Consumer Reports&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;2011 年，曾有报道称 CR 有意进入中国，但至今没有动静。最近几年，国内效仿 CR 的机构越来越多，也不断有人打出「中国的消费者报告」的旗号。&lt;/p&gt;

&lt;p&gt;一切都好像第二套广播体操开头说的那样：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;时代在召唤&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;让我们拭目以待。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;小贴士：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在评测完毕之后，CR 一般将产品拍卖给员工。&lt;/li&gt;
  &lt;li&gt;CR 不予许企业在宣传中引用其评测结果，不惜为此诉诸法律。&lt;/li&gt;
  &lt;li&gt;在很长一段时间里，CR 刻意与企业和政府保持距离，以免影响判断的独立性。2007年的失误出现后，才开始更多地咨询外界意见。&lt;/li&gt;
  &lt;li&gt;CR 目前有 50 个实验室，100 多个测试专家，超过 25 个调查统计研究人员，超过 150个匿名购物者。&lt;/li&gt;
  &lt;li&gt;CR 大部分测试由自己的实验室完成，少数委托给三方实验室，2007 年的比例是十分之一。&lt;/li&gt;
  &lt;li&gt;CR 曾拒绝一家汽车经销商的大量订阅，以免影响杂志的独立性和客观性。&lt;/li&gt;
  &lt;li&gt;CR和「CPSC’（美国消费品安全委员会）共享数据，帮助缺陷产品召回。&lt;/li&gt;
  &lt;li&gt;虽然有很多公司抱怨 CR，但都是针对其评测和结论，很少有人质疑其动机。&lt;/li&gt;
  &lt;li&gt;最近几年，CR 杂志和网络订阅量大致在 700 - 800 万。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;主要参考资料：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.fundinguniverse.com/company-histories/consumers-union-history/&quot;&gt;Consumers Union History - fundinguniverse&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.consumerreports.org/cro/about-us/whats-behind-the-ratings/index.htm&quot;&gt;Behind Our Ratings - Consumer Reports&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.consumerreports.org/consumer-protection/cover-worthy-80-years-of-consumer-reports-magazine/&quot;&gt;Cover Worthy: 80 Years of Consumer Reports Magazine - Consumer Reports&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.consumerreports.org/cro/about-us/history/vintage-photos/index.htm&quot;&gt;Vintage Photo Gallery - Consumer Reports&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://books.google.co.jp/books?id=MxOjAgAAQBAJ&amp;amp;hl=zh-CN&amp;amp;source=gbs_navlinks_s&quot;&gt;Jim Guest - Timothy LaPalme&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://play.google.com/store/books/details?id=uUUMCgAAQBAJ&amp;amp;rdid=book-uUUMCgAAQBAJ&amp;amp;rdot=1&amp;amp;source=gbs_vpt_read&amp;amp;pcampaignid=books_booksearch_viewport&quot;&gt;Watchdogs and Whistleblowers: A Reference Guide to Consumer Activism - Robert N. Mayer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.theatlantic.com/business/archive/2016/04/consumer-reports-in-the-age-of-the-amazon-review/477108/&quot;&gt;Consumer Reports in the Age of the Amazon Review -  The Atlantic&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.nytimes.com/2007/12/08/business/media/08consumer.html&quot;&gt;Success Without Ads - The New York Times&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.wsj.com/articles/SB10001424052748703866704575224093017379202&quot;&gt;Meet the Sticklers -  WSJ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://books.google.co.jp/books/about/Consumer_Reports.html?id=lCAiVjC6Sp8C&amp;amp;redir_esc=y&quot;&gt;Consumer Reports - Kevin P. Manion&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www2.scc.rutgers.edu/ead/manuscripts/consumers_introf.html&quot;&gt;An Inventory to the Records of Consumers’ Research, Inc. - Gregory L. Williams&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt; 
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Tue, 21 Feb 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/02/21/consumer-reports-history.markup/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/02/21/consumer-reports-history.markup/</guid>
        
        <category>笔记</category>
        
        
      </item>
    
  </channel>
</rss>
