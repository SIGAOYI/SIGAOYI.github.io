<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LawooTrip</title>
    <description>龟龟的个人博客-乐物旅行</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 08 Aug 2017 07:01:48 +0000</pubDate>
    <lastBuildDate>Tue, 08 Aug 2017 07:01:48 +0000</lastBuildDate>
    <generator>Jekyll v3.5.1</generator>
    
      <item>
        <title>Web缓存的一些细碎02</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Vue.js 放弃中…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。&lt;/p&gt;

&lt;p&gt;本次从三个方面对学习进行小结。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#0&quot;&gt;一、H5缓存机制介绍&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#1&quot;&gt;二、H5缓存机制原理分析&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#2&quot;&gt;三、移动端Web加载性能（缓存）优化&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我是看不见的分割线&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p id=&quot;0&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一web缓存的作用&quot;&gt;一、web缓存的作用&lt;/h2&gt;

&lt;p&gt;H5，即 HTML5，是新一代的 HTML 标准，加入很多新的特性。离线存储（也可称为缓存机制）是其中一个非常重要的特性。H5 引入的离线存储，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。&lt;/p&gt;

&lt;p&gt;H5 应用程序缓存为应用带来三个优势：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;离线浏览，用户可以在无网络时使用产品&lt;/li&gt;
  &lt;li&gt;速度，已缓存的资源加载的更快&lt;/li&gt;
  &lt;li&gt;负载优化，浏览器只从服务器下载更新过或更改过的资源&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;H5目前的6种缓存机制在&lt;a href=&quot;http://www.lawootrip.com/2017/07/17/web-localstorage-Volume01/&quot;&gt;前一篇文章&lt;/a&gt;有提及。&lt;/p&gt;

&lt;p&gt;下面将首先分析各种缓存机制的原理、用法及特点；然后针对 Anroid 移动端 Web 性能加载优化的需求，看如果利用适当缓存机制来提高 Web 的加载性能。&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;二h5-缓存机制原理&quot;&gt;二、H5 缓存机制原理&lt;/h2&gt;

&lt;h3 id=&quot;21-浏览器缓存机制详解&quot;&gt;2.1 浏览器缓存机制详解&lt;/h3&gt;

&lt;p&gt;浏览器缓存机制是指通过 HTTP 协议头里的 Cache-Control（或 Expires）和 Last-Modified（或 Etag）等字段来控制文件缓存的机制。这应该是 WEB 中最早的缓存机制了，是在 HTTP 协议中实现的，有点不同于 Dom Storage、AppCache 等缓存机制，但本质上是一样的。可以理解为，一个是协议层实现的，一个是应用层实现的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cache-Control&lt;/strong&gt; 用于控制文件在本地缓存有效时长。最常见的，比如服务器回包：Cache-Control:max-age=600 表示文件在本地应该缓存，且有效时长是600秒（从发出请求算起）。在接下来600秒内，如果有请求这个资源，浏览器不会发出 HTTP 请求，而是直接使用本地缓存的文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Last-Modified&lt;/strong&gt; 是标识文件在服务器上的最新更新时间。下次请求时，如果文件缓存过期，浏览器通过 If-Modified-Since 字段带上这个时间，发送给服务器，由服务器比较时间戳来判断文件是否有修改。如果没有修改，服务器返回304告诉浏览器继续使用缓存；如果有修改，则返回200，同时返回最新的文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cache-Control&lt;/strong&gt; 通常与 Last-Modified 一起使用。一个用于控制缓存有效时间，一个在缓存失效后，向服务查询是否有更新。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cache-Control&lt;/strong&gt; 还有一个同功能的字段：Expires。Expires 的值一个绝对的时间点，如：Expires: Thu, 10 Nov 2015 08:45:11 GMT，表示在这个时间点之前，缓存都是有效的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Expires&lt;/strong&gt; 是 HTTP1.0 标准中的字段，Cache-Control 是 HTTP1.1 标准中新加的字段，功能一样，都是控制缓存的有效时间。当这两个字段同时出现时，Cache-Control 是高优化级的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Etag&lt;/strong&gt; 也是和 Last-Modified 一样，对文件进行标识的字段。不同的是，Etag 的取值是一个对文件进行标识的特征字串。在向服务器查询文件是否有更新时，浏览器通过 If-None-Match 字段把特征字串发送给服务器，由服务器和文件最新特征字串进行匹配，来判断文件是否有更新。没有更新回包304，有更新回包200。Etag 和 Last-Modified 可根据需求使用一个或两个同时使用。两个同时使用时，只要满足基中一个条件，就认为文件没有更新。&lt;/p&gt;

&lt;p&gt;另外有两种特殊的情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;手动刷新页面（F5)，浏览器会直接认为缓存已经过期（可能缓存还没有过期），在请求中加上字段：&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache-Control:max-age=0&lt;/code&gt;，发包向服务器查询是否有文件是否有更新。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;强制刷新页面（Ctrl+F5)，浏览器会直接忽略本地的缓存（有缓存也会认为本地没有缓存），在请求中加上字段：&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache-Control:no-cache&lt;/code&gt;（或 &lt;code class=&quot;highlighter-rouge&quot;&gt;Pragma:no-cache&lt;/code&gt;），发包向服务重新拉取文件。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面是通过 Google Chrome 浏览器（用其他浏览器+抓包工具也可以）自带的开发者工具，对一个资源文件不同情况请求与回包的截图。&lt;/p&gt;

&lt;p&gt;首次请求：200&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/241/923/2419230919-56fdeab9a8ba6_articlex&quot; alt=&quot;200&quot; /&gt;&lt;/p&gt;

&lt;p&gt;缓存有效期内请求：200(from cache)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/122/114/1221141305-56fdeaba76fb8_articlex&quot; alt=&quot;200 from cache&quot; /&gt;&lt;/p&gt;

&lt;p&gt;缓存过期后请求：304（Not Modified)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/135/686/135686075-56fdeabb2c2bc_articlex&quot; alt=&quot;304 from cache&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一般浏览器会将缓存记录及缓存文件存在本地 Cache 文件夹中。Android 下 App 如果使用 Webview，缓存的文件记录及文件内容会存在当前 app 的 data 目录中。&lt;/p&gt;

&lt;p&gt;分析：Cache-Control 和 Last-Modified 一般用在 Web 的静态资源文件上，如 JS、CSS 和一些图像文件。通过设置资源文件缓存属性，对提高资源文件加载速度，节省流量很有意义，特别是移动网络环境。但问题是：缓存有效时长该如何设置？如果设置太短，就起不到缓存的使用；如果设置的太长，在资源文件有更新时，浏览器如果有缓存，则不能及时取到最新的文件。&lt;/p&gt;

&lt;p&gt;Last-Modified 需要向服务器发起查询请求，才能知道资源文件有没有更新。虽然服务器可能返回304告诉没有更新，但也还有一个请求的过程。对于移动网络，这个请求可能是比较耗时的。有一种说法叫“消灭304”，指的就是优化掉304的请求。&lt;/p&gt;

&lt;p&gt;抓包发现，带 if-Modified-Since 字段的请求，如果服务器回包304，回包带有 Cache-Control:max-age 或 Expires 字段，文件的缓存有效时间会更新，就是文件的缓存会重新有效。304回包后如果再请求，则又直接使用缓存文件了，不再向服务器查询文件是否更新了，除非新的缓存时间再次过期。&lt;/p&gt;

&lt;p&gt;另外，Cache-Control 与 Last-Modified 是浏览器内核的机制，一般都是标准的实现，不能更改或设置。以 QQ 浏览器的 X5为例，Cache-Control 与 Last-Modified 缓存不能禁用。缓存容量是12MB，不分HOST，过期的缓存会最先被清除。如果都没过期，应该优先清最早的缓存或最快到期的或文件大小最大的；过期缓存也有可能还是有效的，清除缓存会导致资源文件的重新拉取。&lt;/p&gt;

&lt;p&gt;还有，浏览器，如 X5，在使用缓存文件时，是没有对缓存文件内容进行校验的，这样缓存文件内容被修改的可能。&lt;/p&gt;

&lt;p&gt;分析发现，浏览器的缓存机制还不是非常完美的缓存机制。完美的缓存机制应该是这样的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;缓存文件没更新，尽可能使用缓存，不用和服务器交互；&lt;/li&gt;
  &lt;li&gt;缓存文件有更新时，第一时间能使用到新的文件；&lt;/li&gt;
  &lt;li&gt;缓存的文件要保持完整性，不使用被修改过的缓存文件；&lt;/li&gt;
  &lt;li&gt;缓存的容量大小要能设置或控制，缓存文件不能因为存储空间限制或过期被清除。以X5为例，第1、2条不能同时满足，第3、4条都不能满足。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在实际应用中，为了解决 Cache-Control 缓存时长不好设置的问题，以及为了”消灭304“，Web前端采用的方式是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在要缓存的资源文件名中加上版本号或文件 MD5值字串，如 common.d5d02a02.js，common.v1.js，同时设置 Cache-Control:max-age=31536000，也就是一年。在一年时间内，资源文件如果本地有缓存，就会使用缓存；也就不会有304的回包。&lt;/li&gt;
  &lt;li&gt;如果资源文件有修改，则更新文件内容，同时修改资源文件名，如 common.v2.js，html页面也会引用新的资源文件名。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过这种方式，实现了：缓存文件没有更新，则使用缓存；缓存文件有更新，则第一时间使用最新文件的目的。即上面说的第1、2条。第3、4条由于浏览器内部机制，目前还无法满足。&lt;/p&gt;

&lt;h3 id=&quot;22-dom-storage-存储机制&quot;&gt;2.2 Dom Storage 存储机制&lt;/h3&gt;

&lt;p&gt;DOM 存储是一套在 Web Applications 1.0 规范中首次引入的与存储相关的特性的总称，现在已经分离出来，单独发展成为独立的 W3C Web 存储规范。 DOM 存储被设计为用来提供一个更大存储量、更安全、更便捷的存储方法，从而可以代替掉将一些不需要让服务器知道的信息存储到 cookies 里的这种传统方法。&lt;/p&gt;

&lt;p&gt;上面一段是对 Dom Storage 存储机制的官方表述。看起来，Dom Storage 机制类似 Cookies，但有一些优势。&lt;/p&gt;

&lt;p&gt;Dom Storage 是通过存储字符串的 Key/Value 对来提供的，并提供 5MB （不同浏览器可能不同，分 HOST)的存储空间（Cookies 才 4KB)。另外 Dom Storage 存储的数据在本地，不像 Cookies，每次请求一次页面，Cookies 都会发送给服务器。&lt;/p&gt;

&lt;p&gt;DOM Storage 分为 sessionStorage 和 localStorage。localStorage 对象和 sessionStorage 对象使用方法基本相同，它们的区别在于作用的范围不同。sessionStorage 用来存储与页面相关的数据，它在页面关闭后无法使用。而 localStorage 则持久存在，在页面关闭后也可以使用。&lt;/p&gt;

&lt;p&gt;Dom Storage 提供了以下的存储接口：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface Storage { 
readonly attribute unsigned long length; 
[IndexGetter] DOMString key(in unsigned long index); 
[NameGetter] DOMString getItem(in DOMString key); 
[NameSetter] void setItem(in DOMString key, in DOMString data); 
[NameDeleter] void removeItem(in DOMString key); 
void clear();
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;sessionStorage 是个全局对象，它维护着在页面会话(page session)期间有效的存储空间。只要浏览器开着，页面会话周期就会一直持续。当页面重新载入(reload)或者被恢复(restores)时，页面会话也是一直存在的。每在新标签或者新窗口中打开一个新页面，都会初始化一个新的会话。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
// 当页面刷新时，从sessionStorage恢复之前输入的内容
window.onload = function(){
  if (window.sessionStorage) {
      var name = window.sessionStorage.getItem(&quot;name&quot;);
      if (name != &quot;&quot; || name != null){
          document.getElementById(&quot;name&quot;).value = name;
      }
  }
};

// 将数据保存到sessionStorage对象中
function saveToStorage() {
  if (window.sessionStorage) {
     var name = document.getElementById(&quot;name&quot;).value;
     window.sessionStorage.setItem(&quot;name&quot;, name);
     window.location.href=&quot;session_storage.html&quot;;
 }
}
 &amp;lt;/script&amp;gt;

&amp;lt;form action=&quot;./session_storage.html&quot;&amp;gt;
  &amp;lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot;/&amp;gt;
  &amp;lt;input type=&quot;button&quot; value=&quot;Save&quot; onclick=&quot;saveToStorage()&quot;/&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当浏览器被意外刷新的时候，一些临时数据应当被保存和恢复。sessionStorage 对象在处理这种情况的时候是最有用的。比如恢复我们在表单中已经填写的数据。&lt;/p&gt;

&lt;p&gt;把上面的代码复制到 session_storage.html（也可以从附件中直接下载）页面中，用 Google Chrome 浏览器的不同 PAGE 或 WINDOW 打开，在输入框中分别输入不同的文字，再点击“Save”，然后分别刷新。每个 PAGE 或 WINDOW 显示都是当前PAGE输入的内容，互不影响。关闭 PAGE，再重新打开，上一次输入保存的内容已经没有了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/220/256/2202563205-56fe424093728_articlex&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/935/566/93556648-56fe423f1827f_articlex&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Local Storage 的接口、用法与 Session Storage 一样，唯一不同的是：Local Storage 保存的数据是持久性的。当前 PAGE 关闭（Page Session 结束后），保存的数据依然存在。重新打开PAGE，上次保存的数据可以获取到。另外，Local Storage 是全局性的，同时打开两个 PAGE 会共享一份存数据，在一个PAGE中修改数据，另一个 PAGE 中是可以感知到的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;
  //通过localStorage直接引用key, 另一种写法，等价于：
  //localStorage.getItem(&quot;pageLoadCount&quot;);
  //localStorage.setItem(&quot;pageLoadCount&quot;, value);
  if (!localStorage.pageLoadCount)
localStorage.pageLoadCount = 0;
     localStorage.pageLoadCount = parseInt(localStorage.pageLoadCount) + 1;
     document.getElementById('count').textContent = localStorage.pageLoadCount;
&amp;lt;/script&amp;gt;

&amp;lt;p&amp;gt;
    You have viewed this page
    &amp;lt;span id=&quot;count&quot;&amp;gt;an untold number of&amp;lt;/span&amp;gt;
    time(s).
&amp;lt;/p&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将上面代码复制到 local_storage.html 的页面中，用浏览器打开，pageLoadCount 的值是1；关闭 PAGE 重新打开，pageLoadCount 的值是2。这是因为第一次的值已经保存了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/202/620/2026209678-56fe4241451ef_articlex&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/836/137/836137524-56fe424228af7_articlex&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用两个 PAGE 同时打开 local_storage.html，并分别交替刷新，发现两个 PAGE 是共享一个 pageLoadCount 的。&lt;/p&gt;

&lt;p&gt;分析：Dom Storage 给 Web 提供了一种更录活的数据存储方式，存储空间更大（相对 Cookies)，用法也比较简单，方便存储服务器或本地的一些临时数据。&lt;/p&gt;

&lt;p&gt;从 DomStorage 提供的接口来看，DomStorage 适合存储比较简单的数据，如果要存储结构化的数据，可能要借助 JASON了，将要存储的对象转为 JASON 字串。不太适合存储比较复杂或存储空间要求比较大的数据，也不适合存储静态的文件等。&lt;/p&gt;

&lt;h4 id=&quot;23-web-sql-database存储机制&quot;&gt;2.3 Web SQL Database存储机制&lt;/h4&gt;

&lt;p&gt;H5 也提供基于 SQL 的数据库存储机制，用于存储适合数据库的结构化数据。根据官方的标准文档，Web SQL Database 存储机制不再推荐使用，将来也不再维护，而是推荐使用 AppCache 和 IndexedDB。&lt;/p&gt;

&lt;p&gt;现在主流的浏览器（点击查看浏览器支持情况）都还是支持 Web SQL Database 存储机制的。Web SQL Database 存储机制提供了一组 API 供 Web App 创建、存储、查询数据库。&lt;/p&gt;

&lt;p&gt;下面通过简单的例子，演示下 Web SQL Database 的使用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;
    if(window.openDatabase){
      //打开数据库，如果没有则创建
      var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024);

       //通过事务，创建一个表，并添加两条记录
      db.transaction(function (tx) {
           tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)');
           tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, &quot;foobar&quot;)');
           tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, &quot;logmsg&quot;)');
       });

      //查询表中所有记录，并展示出来
     db.transaction(function (tx) {
         tx.executeSql('SELECT * FROM LOGS', [], function (tx, results) {
             var len = results.rows.length, i;
             msg = &quot;&amp;lt;p&amp;gt;Found rows: &quot; + len + &quot;&amp;lt;/p&amp;gt;&quot;;
             for(i=0; i&amp;lt;len; i++){
                 msg += &quot;&amp;lt;p&amp;gt;&quot; + results.rows.item(i).log + &quot;&amp;lt;/p&amp;gt;&quot;;
             }
             document.querySelector('#status').innerHTML =  msg;
             }, null);
      });
}

&amp;lt;/script&amp;gt;

&amp;lt;div id=&quot;status&quot; name=&quot;status&quot;&amp;gt;Status Message&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将上面代码复制到 sql_database.html 中，用浏览器打开，可看到下面的内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/204/236/2042368915-56fe438fbfd26_articlex&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;官方建议浏览器在实现时，对每个 HOST 的数据库存储空间作一定限制，建议默认是 5MB（分 HOST）的配额；达到上限后，可以申请更多存储空间。另外，现在主流浏览器 SQL Database 的实现都是基于 SQLite。&lt;/p&gt;

&lt;p&gt;分析：SQL Database 的主要优势在于能够存储结构复杂的数据，能充分利用数据库的优势，可方便对数据进行增加、删除、修改、查询。由于 SQL 语法的复杂性，使用起来麻烦一些。SQL Database 也不太适合做静态文件的缓存。&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;2&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;三移动端-web-加载性能缓存优化&quot;&gt;三、移动端 Web 加载性能（缓存）优化&lt;/h2&gt;

&lt;p&gt;分析完 H5提供的各种缓存机制，回到移动端（针对 Android，可能也适用于 iOS）的场景。现在 Android App大多嵌入了 Webview 的组件（系统 Webview 或 QQ 游览器的 X5组件），通过内嵌Webview 来加载一些H5的运营活动页面或资讯页。这样可充分发挥Web前端的优势：快速开发、发布，灵活上下线。但 Webview 也有一些不可忽视的问题，比较突出的就是加载相对较慢，会相对消耗较多流量。&lt;/p&gt;

&lt;p&gt;通过对一些 H5页面进行调试及抓包发现，每次加载一个 H5页面，都会有较多的请求。除了 HTML 主 URL 自身的请求外，HTML外部引用的 JS、CSS、字体文件、图片都是一个独立的 HTTP 请求，每一个请求都串行的（可能有连接复用）。这么多请求串起来，再加上浏览器解析、渲染的时间，Web 整体的加载时间变得较长；请求文件越多，消耗的流量也会越多。我们可综合使用上面说到几种缓存机制，来帮助我们优化 Web 的加载性能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/129/554/1295547036-56fe42e54e817_articlex&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;结论：综合各种缓存机制比较，对于静态文件，如 JS、CSS、字体、图片等，适合通过浏览器缓存机制来进行缓存，通过缓存文件可大幅提升 Web 的加载速度，且节省流量。但也有一些不足：缓存文件需要首次加载后才会产生；浏览器缓存的存储空间有限，缓存有被清除的可能；缓存的文件没有校验。要解决这些不足，可以参考手 Q 的离线包，它有效的解决了这些不足。&lt;/p&gt;

&lt;p&gt;对于 Web 在本地或服务器获取的数据，可以通过 Dom Storage 和 IndexedDB 进行缓存。也在一定程度上减少和 Server 的交互，提高加载速度，同时节省流量。&lt;/p&gt;

&lt;p&gt;当然 Web 的性能优化，还包括选择合适的图片大小，避免 JS 和 CSS 造成的阻塞等。这就需要 Web 前端的同事根据一些规范和一些调试工具进行优化了。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt; 
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Tue, 18 Jul 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/07/18/web-localstorage-Volume02/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/18/web-localstorage-Volume02/</guid>
        
        <category>笔记</category>
        
        <category>Web前端</category>
        
        
      </item>
    
      <item>
        <title>Web缓存的一些细碎01</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Vue.js 放弃中…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。&lt;/p&gt;

&lt;p&gt;本次从三个方面对学习进行小结。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#0&quot;&gt;一、web缓存的作用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#1&quot;&gt;二、web缓存的类型&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#2&quot;&gt;三、浅析web缓存在浏览器端工作原理&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#3&quot;&gt;四、小结&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我是看不见的分割线&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p id=&quot;0&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一web缓存的作用&quot;&gt;一、web缓存的作用&lt;/h2&gt;

&lt;p&gt;主要三个方面：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;减少网络带宽消耗（当Web缓存副本被使用时，只会产生极小的网络流量，可以有效的降低运营成本。）&lt;/li&gt;
  &lt;li&gt;降低服务器压力（给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，间接降低服务器的压力。同时，搜索引擎的爬虫机器人也能根据过期机制降低爬取的频率，也能有效降低服务器的压力。）&lt;/li&gt;
  &lt;li&gt;减少网络延迟，加开页面打开速度。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;二web缓存的类型&quot;&gt;二、web缓存的类型&lt;/h2&gt;

&lt;p&gt;在Web应用领域，Web缓存大致可以分为以下几种类型：&lt;/p&gt;

&lt;h3 id=&quot;21-数据库数据缓存&quot;&gt;2.1 数据库数据缓存&lt;/h3&gt;

&lt;p&gt;web应用，特别是SNS类型的应用，往往关系比较复杂，数据库表繁多，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，会将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。比如常用的缓存方案有&lt;a href=&quot;http://www.runoob.com/Memcached/Memcached-tutorial.html&quot;&gt;memcached&lt;/a&gt; 等。&lt;/p&gt;

&lt;h3 id=&quot;22-服务器端缓存&quot;&gt;2.2 服务器端缓存&lt;/h3&gt;

&lt;p&gt;服务器端缓存包含代理服务器缓存和CDN缓存:&lt;/p&gt;

&lt;h4 id=&quot;221-代理服务器缓存&quot;&gt;2.2.1 代理服务器缓存&lt;/h4&gt;

&lt;p&gt;代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。可以把它理解为一个共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少相应时间和带宽使用方面很有效，同一个副本会被重用多次。常见代理服务器缓存解决方案有&lt;a href=&quot;http://www.phpfans.net/manu/Squid/&quot;&gt;Squid&lt;/a&gt; 等，这里不再详述。&lt;/p&gt;

&lt;h4 id=&quot;222-cdn缓存&quot;&gt;2.2.2 CDN缓存&lt;/h4&gt;

&lt;p&gt;CDN（Content delivery networks）缓存，也叫网关缓存、反向代理缓存。CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。虽然这种架构负载均衡源服务器之间的缓存没法共享，但却拥有更好的处扩展性。从浏览器角度来看，整个CDN就是一个源服务器。&lt;/p&gt;

&lt;h2 id=&quot;23-浏览器端缓存&quot;&gt;2.3 浏览器端缓存&lt;/h2&gt;

&lt;p&gt;浏览器缓存（Browser Caching）是浏览器端保存数据用于快速读取或避免重复资源请求的优化机制，有效的缓存使用可以避免重复的网络请求和浏览器快速地读取本地数据，整体上加速网页展示给用户。&lt;/p&gt;

&lt;h2 id=&quot;24-web应用层缓存&quot;&gt;2.4 Web应用层缓存&lt;/h2&gt;

&lt;p&gt;应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据，页面，图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;下面着重从浏览器端来看缓存工作机制和原理。&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;2&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;三浅析web缓存在浏览器端工作原理&quot;&gt;三、浅析web缓存在浏览器端工作原理&lt;/h2&gt;

&lt;p&gt;根据标准，到目前为止，H5 一共有6种缓存机制，有些是之前已有，有些是 H5 才新加入的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;浏览器缓存机制；&lt;/li&gt;
    &lt;li&gt;Dom Storgage 存储机制；&lt;/li&gt;
    &lt;li&gt;Web SQL Database 存储机制；&lt;/li&gt;
    &lt;li&gt;ApplicationCach（APPCache）机制；&lt;/li&gt;
    &lt;li&gt;Indexed Database (IndexdDB);&lt;/li&gt;
    &lt;li&gt;File System API;&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;31-浏览器缓存机制&quot;&gt;3.1 浏览器缓存机制&lt;/h3&gt;

&lt;h4 id=&quot;311-非http协议定义的缓存机制&quot;&gt;3.1.1 非HTTP协议定义的缓存机制&lt;/h4&gt;

&lt;p&gt;浏览器缓存机制，其实主要就是HTTP协议定义的缓存机制（如： Expires； Cache-control等）。但是也有非HTTP协议定义的缓存机制，如使用HTML Meta 标签，Web开发者可以在HTML页面的&amp;lt;head&amp;gt;节点中加入&lt;meta /&gt;标签，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;META HTTP-EQUIV=&quot;Pragma&quot; CONTENT=&quot;no-cache&quot;&amp;gt;

&amp;lt;META HTTP-EQUIV=&quot;Expires&quot; CONTENT=&quot;0&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为代理不解析HTML内容本身。下面主要介绍HTTP协议定义的缓存机制。&lt;/p&gt;

&lt;h4 id=&quot;312-http协议定义的缓存机制&quot;&gt;3.1.2 HTTP协议定义的缓存机制&lt;/h4&gt;

&lt;p&gt;通过 HTTP 协议头里的 Cache-Control（或 Expires）和 Last-Modified（或 Etag）等字段来控制文件缓存的机制。这应该是 WEB 中最早的缓存机制了，是在 HTTP 协议中实现的，有点不同于 Dom Storage、AppCache 等缓存机制，但本质上是一样的。可以理解为，一个是协议层实现的，一个是应用层实现的。&lt;/p&gt;

&lt;h4 id=&quot;313-http10时代缓存字段详解&quot;&gt;3.1.3 HTTP1.0时代缓存字段详解&lt;/h4&gt;

&lt;p&gt;2个字段：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Pragma：设置页面是否缓存，为Pragma则缓存，no-cache则不缓存。&lt;/li&gt;
  &lt;li&gt;Expires：有了Pragma来禁用缓存，自然也需要有个东西来启用缓存和定义缓存时间，对HTTP1.0而言，Expires就是做这件事的首部字段。Expires的值对应一个GMT（格林尼治时间），比如Mon, 22 Jul 2002 11:12:01 GMT来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。&lt;br /&gt;
如果Pragma头部和Expires头部同时存在，则起作用的会是Pragma，需要注意的是，响应报文中Expires所定义的缓存时间是相对服务器上的时间而言的，其定义的是资源“失效时刻”，如果客户端上的时间跟服务器上的时间不一致（特别是用户修改了自己电脑的系统时间），那缓存时间可能就没啥意义了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;314-http11-时代缓存字段详解&quot;&gt;3.1.4 HTTP1.1 时代缓存字段详解&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Cache-Control： 针对上述的“Expires时间是相对服务器而言，无法保证和客户端时间统一”的问题，http1.1新增了 Cache-Control 来定义缓存过期时间。&lt;strong&gt;注意：若报文中同时出现了 Expires 和 Cache-Control，则以 Cache-Control 为准。&lt;/strong&gt;
(1) 最常见的，比如服务器回包：Cache-Control:max-age=600 表示文件在本地应该缓存，且有效时长是600秒（从发出请求算起）。在接下来600秒内，如果有请求这个资源，浏览器不会发出 HTTP 请求，而是直接使用本地缓存的文件。
(2) Cache-Control: no-cache；这个很容易让人产生误解，使人误以为是响应不被缓存。实际上她是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。 
(3) Cache-Control: no-store；这个才是响应不被缓存的意思。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Last-Modified/If-Modified-Since：
(1) Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。 
(2) If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Etag/If-None-Match：Etag/If-None-Match也要配合Cache-Control使用。
(1) Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器觉得）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。
(2) If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;既生Last-Modified何生Etag？
你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题： 
(1) Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间。
(2) 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存。
(3) 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。
Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小结&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/web2017-07-17-01.png&quot; alt=&quot;浏览器第一次请求01&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;浏览器第一次请求&lt;/small&gt;
&lt;br /&gt;
&lt;img src=&quot;http://image.lawootrip.com/web-2017-07-17-02.png&quot; alt=&quot;浏览器第一次请求02&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;浏览器第二次请求&lt;/small&gt;&lt;/p&gt;

&lt;h4 id=&quot;32dom-storage-存储机制&quot;&gt;3.2Dom Storage 存储机制&lt;/h4&gt;

&lt;p&gt;DOM Storage 是指 HTML5 的本地存储 API sessionStorage 和 localStorage。在介绍HTML5本地存储之前，先来看一看前面几个存储方式的概念。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/391/641/3916412705-59312d0fceb14_articlex&quot; alt=&quot;Dom Storage&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;HTTP Cookie: Cookie是为了解决HTTP无状态的特性而出现的，也可以叫用户识别机制。常用的用户识别机制包括：
    &lt;ul&gt;
      &lt;li&gt;承载用户信息的HTTP首部&lt;/li&gt;
      &lt;li&gt;客户端IP地址追踪技术，通过用户的IP地址对其进行识别&lt;/li&gt;
      &lt;li&gt;用户登录，用认证机制来识别用户&lt;/li&gt;
      &lt;li&gt;胖URL，一种在URL中嵌入识别信息的技术&lt;/li&gt;
      &lt;li&gt;cookie，一种强大且高效的持久身份识别技术&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于购物网站而言，cookie是非常重要的，为了实现购物车功能，把已选物品加入cookie，可以实现不同页面之间数据的同步，同时在提交订单的时候又会把这些cookie传到后台，大大方便了前后端开发。设置cookie:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function setCookie(name, value, options) {
  var expires = options.expires;
  var path = options.path;
  var domain = options.domain;
  var secure = options.secure;

  // 缓存时间转为日期对象
  if (typeof expires === 'number') {
    expires = new Date(new Date().getTime() + expires * 864e+5); // 缓存时间单位：天
  }
    document.cookie =
    name + '=' + escape(value) +
    (expires ? '; expires=' + expires.toUTCString() : '') +
    (path ? '; path=' + path : '') +
    (domain ? '; domain=' + domain : '') +
    (secure ? '; secure' : '');

  return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;获取cookie:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function getCookie(name) {
  var arr = document.cookie.match(new RegExp('(^| )' + name + '=([^;]*)(;|$)'));
  if (arr !== null) {
    return unescape(arr[2]);
  }

  // return null;
  return '';
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;userData是微软在上世纪90年代的浏览器大战时推出的本地存储方案，借助DHTML的behaviour属性来存储本地数据， 允许每个页面最多存储64K数据，每个站点最多640K数据，userData的缺点显而易见，它不是Web标准的一部分，除非你的程序只需要支持IE， 否则它基本没什么用处。&lt;/li&gt;
  &lt;li&gt;Flash cookie的名字有些误导，它实际上和HTTP cookie并不是一回事，或许它的名字应该叫做”Flash本地存储”，Flash cookie默认允许每个站点存储不超过100K的数据，如果超出了，Flash会自动向用户请求更大的存储空间，借助Flash的 ExternalInterface接口，你可以很轻松地通过Javascript操作Flash的本地存储。Flash的问题很简单，就是因为它是 Flash。&lt;/li&gt;
  &lt;li&gt;Gears是Google在07年发布的一个开源浏览器插件，旨在改进各大浏览器的兼容性，Gears内置了一个基于SQLite的嵌入式 SQL数据库，并提供了统一API对数据库进行访问，在取得用户授权之后，每个站点可以在SQL数据库中存储不限大小的数据，Gears的问题就是 Google自己都已经不用它了。&lt;/li&gt;
  &lt;li&gt;HTML5 的本地存储 API sessionStorage 和 localStorage
Dom Storage 是通过存储字符串的 Key/Value 对来提供的，并提供 5MB （不同浏览器可能不同，分 HOST)的存储空间（Cookies 才 4KB)。另外 Dom Storage 存储的数据在本地，不像 Cookies，每次请求一次页面，Cookies 都会发送给服务器。
DOM Storage 分为 sessionStorage 和 localStorage。localStorage 对象和 sessionStorage 对象使用方法基本相同，它们的区别在于作用的范围不同。sessionStorage 用来存储与页面相关的数据，它在页面关闭后无法使用。而 localStorage 则持久存在，在页面关闭后也可以使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;简单用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var name = sessionStorage.setItem(&quot;name&quot;,&quot;wangjuan&quot;);
alert(sessionStorage.getItem(&quot;name&quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;并不是所有的浏览器都支持这两个对象。在没有原生支持localStorage的浏览器中使用时，MDN给出了兼容代码&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Guide/API/DOM/Storage#localStorage&quot;&gt;戳这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;不同浏览器对于这两种用法的差异的兼容代码可参考:&lt;a href=&quot;https://github.com/mortzdk/localStorage&quot;&gt;戳这里&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;33-web-sql存储机制&quot;&gt;3.3 Web SQL存储机制&lt;/h4&gt;

&lt;p&gt;H5 也提供基于 SQL 的数据库存储机制，用于存储适合数据库的结构化数据。根据官方的标准文档，Web SQL Database 存储机制不再推荐使用，将来也不再维护，而是推荐使用 AppCache 和 IndexedDB。
查看更多：&lt;a href=&quot;http://www.runoob.com/html/html5-web-sql.html&quot;&gt;戳这里&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;34-application-cache-机制&quot;&gt;3.4 Application Cache 机制&lt;/h4&gt;

&lt;p&gt;Application Cache（简称 AppCache)似乎是为支持 Web App 离线使用而开发的缓存机制。它的缓存机制类似于浏览器的缓存（Cache-Control 和 Last-Modified）机制，都是以文件为单位进行缓存，且文件有一定更新机制。但 AppCache 是对浏览器缓存机制的补充，不是替代。
AppCache 的原理有两个关键点：manifest 属性和 manifest 文件。
W3C 官方的一个例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/515/220/515220078-59315a8c9c8a6_articlex&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面 HTML 文档，引用外部一个 JS 文件和一个 GIF 图片文件，在其 HTML 头中通过 manifest 属性引用了一个 appcache 结尾的文件（即manifest文件）。
缓存的结果是：我们在 Google Chrome 浏览器中打开这个 HTML 链接，JS 功能正常，图片也显示正常。禁用网络，关闭浏览器重新打开这个链接，发现 JS 工作正常，图片也显示正常。当然也有可能是浏览缓存起的作用，我们可以在文件的浏览器缓存过期后，禁用网络再试，发现 HTML 页面也是正常的。
manifest 文件就是以 appcache 结尾的文件，是一个普通文件文件，列出了需要缓存的文件。
完整的 manifest 文件，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CACHE MANIFEST
# 2012-02-21 v1.0.0
/theme.css
/logo.gif
/main.js

NETWORK:
login.asp

FALLBACK:
/html/ /offline.html 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;了解更多：&lt;a href=&quot;http://www.cnblogs.com/lovesong/p/5021992.html?utm_medium=referral&quot;&gt;戳我&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;35-indexed-database&quot;&gt;3.5 Indexed Database&lt;/h4&gt;

&lt;p&gt;IndexedDB 也是一种数据库的存储机制，但不同于已经不再支持的 Web SQL Database。IndexedDB 不是传统的关系数据库，indexedDB中没有表的概念，类似于 Dom Storage 的 key-value 的存储方式，但功能更强大，且存储空间更大。它的特点是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;以key-value 的方式存取对象，可以是任何类型值或对象，包括二进制。&lt;/li&gt;
  &lt;li&gt;可以对对象任何属性生成索引，方便查询。&lt;/li&gt;
  &lt;li&gt;较大的存储空间，默认推荐250MB(分 HOST)，比 Dom Storage 的5MB要大的多。&lt;/li&gt;
  &lt;li&gt;通过数据库的事务（tranction）机制进行数据操作，保证数据一致性。&lt;/li&gt;
  &lt;li&gt;异步的 API 调用，避免造成等待而影响体验。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;了解更多：&lt;a href=&quot;http://www.cnblogs.com/dolphinX/p/3415761.html&quot;&gt;戳1&lt;/a&gt;和&lt;a href=&quot;http://www.cnblogs.com/dolphinX/p/3416889.html&quot;&gt;戳2&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;36-file-system-api&quot;&gt;3.6 File System API&lt;/h4&gt;

&lt;p&gt;File System API 是 H5 新加入的存储机制。它为 Web App 提供了一个虚拟的文件系统，就像 Native App 访问本地文件系统一样。由于安全性的考虑，这个虚拟文件系统有一定的限制。Web App 在虚拟的文件系统中，可以进行文件（夹）的创建、读、写、删除、遍历等操作。&lt;/p&gt;

&lt;p&gt;File System API 也是一种可选的缓存机制，和前面的 SQLDatabase、IndexedDB 和 AppCache 等一样。File System API 有自己的一些特定的优势：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以满足大块的二进制数据（ large binary blobs）存储需求。&lt;/li&gt;
  &lt;li&gt;可以通过预加载资源文件来提高性能。&lt;/li&gt;
  &lt;li&gt;可以直接编辑文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p id=&quot;3&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;四小结&quot;&gt;四、小结&lt;/h3&gt;

&lt;p&gt;反正我在放弃中，前端水深请小心。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://jixianqianduan.com/frontend-javascript/2015/12/28/nine-browser-cache-methods.html&quot;&gt;九种浏览器端缓存机制知多少&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/wangpenghui522/p/5498427.html#top&quot;&gt;浏览器缓存原理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.alloyteam.com/2012/03/web-cache-1-web-cache-overview/&quot;&gt;Web缓存机制系列
&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000002701423&quot;&gt;Web 前端实现本地存储&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.lawootrip.com/2017/07/18/web-localstorage-Volume02/&quot;&gt;H5 缓存机制浅析 - 移动端 Web 加载性能优化&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html&quot;&gt;浏览器缓存机制&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://mangguo.org/browser-cache-mechanism-detailed/&quot;&gt;浏览器缓存机制详解&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/skylar/p/browser-http-caching.html&quot;&gt;透过浏览器看HTTP缓存&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/vajoy/p/5341664.html&quot;&gt;浅谈浏览器http的缓存机制&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/zichi/p/4685822.html&quot;&gt;浏览器缓存机制浅析&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt; 
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Mon, 17 Jul 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/07/17/web-localstorage-Volume01/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/17/web-localstorage-Volume01/</guid>
        
        <category>笔记</category>
        
        <category>Web前端</category>
        
        
      </item>
    
      <item>
        <title>关于DNS解析优化的一些细碎</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;DNS优化，从入门到放弃。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;前段时间掉进了网站加载缓慢，数据还会丢包的大坑。&lt;/p&gt;

&lt;p&gt;在产品其他方面加紧优化的基础上，又赶紧研究了一下DNS的工作原理以及通常使用的优化技巧。&lt;/p&gt;

&lt;p&gt;现在从坑里爬出来了。&lt;/p&gt;

&lt;p&gt;喘口气&lt;/p&gt;

&lt;p&gt;本文将从以下六个方面对DNS优化进行了一些细碎的小结。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#0&quot;&gt;一、域名DNS解析原理和过程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#1&quot;&gt;二、浏览器加载网页的基本过程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#2&quot;&gt;三、合理利用DNS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#3&quot;&gt;四、合理使用DNS-prefetch让DNS预读取&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#4&quot;&gt;五、DNS域名解析拆分为多个域名增加并行下载量&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#5&quot;&gt;六、加快域名DNS解析速度方法小结&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;我是看不见的分割线&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p id=&quot;0&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一域名dns解析原理和过程&quot;&gt;一、域名DNS解析原理和过程&lt;/h3&gt;

&lt;h5 id=&quot;dns是怎么来的&quot;&gt;DNS是怎么来的?&lt;/h5&gt;

&lt;p&gt;DNS 是域名系统 (Domain Name System) 的缩写。在Internet上域名与IP地址之间是一对一(或者多对一)的，域名虽然便于人们记忆，但机器之间只能互相认识IP地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS就是进行域名解析的服务器。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-05-15-structure.PNG&quot; alt=&quot;DNS服务结构&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;DNS的树形结构&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，DNS服务器类型主要有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;内部 DNS ：位于内网中，提供内网 DNS 服务，也具备 Internet DNS 缓存与转发能力&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;外部 DNS：位于 Internet 中，提供 Internet 的 DNS 服务（包括 DNS 缓存与转发）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;主 DNS：提供 DNS 服务（包括查询，缓存写入）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;辅 DNS：只提供 DNS 查询服务，与主 DNS 同步数据库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;唯缓存 DNS：自身不具备 DNS 解析能力，但具有 DNS 缓存数据库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;转发 DNS：具备转发特性，能将 DNS 请求转发给其他 DNS 服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;权威 DNS： 自身数据库中存在与 DNS 请求相对应的映射&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;非权威 DNS：不存在相对应的映射，而存在对应缓存查询结果&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-05-15-DNS-process.png&quot; alt=&quot;DNS服务进程&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;DNS解析进程&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;上图的DNS解析过程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;龟龟(192.168.1.1) 在浏览器访问 http://www.lawootrip.com&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;192.168.1.1 检查本地 hosts 文件中是否存在 www.lawootrip.com 对应的 IP&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;若无，192.168.1.1 继续检查本地 DNS 缓存中是否存在 www.lawootrip.com 对应的 IP&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;若无， 192.168.1.1 向本地 DNS 服务器发起 DNS 查询请求&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;路由器接收到 DNS 查询请求后，检查路由器 DNS 缓存&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;若无，路由器以外网地址 202.202.202.202 向本地 DSN 服务器 （ISP DNS）发起 DNS 查询请求&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ISP DNS 接收到 DNS 查询请求后，发现自己不是权威 DNS ，且无对应的缓存数据，于是将请求转发给 其他 DNS 服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其他 DNS 服务器 接收到请求后，一样发现自己不是权威 DNS，且无对应的缓存数据，于是开始进行 DNS 迭代查询：将请求发送给根域名服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;根域名服务器接收到请求后，将顶级域名服务器 (.com) IP 发送给其他 DNS 服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其他 DNS 服务器根据 IP 将 DNS 查询请求发送给 顶级域名服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;顶级域名服务器接收到请求后，将 二级域名服务器 (jianshu.com) IP 发送给其他 DNS 服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其他域名服务器根据 IP 将 DNS 查询请求发送给二级域名服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;二级域名服务器 接收到请求后，发现自己是权威 DNS 服务器，于是将 www.lawootrip.com 映射的 IP 151.101.72.133 发送给其他域名服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其他域名服务器 接收到解析结果后，将 151.101.72.133 逐层返回传递下去，最终直至 192.168.1.1&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;15.192.168.1.1 接收到 www.lawootrip.com 解析结果 151.101.72.133 ，根据 IP 与 www.lawootrip.com 建立 TCP 连接，然后发起 HTTP 请求主页内容&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;二浏览器加载网页的基本过程&quot;&gt;二、浏览器加载网页的基本过程&lt;/h3&gt;

&lt;p&gt;1、从浏览器地址栏的请求链接开始，浏览器通过DNS解析查到域名映射的IP地址，成功之后浏览器端向此IP地址取得连接，成功连接之后，浏览器端将请求头信息通过HTTP协议向此IP地址所在服务器发起请求，服务器接受到请求之后等待处理。&lt;/p&gt;

&lt;p&gt;2、览器加载显示html的顺序是：从上到下，渲染的顺序也是从上到下，下载和渲染是同时进行的。如果遇到语义解释性的标签嵌入文件(JS脚本，CSS 下载过程会启用单独连接进行下载，并且在下载后进行解析，解析过程中，停止页面所有往下元素的下载。&lt;/p&gt;

&lt;p&gt;3、什么原因会导致网页加载过慢?浏览器可以在下载CSS资源的同时，并行解析HTML文件，但是，一旦发现有脚本文件的引用，则必须等待脚本文件完成下载并且执行后才能继续解析。内容下载时间主要取决于用户带宽、服务器带宽、文件大小、文件数量等。一般来说，将静态文件挂在CDN上，甚至全站CDN，往往能较好的解决这类问题。&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;2&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;三合理利用dns-ttl值-增加域名的缓存命中率&quot;&gt;三、合理利用DNS TTL值 增加域名的缓存命中率&lt;/h3&gt;

&lt;p&gt;1、DNS 服务器采用递归或迭代来处理客户端查询时，它们将发现并获得大量有关 DNS 命名空间的重要信息。然后这些信息由服务器缓存。缓存为 DNS 解析流行名称的后续查询提供了加速性能的方法，同时大大减少了网络上与 DNS 相关的查询通信量。&lt;/p&gt;

&lt;p&gt;2、TTL(Time-To-Live)即一条域名解析记录在DNS服务器上缓存时间。当信息缓存时，生存时间 (TTL) 值适用于所有缓存的 RR。只要缓存 RR 的 TTL 没有到期，DNS 服务器就可继续缓存并再次使用 RR 来应答与这些 RR 相匹配的客户端提出的查询。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-05-15-TTL.png&quot; alt=&quot;DNS服务进程&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;TTL设置&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;3、适当地增大TTL值可以让DNS Server缓存该域名更长时间，增加缓存的命中率。TTL一般默认为一小时，可以根据实际情况设为一天甚至一周以上。当然，如果你域名的IP经常变化，则TTL不应过大，否则各地的DNS Server会暂时无法获得新的正确的IP地址。&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;3&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;四合理使用dns-prefetch让dns预读取&quot;&gt;四、合理使用DNS-prefetch让DNS预读取&lt;/h3&gt;

&lt;p&gt;1、从上面浏览器加载网页的过程可以看出，网页的请求是可以多任务同时进行的，对于网页有多个DNS请求的情况，可以让浏览器在后台先把要使用的DNS请求默默地完成，这样当用户在打开新的网页时，就可以节省DNS查询的时间了。&lt;/p&gt;

&lt;p&gt;2、控制浏览器的DNS预读取就是DNS-prefetch标签了，DNS Prefetch应该尽量的放在网页的前面，&lt;/p&gt;

&lt;p&gt;格式类似是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;link rel=&quot;dns-prefetch&quot; href=&quot;//img.lawootrip.com&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;　
很多网站都使用使用百度广告联盟代码，使用这个就可以预读取DNS了。&lt;/p&gt;

&lt;p&gt;3、默认情况下浏览器会有隐式的DNS Prefetch，即会对页面中和当前域名(正在浏览网页的域名)不在同一个域的域名进行预获取，并且缓存结果，我们可以通过下面的标签禁止隐式的DNS Prefetch：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;meta http-equiv=”x-dns-prefetch-control” content=”off”&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4、需要注意的就是，DNS Prefetch只需要在用户在第一次打开网站时使用即可，没有必要每个页面都使用DNS Prefetch，否则就是重复DNS读取了，反而还无形中增加了DNS查询的次数，效果适得其反。&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;4&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;五dns域名解析拆分为多个域名增加并行下载量&quot;&gt;五、DNS域名解析拆分为多个域名增加并行下载量&lt;/h3&gt;

&lt;p&gt;1、一般来说网页的内容加载时会发生多个域名请求服务，如果你的网站JS、CSS、图片等非常多的话，建议将这些文件分别放在不同的域名上，这样浏览器在打开某一个页面时就可以同时向这些域名发送DNS解析请求了，能在一定程度上减少DNS时间。&lt;/p&gt;

&lt;p&gt;2、网页的内容越多，分析的域名应该尽量多一些。例如html、htm，js、css，jpg、png、gif，php、asp都可以放在不同的域名上。在实际应用上，使用全站CDN或者是静态文件CDN就可以实现上述效果，并且结合css sprite一起来使用的。&lt;/p&gt;

&lt;p&gt;3、css sprite(雪碧图)的作用恰恰相反，它不是增加域名请求，而减少域名DNS请求，主要是用在图片上。它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，这样一来，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;5&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;六加快域名dns解析速度方法小结&quot;&gt;六、加快域名DNS解析速度方法小结&lt;/h3&gt;

&lt;p&gt;1、以上就是一些简单的优化DNS小技巧，即时对个人开发者来说也没有什么门槛和技术难度，但是对提升网站的响应速度却有着明显的功效，大家不妨一试。&lt;/p&gt;

&lt;p&gt;2、除了从网站本身的DNS解析来加快访问速度外，我们平常在选择DNS服务时尽量使用那些稳定可靠的DNS服务，这样的DNS服务响应速度和缓存率都是非常不错的。假如自己的网站分拆了多个二级域名，不妨好好用用CNAME，设置好TTL时间，保证网站的第一次解析，可以直接从运营商的DNS缓存中拿到。&lt;/p&gt;

&lt;p&gt;此处顺便推荐三个神器，两个神服务。&lt;/p&gt;

&lt;p&gt;“DNSpod”作为NS服务商，免费稳定专业。&lt;/p&gt;

&lt;p&gt;“七牛云CDN”作为CDN服务商，免费稳定专业。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-05-15-shenqi.png&quot; alt=&quot;Chrles+Dig+微信web工具&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;Chrles+Dig+微信web工具&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;MAC环境下，推荐 &lt;strong&gt;Charles&lt;/strong&gt;用来进行数据抓包，网络通讯分析；&lt;strong&gt;Dig&lt;/strong&gt;用来检测DNS，GUI界面，简单直观好用；&lt;strong&gt;微信web工具&lt;/strong&gt;作为辅助，尤其是你的产品需要在微信内打开时，必备工具。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt; 
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Mon, 15 May 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/05/15/DNS-optimization/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/05/15/DNS-optimization/</guid>
        
        <category>笔记</category>
        
        <category>DNS</category>
        
        
      </item>
    
      <item>
        <title>浅析微信扫码登陆</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;实现微信登录，不一定要认证微信开放平台。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;话不多说，直接上图。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/25s.png&quot; alt=&quot;25s&quot; /&gt;&lt;/p&gt;

&lt;p&gt;先看登录二维码的分析，可以清楚看到页面先后加载了网页、图片、CSS、Javascript等资源文件，包括二维码图片。&lt;/p&gt;

&lt;p&gt;然后仔细观察会发现，网页会一直在异步请求一个链接，这个链接其实就是在监听服务器，如果有人用微信客户端授权成功，则会返回成功的信息然后跳转；否则继续监听。&lt;/p&gt;

&lt;p&gt;这个过程就是整个网页最重要的部分了，通过不断请求来监听状态。所以需要重点分析此请求。&lt;/p&gt;

&lt;p&gt;从图中我们还可以看到，右侧，每个请求都是用了25s左右。为什么要这么长时间呢？&lt;/p&gt;

&lt;p&gt;由于监听和登录操作肯定是短时间内必须完成的，比如我扫完二维码确认登录了，这个页面就要在短时间内做出响应。如果要做到这样，最简单的方法就是通过Javascript定时器，每隔几秒请求服务器并获取状态（事实上我同时也研究过新浪微博的扫二维码登录，它就是这样做的，每隔3-4秒左右请求一次）。然而这样会直接导致的问题就是，服务器会产生非常高的并发，小用户级别的服务器还没什么，但是像微信这种需要服务庞大用户群的服务器，就必须做这方面的优化。&lt;/p&gt;

&lt;p&gt;所以微信的采用的做法就是减少请求并增加响应时间，实现的原理大概就是在服务器端接收到请求后，内部加个定时器不断检查用户授权的状态，如果检测到用户授权则马上响应给网页端；否则继续检查；当时间累积到25秒左右，不论成不成功都终止检测并立即响应给网页端。&lt;/p&gt;

&lt;p&gt;好了，我们接下来继续观察这个请求的参数：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/17-04-26-query.png&quot; alt=&quot;query&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到总共有五个参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;loginicon ：布尔值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;uuid：字符串&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;tip ：正整数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;r：负整数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;_：正整数&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从字面上来理解的话，&lt;/p&gt;

&lt;p&gt;第一个参数大概意思是，是否要有登录图标（true=&amp;gt;要，false=&amp;gt;不要）；&lt;/p&gt;

&lt;p&gt;第二个参数，是指二维码的值，随便测试下就知道了；&lt;/p&gt;

&lt;p&gt;第三个参数，应该是指是否要提示（1=&amp;gt;要，0=&amp;gt;不要）；&lt;/p&gt;

&lt;p&gt;第四个参数，应该是一个随机数（random）；&lt;/p&gt;

&lt;p&gt;第五个参数，不难看出这是个Unix时间戳。随机数和时间戳跟安全机制有关吧，防止相关的攻击，如重放攻击。&lt;/p&gt;

&lt;p&gt;这几个参数当中，最重要的是当然是uuid了，因为这是用来向服务器请求授权状态的凭借。并且这个uuid必须是唯一不重复的，不然试想下，两个人在不同的电脑下浏览到了同一个二维码，有人授权登录了，可能会是在另一个人电脑上登录微信的网页版。所以说这个唯一的uuid是专门用来绑定一个微信账号的授权的。&lt;/p&gt;

&lt;p&gt;因为uuid一般是随机生成的，但是像这里的这串字符，观察最后两个字符“==”，又像是经过某个加密算法产生的，不过这并不太重要，确保到uuid的唯一不重复性就行了。至于r这个参数，我个人猜测这是个随机数。最后一个参数是用来做超时验证操作的，确保一个uuid只在短时间内有效，如果你仔细观察，会发现二维码登录页在几分钟内不登录，那么它会自动刷新然后更新过另外一个二维码。最后利用这三个进行某种算法之后生成签名（下面提到的ticket值）返回给客户端。&lt;/p&gt;

&lt;p&gt;接下来我们看看这个请求的返回值：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/17-04-26-response.png&quot; alt=&quot;response&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从图中我们可以看到返回的是一条Javascript语句，有个状态码408，这个就是表示用户还没有用微信客户端APP授权，需要继续请求监听状态。如果是授权成功，则返回200，然后登录页会跳转到后台：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;window.code=200;
window.redirect_uri=&quot;https://wx.qq.com/cgi-bin/mmwebwx-bin/webwxnewloginpage?ticket=AV09Uzr8oDEF1xoAcaOdNUi@articket_0&amp;amp;uuid=wdBJJLlfaQ==&amp;amp;lang=zh_CN&amp;amp;scan=1431123223&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;ticket值就是服务器生成的用户签名，理解为access_token即可。&lt;/p&gt;

&lt;p&gt;再来看看微信客户端APP扫描二维码后的页面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/17-04-26-app.PNG&quot; alt=&quot;app&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当扫描成功二维码后，会弹出授权窗口，询问是否授权登录。&lt;/p&gt;

&lt;p&gt;换个二维码扫描软件可以得到登录时候的二维码字符串实际值如图。经过多次试验可以知道前半段不变的，只有后面的参数会变（&lt;strong&gt;即uuid值&lt;/strong&gt;）。&lt;/p&gt;

&lt;p&gt;所以分析得到微信客户端的步骤是这样的：&lt;/p&gt;

&lt;p&gt;1.扫描二维码（扫一扫）&lt;/p&gt;

&lt;p&gt;2.如果字符串前半段是https://login.weixin.qq.com/l/，则弹出授权窗口&lt;/p&gt;

&lt;p&gt;3.如果点击确定，再向服务器请求改变这个uuid的状态&lt;/p&gt;

&lt;p&gt;完整的流程图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/17-04-26-flow-chart.jpg&quot; alt=&quot;flow-chart&quot; /&gt;&lt;/p&gt;

&lt;p&gt;至此，整个的扫二维码登录流程就完成了。&lt;/p&gt;

&lt;p&gt;至于如何利用在此剖析的原理进行二次开发和利用，就尽情发挥你的聪明才智吧。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt; 
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

</description>
        <pubDate>Wed, 26 Apr 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/04/26/https-con/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/26/https-con/</guid>
        
        <category>笔记</category>
        
        <category>微信</category>
        
        
      </item>
    
      <item>
        <title>各种加密代理协议的简单对比</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;目前我们常用的加密代理有协议有 HTTPS，SOCKS5-TLS 和 shadowsocks,此文从各个角度简单分析各个协议的优劣，以帮助各位选择合适的协议。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本文将从&lt;a href=&quot;#0&quot;&gt;性能&lt;/a&gt;、&lt;a href=&quot;#1&quot;&gt;数据安全性&lt;/a&gt;、&lt;a href=&quot;#2&quot;&gt;抗识别&lt;/a&gt;、&lt;a href=&quot;#3&quot;&gt;部署难度&lt;/a&gt;、&lt;a href=&quot;#4&quot;&gt;功能&lt;/a&gt;，五个方面对各类协议进行对比阐述。&lt;/p&gt;

&lt;p&gt;先简单说些背景知识，以上协议都是基于 TCP 的代理协议，代理协议（Proxy Procotol）与 VPN 不同，仅可被用于通过代理服务器转发 TCP 连接（shadowsocks 支持代理 UDP），而 VPN 可被用于 IP 层上的所有协议，如 TCP、UDP、ICMP 等。所以在使用代理时，ping 等 ICMP 应用是不可以被代理的。&lt;/p&gt;

&lt;p&gt;然后简单解释一下什么是 TLS，TLS 又名 SSL，是针对数据流的安全传输协议。简单来说，一个 TCP 链接，把其中原本要传输的数据，按照 TLS 协议去进行加密传输，那么即可保证其中传输的数据安全。这个安全至少体现在以下几个方面：&lt;/p&gt;

&lt;p&gt;数据被加密，任何可以截取到 TCP 数据流的人，无法解密出原始数据；
数据不可被篡改，一旦篡改会导致解密失败，连接断开；
服务器身份验证，基于 X509 的证书体系去确认目标服务器是否为真实的服务器。
明文的 HTTP 套上一层 TLS，也就变成了 HTTPS，SOCKS5 套上 TLS，就变成了 SOCKS5-TLS。TLS 协议是整个互联网安全的基石，几乎所有需要安全传输的地方都使用了 TLS，如银行、政府等等。&lt;/p&gt;

&lt;p&gt;当被用作代理协议时，HTTP 层和 SOCKS5 层去进行具体的代理连接控制，如进行身份验证、告知需要转发的目标主机名等。所以不需要 TLS 他们也可以用作代理，只不过所有数据都是明文传输，不具备安全性。加上 TLS 后，由 TLS 去保证安全。而 shadowsocks 协议则融合了代理控制和安全保证。所以后文的很多对比实际上是 shadowsocks 和 TLS 的对比。&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;0&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;性能&quot;&gt;性能&lt;/h1&gt;

&lt;p&gt;TLS 协议由于承担了一项额外的功能，需要验证目标服务器身份，导致其握手时会比较复杂。&lt;/p&gt;

&lt;p&gt;ping 的时间表示，一个 IP 层数据包从本地发出，到服务器再返回的来回时间，即 RTT（round-trip time）。&lt;/p&gt;

&lt;p&gt;在发起代理连接时，首先我们需要进行 TCP 3 次握手，耗时为 1 个 RTT。（此处把最后的 ACK 直接并入后续的数据传输部分）。&lt;/p&gt;

&lt;p&gt;然后进行 TLS 握手，因为服务端和客户端需要进行身份验证并协商协议版本号、加密方式等细节，第一次连接时需要 2 个 RTT。当然 TLS 的制定者也发现这太慢了，于是引入了 TLS Session Resumption，当服务端和客户端服务器连接过一次后，之后的连接可以直接复用先前的协商结果，使得 RTT 降低到 1 个 RTT。但这需要服务器和客户端的支持。（这是为什么 Surge benchmark 时，对于 TLS 代理第一次的测试结果可能较慢的原因之一）&lt;/p&gt;

&lt;p&gt;对于 HTTPS 协议，当 TLS 连接建立后，客户端通过 HTTP 层发起代理请求，服务端回应连接建立，此后进入正常的代理通讯环节，再耗费 1 个 RTT。&lt;/p&gt;

&lt;p&gt;对于 SOCKS5-TLS 协议，当 TLS 连接建立后，如果没有验证的环节，那么需要再耗费 1 个 RTT，如果有验证（用户名密码），那么需要耗费 2 个 RTT。&lt;/p&gt;

&lt;p&gt;而对于 shadowsocks，由于使用的是预共享密钥（pre-shared key, PSK），加密方式也是预先约定好的，所以不需要进行协商，只需要在 TCP 建立之后，再耗费一个 1 个 RTT 告知目标主机名。&lt;/p&gt;

&lt;p&gt;总结如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTPS（TLS Session Resumption）：3 个 RTT

SOCKS5-TLS 无验证：3 个 RTT

SOCKS5-TLS 有验证：4 个 RTT

shadowsocks：2 个 RTT
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;（注：最后一个 RTT 并不严谨，因为客户端可以在最后一个 RTT 产生响应前，直接开始后续传输。另外如果使用了 TCP Fast Open，可以看作 TCP 阶段 RTT 为 0。）&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;对于日常使用，最影响性能的就是握手速度，后续传输过程中的加解密性能，对于现代 CPU 来说基本都不会构成瓶颈。 shadowsocks 由于有 PSK 的特点，在 TCP 协议基础上已经达到极限，不可能有协议能再低于 2 个 RTT。&lt;/p&gt;

&lt;p&gt;所以，同等网络环境下，shadowsocks 是明显快于 HTTPS 的。（体现在延迟上，而不是带宽）&lt;/p&gt;

&lt;p&gt;另外，最新的 TLS 1.3 协议正力图解决这个问题，由于目前还处于草案阶段，各种工具链不完善，现在不太好评估实际效果。&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;数据安全性&quot;&gt;数据安全性&lt;/h1&gt;

&lt;p&gt;（此处说的数据安全性，指的是加密后的流量是否会被截取并破解的问题。）&lt;/p&gt;

&lt;p&gt;对于 TLS，作为个人用户，丝毫不用担心，TLS 协议如果真的不安全了，世界早就乱套了…&lt;/p&gt;

&lt;p&gt;对于 shadowsocks，使用的加密方法也都是工业上成熟的算法，从数据安全性角度考虑也基本不用担心。&lt;/p&gt;

&lt;hr /&gt;

&lt;p id=&quot;2&quot;&gt;&lt;/p&gt;

&lt;h1 id=&quot;抗识别&quot;&gt;抗识别&lt;/h1&gt;

&lt;p&gt;这个问题有两个角度需要考虑：&lt;/p&gt;

&lt;p&gt;观察一段数据流量，是否能判别这是一个代理协议的流量；
对于一个仅暴露出 TCP 端口的黑箱，能否判断这个端口提供了代理服务。
对于 shadowsocks 协议，在第一点上，观察者只能判定这个数据流为未知的协议。而第二点，shadowsocks 的几次修改，都是因为在这出了问题，目前最新的 AEAD 加密方式，应该已经解决了这个问题，但还需要时间去检验。&lt;/p&gt;

&lt;p&gt;对于 HTTPS 协议，在第一点上，观察者是无法去区分这是一个代理还是一个标准的 HTTPS 网页访问的。而第二点，在妥善配置的情况下，也是完全无法判别。&lt;/p&gt;

&lt;p&gt;但在实践中，大部分 HTTPS 代理服务器为了兼容浏览器行为，在直接被当做 HTTPS Web 服务器访问时，会返回代理错误页或者 407 Proxy authentication required，直接暴露了自己是一个代理，如果要抗击第二点，可以将服务端的行为修改为，如果请求的 Header 中，不包含一个有效的 Auth，那么就返回一个标准的 200 页面，这样从理论上杜绝了被嗅探的可能。&lt;/p&gt;

&lt;p&gt;总结一下，最新的 shadowsocks 已经能满足抗识别的两个要求，但是观察者得到结论是“未知协议”。而使用 HTTPS，观察者无法判断这是一个 HTTPS 代理还是 HTTPS Web 服务器，这是更优的结果。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hiding true identities inside a seemingly ordinary. — Person of Interest S03E23&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;p id=&quot;3&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;部署难度&quot;&gt;部署难度&lt;/h1&gt;

&lt;p&gt;HTTPS 协议使用广泛，有众多成熟的工业级工具，如 squid，haproxy，nghttp2 等等，但是由于 HTTPS 协议本身比较复杂，配置起来参数众多，有很多性能相关参数需要自己调优，所以一般用户配置起来会有难度。&lt;/p&gt;

&lt;p&gt;shadowsocks 经过多年发展，目前也已经有众多的软件支持，但是对于不同特性的支持度不一。由于参数简单，部署配置起来极其方便。&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;4&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;功能&quot;&gt;功能&lt;/h1&gt;

&lt;p&gt;shadowsocks 目前还存在一些功能上的缺陷：&lt;/p&gt;

&lt;p&gt;1.shadowsocks 没有设计错误回报机制，对于以下错误，客户端看到的行为都是服务器主动断开 TCP 连接：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;密钥或者加密方法错误&lt;/li&gt;
  &lt;li&gt;目标主机名 DNS 解析失败&lt;/li&gt;
  &lt;li&gt;目标主机不可达&lt;/li&gt;
  &lt;li&gt;目标主机拒绝连接&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2.这使得客户端没办法根据不同的错误采取进一步的动作，只能简单的向用户返回 Socket closed by remote 错误。&lt;/p&gt;

&lt;p&gt;3.shadowsocks 没有考虑用户鉴别，使得服务端 ACL 或者流量统计等功能无法实现，主流的 workaround 是通过不同的端口号去识别不同的用户，但这极其浪费资源且很不优雅。
部分 ISP 对于非 HTTP 和 TLS 的未知流量，会进行降速限制，这个可以通过配置 obfs 解决。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt; 
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Tue, 18 Apr 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/04/18/https-con/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/18/https-con/</guid>
        
        <category>笔记</category>
        
        <category>代理协议</category>
        
        
      </item>
    
      <item>
        <title>美国《消费者报告》简史</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;CR知多少&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;几百年前很少有人因选东西而烦恼，产品种类少，构造简单，短时间上手就能判断好坏。近代科学技术的爆发改变了一切。企业和品牌喷涌而出，商品市场如雨林般繁复，很多产品的微妙区别已经超出普通人的辨识范围。&lt;/p&gt;

&lt;p&gt;选购之时我们常说这个好、那个坏，产品好坏究竟指什么？性能、安全性、可靠性，还是多种指标的综合？如果是性能，有哪些指标，哪个是核心指标？如果是可靠性，用什么来衡量？&lt;/p&gt;

&lt;p&gt;当你想要了解商品知识时，离你最近的是喧嚣的媒体和广告——请仔细思量：广告是什么？广告是企业发明出来蛊惑人心的玩意儿，绝大部分混杂着诡计和套路。对选购来说，它们是迷宫，是泥沼，是错误的路标。&lt;/p&gt;

&lt;p&gt;然而在很长一段时间里，人们只能以流言和广告为基础，凭感觉进行选购。面对狡猾的企业，绝大部分消费者像猴子一样无知。&lt;/p&gt;

&lt;p&gt;直到二十世纪初，形势才稍有改善。当时的美国，强国气象已现，新玩意儿层出不穷，少数人不甘心被大众媒体愚弄，一种组织应运而生。&lt;/p&gt;

&lt;p&gt;1927 年，消费者历史上一本重要的书诞生了：《Your Money’s Worth》，作者便是日后消费者运动的两员大将：Frederick J. Schlink（富理德里克·J·施林克） 和 Stuart Chase（斯图尔特·蔡斯） 。
&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-2.png&quot; alt=&quot;2&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;《Your Money’s Worth》封面，来源：raretradingbooks&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;这本书详细介绍了食品、医药、汽车、家电等领域的诡计陷阱和过度广告。大获成功之后，施林克和斯图尔特趁热打铁创立了 Consumer Club（消费者俱乐部），经过两年的呼吁和准备， 1929 年又成立了 Consumers Research（消费者研究）。
&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-3.png&quot; alt=&quot;3&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;施林克和消费者研究实验室，来源：consumersresearch.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;这是一个什么样的组织？它致力于测试各式产品，发布商品指南，指导人们选购。&lt;/p&gt;

&lt;p&gt;它是一个非营利性组织，也是世界上第一个消费者组织。自此之后，消费者组织在美国和世界各地陆续出现，并由消费者研究确立了两大原则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;独立于企业，不接受企业送测和资助。&lt;/li&gt;
  &lt;li&gt;无商业广告，资金主要来自消费者订阅和捐赠。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;到了 1933 年，消费者研究已经有了 42000 名订阅者，但没过多久，消费者运动历史上最大的转折出现了。&lt;/p&gt;

&lt;p&gt;1933 年， 施林克决定把总部从纽约搬到华盛顿乡村，这一举动引发了不满。因工作时间长、工资低，几名员工要求加薪，但被施林克立刻拒绝。1935 年，三名员工组建了工会，施林克知道后炒了他们。此举激怒了众人，大家决定罢工，要求恢复解聘者职位并提高工资。&lt;/p&gt;

&lt;p&gt;施林克怎么回应？他拒绝调解和仲裁，雇人进行报复，还指控罢工者是共产主义者。这实在是一件很讽刺的事情，一个号称维护公共利益的组织，却掉过头来对付自己的员工。&lt;/p&gt;

&lt;p&gt;罢工者和支持者们都很愤怒，遂决定另起炉灶。1936 年，在 Arthur Kallet（阿瑟·卡莱特）、Colston Warne（科尔斯顿·沃恩）等人的带领下， Consumers Union（消费者联盟）成立了，并出版一份叫 Consumers Union Reports（消费者联盟报告）的杂志 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-4.png&quot; alt=&quot;4&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;左为阿瑟·卡莱特，右为科尔斯顿·沃恩，来源：Consumer Reports - Kevin P. Manion&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;此时的消费者联盟报告，就是日后消费者运动中神祇一般的存在——Consumer Reports（消费者报告）。（PS：下文统称为 CR）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-5.png&quot; alt=&quot;5&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;1936 年 5 月，第一期 CR 出版，评测了肥皂、丝袜、牛奶等产品，来源：consumerreports.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;CR 从一诞生就受到多方夹击：&lt;/p&gt;

&lt;p&gt;一面是同行的抵制， 曾有 60 多种出版物拒绝刊登 CR 的募捐广告。 Reader’s Digest （读者文摘） 认为 CR 想给经济体系抹黑，Good Housekeeping（好管家） 谴责 CR 通过打破大众对广告组织的信任，延长了大萧条（PS：当时大萧条刚结束不久）。&lt;/p&gt;

&lt;p&gt;一面是消费者研究的打压，施林克不断指控消费者联盟是共产主义组织，终于在 1939 年，消费者联盟被 HUAC（非美活动调查委员会）列入 Subversive Organizations（颠覆性组织）名单，直到 1954 年才从名单中去除。&lt;/p&gt;

&lt;p&gt;最初，CR 的订阅量只有 4000，到了1936 年底，订阅量已经超过了 37000 。由于资金短缺，早期只能评测牛奶、丝袜、热水瓶、收音机、风扇等等便宜货。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-6.png&quot; alt=&quot;6&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;30年代，CR探讨了过度广告、维生素过度补充、吸烟危害等问题，来源：consumerreports.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;今人或许难以想象，二十世纪初的美国，避孕用品仍被视为「淫秽物品」， 1873 年通过的禁止淫秽作品和不道德物品的《康斯托克法》，在当时仍然有效。&lt;/p&gt;

&lt;p&gt;1937 年 ，CR 出版了《避孕用品报告》，却被邮局告知禁止寄送。CR 随即把邮局告上法庭，历时七年，法院最终否决了该禁令。&lt;/p&gt;

&lt;p&gt;1939 年，CR 的订阅量达到到 85000，然而第二次世界大战改变了一切。战争时期，制造业集中生产军用品，民众对评测的需求变小，市面上也没多少商品可供评测。&lt;/p&gt;

&lt;p&gt;到 1942 年 ，CR 的订阅量下滑到 1939 年的一半。这一年，Consumers Union Reports（消费者联盟报告）改名为 Consumer Reports（消费者报告）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-7.png&quot; alt=&quot;7&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;上世纪 40 年代，CR 批评利用战时产品短缺谋取高利的企业，揭露无用的「科学」助眠产品，并在战后给出汽车选购建议，来源：consumerreports.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;二战结束，人们继续买买买， CR 迎来大发展。1946 年的订阅量达到 10  万，1950 年，订阅量到达 40 万。&lt;/p&gt;

&lt;p&gt;1947 年，CR 测试了自动洗衣机，1952 年，发布第一份汽车维修频率表，1954 年，发布第一份彩色电视评测，1958 年，抨击用低电压刺激肌肉的减肥产品。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-8.png&quot; alt=&quot;8&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;上世纪 50 年代，CR 呼吁安全带应当成为汽车标配，来源：consumerreports.orgg&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;1954 年，CR 董事会决定把总部从纽约市搬到纽约州弗农山，办公室和试验室得以扩大，并添置了新的测试设备。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-9.png&quot; alt=&quot;9&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;1954 年，CR 迁到新总部，来源：Consumer Reports - Kevin P. Manion&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;迁到新家之后，CR 决定不再只是评测商品，开始更多介入消费者相关的事务。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-10.png&quot; alt=&quot;10&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;1954 年，读者参观 CR 的实验室，来源：Consumer Reports - Kevin P. Manion&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;50 年代末，CR 的实力更加强大，开始向其他消费者组织援助，并致力于领导世界范围内的消费者运动，协助成立了 IOCU（国际消费者联盟），即现在的 CI（国际消费者协会）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-11.png&quot; alt=&quot;11&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;1960 年，IOCU 成立，来源：Consumer Reports - Kevin P. Manion&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;在 50 年代末 60 年代初，CR 进行了几项核试验对日常饮食影响的研究（如 1959 年对牛奶的调查），促使政府加强对核辐射灰尘的监测，并赢得公众对禁止核试验条约的支持。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-12.png&quot; alt=&quot;12&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;1961 年的核辐射避难所宣传图，来源：invisiblethemepark&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;有趣的是，冷战期间很多读者请求 CR 发布「核辐射避难所」指南，但由于其中的复杂变量和未知因素太多，消费者报告拒绝评测。为了照顾读者，最终分享了一位科学家的个人建造经验。&lt;/p&gt;

&lt;p&gt;1962 年，CR 发布了第一份汽车保险报告，并推动车险改革。1965 年， Ralph Nader 出版著名图书《Unsafe at Any Speed》，随后 CR 邀请他加入董事会，为汽车评测提供建议。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-13.png&quot; alt=&quot;13&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;上世纪 60 年代，汽车数量增加，CR 呼吁错开上班时间，增加公共交通工具，来源：consumerreports.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;在 Ralph Nader 的影响下，CR 评测汽车的流程和方法越来越专业。当时 CR 汽车评测的影响力有多大？1965 年， CR 把  Toyota（丰田）Corona 评为「特别适合长途驾驶」， 1975 年，Corona 成了美国汽车市场进口最多的一款车型。&lt;/p&gt;

&lt;p&gt;CR 历史上长期关注过几类产品，有汽车、儿童用品，以及香烟。&lt;/p&gt;

&lt;p&gt;在二十世纪早期，吸烟危害并未成为共识，并且在烟草行业的鼓吹下，吸烟被认为是一件尊贵、性感和潇洒的事情：&lt;/p&gt;

&lt;p&gt;一个著名的契斯特菲尔德牌香烟广告给出这样一幅场景：一位优雅的男士和一位迷人的女士浪漫地坐在海边，男人正在点燃一根卷烟，旁白是： 「呼出我的风格。」来源：钓愚：操纵与欺骗的经济学 - 乔治·阿克洛夫、罗伯特·席勒&lt;/p&gt;

&lt;p&gt;从 1953 到 1964 年，CR 不断发文探讨吸烟危害，揭露烟草行业的诡计，并在 1963  年出版《消费者联盟关于吸烟与公共利益的报告》。&lt;/p&gt;

&lt;p&gt;1964 年，美国卫生总署《吸烟与健康》 出台，以政府立场明确了吸烟危害，文中引用了 CR 的报告。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-14.png&quot; alt=&quot;14&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;1968 年 11 月，CR 评测了电动玩具，来源：consumerreports.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;1968 年，CR 测试了多款电动玩具，发现其中四分之一存在风险，将它们评为「不可接受」。1969 年，在这项测试的促进下，《保护儿童和玩具安全法案》通过。&lt;/p&gt;

&lt;p&gt;1972 年，在 CR 的推动下，《消费者产品安全法》通过，美国 CPSC （消费品安全委员会）成立。同一年 ，CR 第一次测试儿童安全座椅，把 17 款中的 12 款评为「不可接受」，随后致力于推动更严格的安全标准出台。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-15.png&quot; alt=&quot;15&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;上世纪 70 年代，CR 研究了微波产品的辐射泄漏问题，来源：consumerreports.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;1974 年，CR 发布了一系列关于美国水污染的文章，并给出详细的清理建议。为此，CR 获得了当年的 National Magazine Awards（国家杂志奖），在这之后，又获得三次该奖项。&lt;/p&gt;

&lt;p&gt;80 年代， CR 在新内容上进行了多方面的尝试，比如一系列旅游和健康方面的刊物。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-16.png&quot; alt=&quot;16&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;Penny Power 封面，来源：Consumer Reports - Kevin P. Manion&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;1980 年，CR 出版儿童杂志 Penny Power（后来改为 Zillions ）。1983 年，CR 发表了一篇 28 页的电脑选购建议，评测了包括苹果在内的 17 款个人电脑。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-17.png&quot; alt=&quot;17&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;上世纪 80 年代的，CR 抨击保健品行业，来源：consumerreports.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;在这篇文章里，CR 作出预测：到 2000 年，电脑会像电视一样普及。&lt;/p&gt;

&lt;p&gt;1986 年，CR 董事会决定在 Connecticut（康涅狄格州）的 East Haddam（东哈德姆）买一条跑道，并将其改造成当时最先进的汽车测试场。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-18.png&quot; alt=&quot;18&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;CR 位于东哈德姆的汽车测试跑道，来源：wikipedia.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;这一年，也是 CR/CU 的 50 岁生日。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-19.png&quot; alt=&quot;19&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;CR 位于东哈德姆的汽车测试跑道，来源：wikipedia.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;1988 年，在这个汽车测试场地，CR 测试发现 Suzuki（铃木）的 Samurai（武士） 容易翻车，将它评为「不可接受」。&lt;/p&gt;

&lt;p&gt;报告一出，该车销量急速下降，几年后退出美国市场，并于 1995 年停售。铃木公司很不高兴，在 1996 年将 CR 告上法庭，这场官司一打就是 8 年，最终以「庭外和解」结束。&lt;/p&gt;

&lt;p&gt;到 2010 年为止，CR 和厂商打了 16 次产品诽谤的官司，但没有一次输过或赔款。面对 CR 对自己不利的评测结果，大部分公司选择接受并改进。&lt;/p&gt;

&lt;p&gt;如 2010 年的苹果 iPhone 4 的天线问题（通过派发保护套解决），雷克萨斯的 GX460 SUV 的安全问题（通过召回解决），以及前不久苹果  MacBook Pro 的电池问题（通过软件更新解决）。&lt;/p&gt;

&lt;p&gt;90 年代以后，CR 顺应潮流以多种形式发布信息，包括光盘、电视节目、网站等等，还成立了图书出版部门。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-20.png&quot; alt=&quot;20&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;上世纪 90 年代的 CR，来源：consumerreports.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;1991 年，CR 将总部从弗农山迁至附近的扬克斯。1992 年，CR 的订阅会员达到 200 万。随后几年，CR 向医疗保健行业发起挑战。&lt;/p&gt;

&lt;p&gt;1994 年，CR 促使加州的医疗保健公司从非营利性转为营利性，并将收回来的资金用于公共利益，这一转换计划后来扩展到其他几十个州。1995年，CR 起诉加州的一家医疗保健公司，批评它的营销方式，并阻止其在加州销售。&lt;/p&gt;

&lt;p&gt;同一年，订阅量到达 470 万，进入付费订阅杂志前十名。1996 年底，出版业估计 CR 的读者（包括图书馆和传阅的读者）超过 1800 万，是当时美国最流行的杂志之一。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-21.png&quot; alt=&quot;21&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;为保护消费者利益，CR 会出面反对一些公司的合并，来源：consumerreports.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;CR 不仅爱打官司， 还好管「闲事」。为保护消费者利益，2011 年，CR 出面反对通讯公司 AT&amp;amp;T  收购 T-Mobile ，2015 年，又反对 Comcast（康卡斯特） 收购 Time Warner（时代华纳）。&lt;/p&gt;

&lt;p&gt;但是，步入新世纪以后，CR 遇到新的问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;读者群体老龄化：2010 年时，网络会员平均年龄 56 岁，杂志会员的平均年龄 65 岁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了吸引年轻人，CR 进行了多方面的尝试：2006 年收购针对年轻女性的购物杂志「ShopSmart」，2008年收购读者较年轻的消费资讯博客 「Consumerist」。&lt;/p&gt;

&lt;p&gt;去年是 CR 八十年周年，网站大改版，以绿色为基调，设计更年轻化。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-22.png&quot; alt=&quot;22&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;最近几年的 CR，来源：consumerreports.org&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;除了有来自外界的挑战，CR 还要应对内部的失误，以下是部分负面消息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;90 年代，CR 发现其财务总监在采购中收取回扣，随后停止了他的工作，并将他告上法庭。&lt;/li&gt;
  &lt;li&gt;2002 年，CR 因质量问题召回汽车仪表板上的用的储物箱，它们之前被作为赠品送给订阅者。&lt;/li&gt;
  &lt;li&gt;2007 年，CR 犯了创立以来最大的错误。在当年的一份评测报告中，CR表示大多数儿童安全座椅在侧面撞击中都不安全。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2007 年的文章引发了恐慌和怀疑，几天后杂志撤回了这一报告，向读者道歉，并用四页的篇幅解释了错误的发生。&lt;/p&gt;

&lt;p&gt;这一事件对消费者报告的声誉产生了影响，但其回应方式某种程度上增强了公众对它的信赖。2008 年，订阅量不降反升，达到 800 万的巅峰。&lt;/p&gt;

&lt;p&gt;新世纪以来，CR 采取了一些有争议的举措：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;网站评测旁附有电商链接，部分产品有返利。&lt;/li&gt;
  &lt;li&gt;与亚马逊合作，允许其部分产品页面显示 CR 的选购指南。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基于多年累积的信誉，大多认为这些举措对其独立性影响不大。&lt;/p&gt;

&lt;p&gt;话说回来， 当年的消费者研究（Consumers Research）上哪去了？多年以来，消费者研究一边测试商品，一边打压 CR 。随着两个 CR 的差距越来越大， 80 年代，消费者研究被卖给私人，最终在 1983 年，正式关闭实验室。自此，消费者研究只关注消费领域的政策和资讯，不再测试产品。&lt;/p&gt;

&lt;p&gt;正如斯图尔特 蔡斯为 CR 二十五周年（1961 年）写的短文中所说：&lt;/p&gt;

&lt;p&gt;某种意义上，（独立的）消费者测试是一种必然的、对受大众媒体裹挟而困惑的消费者的回应。&lt;/p&gt;

&lt;p&gt;80 余年，无广告，拒绝送测，不受企业资助，仅靠捐赠和订阅生存，消费者报告战胜了老东家的诽谤，同行的排斥，企业的敌视，熬过了二战的低迷，每年评测数千种产品，在商品市场正视听、拨云雾，帮助消费决策，推动消费立法，领导消费者运动，最终成为消费者中神祇一般的存在。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-27-consumer-reports-history-22.png&quot; alt=&quot;23&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;CR 不同年代的产品测试场景，来源：Consumer Reports&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;2011 年，曾有报道称 CR 有意进入中国，但至今没有动静。最近几年，国内效仿 CR 的机构越来越多，也不断有人打出「中国的消费者报告」的旗号。&lt;/p&gt;

&lt;p&gt;一切都好像第二套广播体操开头说的那样：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;时代在召唤&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;让我们拭目以待。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;小贴士：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在评测完毕之后，CR 一般将产品拍卖给员工。&lt;/li&gt;
  &lt;li&gt;CR 不予许企业在宣传中引用其评测结果，不惜为此诉诸法律。&lt;/li&gt;
  &lt;li&gt;在很长一段时间里，CR 刻意与企业和政府保持距离，以免影响判断的独立性。2007年的失误出现后，才开始更多地咨询外界意见。&lt;/li&gt;
  &lt;li&gt;CR 目前有 50 个实验室，100 多个测试专家，超过 25 个调查统计研究人员，超过 150个匿名购物者。&lt;/li&gt;
  &lt;li&gt;CR 大部分测试由自己的实验室完成，少数委托给三方实验室，2007 年的比例是十分之一。&lt;/li&gt;
  &lt;li&gt;CR 曾拒绝一家汽车经销商的大量订阅，以免影响杂志的独立性和客观性。&lt;/li&gt;
  &lt;li&gt;CR和「CPSC’（美国消费品安全委员会）共享数据，帮助缺陷产品召回。&lt;/li&gt;
  &lt;li&gt;虽然有很多公司抱怨 CR，但都是针对其评测和结论，很少有人质疑其动机。&lt;/li&gt;
  &lt;li&gt;最近几年，CR 杂志和网络订阅量大致在 700 - 800 万。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;主要参考资料：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.fundinguniverse.com/company-histories/consumers-union-history/&quot;&gt;Consumers Union History - fundinguniverse&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.consumerreports.org/cro/about-us/whats-behind-the-ratings/index.htm&quot;&gt;Behind Our Ratings - Consumer Reports&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.consumerreports.org/consumer-protection/cover-worthy-80-years-of-consumer-reports-magazine/&quot;&gt;Cover Worthy: 80 Years of Consumer Reports Magazine - Consumer Reports&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.consumerreports.org/cro/about-us/history/vintage-photos/index.htm&quot;&gt;Vintage Photo Gallery - Consumer Reports&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://books.google.co.jp/books?id=MxOjAgAAQBAJ&amp;amp;hl=zh-CN&amp;amp;source=gbs_navlinks_s&quot;&gt;Jim Guest - Timothy LaPalme&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://play.google.com/store/books/details?id=uUUMCgAAQBAJ&amp;amp;rdid=book-uUUMCgAAQBAJ&amp;amp;rdot=1&amp;amp;source=gbs_vpt_read&amp;amp;pcampaignid=books_booksearch_viewport&quot;&gt;Watchdogs and Whistleblowers: A Reference Guide to Consumer Activism - Robert N. Mayer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.theatlantic.com/business/archive/2016/04/consumer-reports-in-the-age-of-the-amazon-review/477108/&quot;&gt;Consumer Reports in the Age of the Amazon Review -  The Atlantic&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.nytimes.com/2007/12/08/business/media/08consumer.html&quot;&gt;Success Without Ads - The New York Times&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.wsj.com/articles/SB10001424052748703866704575224093017379202&quot;&gt;Meet the Sticklers -  WSJ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://books.google.co.jp/books/about/Consumer_Reports.html?id=lCAiVjC6Sp8C&amp;amp;redir_esc=y&quot;&gt;Consumer Reports - Kevin P. Manion&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www2.scc.rutgers.edu/ead/manuscripts/consumers_introf.html&quot;&gt;An Inventory to the Records of Consumers’ Research, Inc. - Gregory L. Williams&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt; 
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Tue, 21 Feb 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/02/21/consumer-reports-history.markup/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/02/21/consumer-reports-history.markup/</guid>
        
        <category>笔记</category>
        
        
      </item>
    
      <item>
        <title>Merge、Rebase的选择</title>
        <description>&lt;blockquote&gt;
&lt;p&gt;BY &lt;a href=&quot;https://github.com/geeeeeeeeek/git-recipes/&quot;&gt;童仲毅geeeeeeeeek@github&lt;/a&gt;——目前看到的关于Merge、Rebase最通俗易懂的wiki。&lt;/p&gt;
&lt;p&gt;这是一篇在原文(&lt;a href=&quot;https://www.atlassian.com/git/tutorials/merging-vs-rebasing&quot;&gt;BY atlassian&lt;/a&gt;)基础上演绎的译文。除非另行注明，页面上所有内容采用知识共享-署名(&lt;a herf=&quot;https://creativecommons.org/licenses/by/2.5/au/deed.en&quot;&gt;CC BY 2.5 AU协议共享。&lt;/a&gt;)&lt;/p&gt; 
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt; 这个命令经常被人认为是一种Git巫术，初学者应该避而远之。但如果使用得当的话，它能给你的团队开发省去太多烦恼。在这篇文章中，我们会比较&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt;和类似的&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt;命令，找到Git工作流中rebase的所有用法。&lt;/p&gt;

&lt;h3 id=&quot;概述&quot;&gt;概述&lt;/h3&gt;
&lt;p&gt;你要知道的第一件事是，&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt; 和&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt; 做的事其实是一样的。它们都被设计来将一个分支的更改并入另一个分支，只不过方式有些不同。&lt;/p&gt;

&lt;p&gt;想象一下，你刚创建了一个专门的分支开发新功能，然后团队中另一个成员在master分支上添加了新的提交。这就会造成提交历史被Fork一份，用Git来协作的开发者应该都很清楚。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/919155232a162011b8a64a84872482034c0ce999/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f6d657267696e672d76732d7265626173696e672f30312e737667&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在，如果master中新的提交和你的工作是相关的。为了将新的提交并入你的分支，你有两个选择：merge或rebase。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;merge&quot;&gt;Merge&lt;/h3&gt;
&lt;p&gt;将master分支合并到feature分支最简单的办法就是用下面这些命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;　　git checkout feature
　　git merge master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者，你也可以把它们压缩在一行里。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git merge master feature
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;feature分支中新的合并提交(merge　commit)将两个分支的历史连在了一起。你会得到下面这样的分支结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/266aef357af48c218b8779cd489bcb8839aa0a25/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f6d657267696e672d76732d7265626173696e672f30322e737667&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Merge好在它是一个安全的操作。现有的分支不会被更改，避免了rebase潜在的缺点（后面会说）。&lt;/p&gt;

&lt;p&gt;另一方面，这同样意味着每次合并上游更改时feature分支都会引入一个外来的合并提交。如果master非常活跃的话，这或多或少会污染你的分支历史。虽然高级的git log 选项可以减轻这个问题，但对于开发者来说，还是会增加理解项目历史的难度。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;rebase&quot;&gt;Rebase&lt;/h3&gt;
&lt;p&gt;作为merge的替代选择，你可以像下面这样将feature分支并入master分支：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git checkout feature
git rebase master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;它会把整个feature分支移动到master分支的后面，有效地把所有master分支上新的提交并入过来。但是，rebase为原分支上每一个提交创建一个新的提交，重写了项目历史，并且不会带来合并提交。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/626197748d8d8493b194ce59874b71897c88c39f/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f6d657267696e672d76732d7265626173696e672f30332e737667&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;rebase最大的好处是你的项目历史会非常整洁。首先，它不像&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt; 那样引入不必要的合并提交。其次，如上图所示，rebase导致最后的项目历史呈现出完美的线性——你可以从项目终点到起点浏览而不需要任何的Fork。这让你更容易使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git log&lt;/code&gt; 、&lt;code class=&quot;highlighter-rouge&quot;&gt;git bisect&lt;/code&gt; 和&lt;code class=&quot;highlighter-rouge&quot;&gt;gitk&lt;/code&gt; 来查看项目历史。&lt;/p&gt;

&lt;p&gt;不过，这种简单的提交历史会带来两个后果：安全性和可跟踪性。如果你违反了Rebase黄金法则，重写项目历史可能会给你的协作工作流带来灾难性的影响。此外，rebase不会有合并提交中附带的信息——你看不到feature分支中并入了上游的哪些更改。&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;交互式的rebase&quot;&gt;交互式的rebase&lt;/h3&gt;
&lt;p&gt;交互式的rebase允许你更改并入新分支的提交。这比自动的rebase更加强大，因为它提供了对分支上提交历史完整的控制。一般来说，这被用于将feature分支并入master分支之前，清理混乱的历史。&lt;/p&gt;

&lt;p&gt;把&lt;code class=&quot;highlighter-rouge&quot;&gt;-i&lt;/code&gt; 传入&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt; 选项来开始一个交互式的rebase过程：
　　&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git checkout feature
git rebase -i master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;它会打开一个文本编辑器，显示所有将被移动的提交：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pick 33d5b7a Message for commit #1
pick 9480b3d Message for commit #2
pick 5c67e61 Message for commit #3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个列表定义了rebase将被执行后分支会是什么样的。更改pick 命令或者重新排序，这个分支的历史就能如你所愿了。比如说，如果第二个提交修复了第一个提交中的小问题，你可以用fixup 命令把它们合到一个提交中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pick 33d5b7a Message for commit #1
fixup 9480b3d Message for commit #2
pick 5c67e61 Message for commit #3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;保存后关闭文件，Git会根据你的指令来执行rebase，项目历史看上去会是这样：
　　
&lt;img src=&quot;https://camo.githubusercontent.com/b685d6f2a7b4ecf6896fa2439e8da2fb958195fd/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f6d657267696e672d76732d7265626173696e672f30342e737667&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　忽略不重要的提交会让你的feature分支的历史更清晰易读。这是git merge 做不到的。
　　&lt;/p&gt;
&lt;h3 id=&quot;rebase的黄金法则&quot;&gt;Rebase的黄金法则&lt;/h3&gt;
&lt;p&gt;当你理解rebase是什么的时候，最重要的就是什么时候 不能 用rebase。git rebase 的黄金法则便是，绝不要在公共的分支上使用它。&lt;/p&gt;

&lt;p&gt;比如说，如果你把master分支rebase到你的feature分支上会发生什么：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/b3d06635fdadff5863f94aa53b16bba69452f04f/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f6d657267696e672d76732d7265626173696e672f30352e737667&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这次rebase将master分支上的所有提交都移到了feature分支后面。问题是它只发生在你的代码仓库中，其他所有的开发者还在原来的master上工作。因为rebase引起了新的提交，Git会认为你的master分支和其他人的master已经分叉了。&lt;/p&gt;

&lt;p&gt;同步两个master分支的唯一办法是把它们merge到一起，导致一个额外的合并提交和两堆包含同样更改的提交。不用说，这会让人非常困惑。&lt;/p&gt;

&lt;p&gt;所以，在你运行git rebase 之前，一定要问问你自己“有没有别人正在这个分支上工作？”。如果答案是肯定的，那么把你的爪子放回去，重新找到一个无害的方式（如git revert）来提交你的更改。不然的话，你可以随心所欲地重写历史。&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;强制推送&quot;&gt;强制推送&lt;/h3&gt;
&lt;p&gt;如果你想把rebase之后的master分支推送到远程仓库，Git会阻止你这么做，因为两个分支包含冲突。但你可以传入&lt;code class=&quot;highlighter-rouge&quot;&gt;--force&lt;/code&gt; 标记来强行推送。就像下面一样：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;小心使用这个命令！！！&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git push --force
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;它会重写远程的master分支来匹配你仓库中rebase之后的master分支，对于团队中其他成员来说这看上去很诡异。所以，务必小心这个命令，只有当你知道你在做什么的时候再使用。&lt;/p&gt;

&lt;p&gt;仅有的几个强制推送的使用场景之一是，当你在想向远程仓库推送了一个私有分支之后，执行了一个本地的清理（比如说为了回滚）。这就像是在说“哦，其实我并不想推送之前那个feature分支的。用我现在的版本替换掉吧。”同样，你要注意没有别人正在这个feature分支上工作。&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;工作流&quot;&gt;工作流&lt;/h3&gt;
&lt;p&gt;rebase可以或多或少应用在你们团队的Git工作流中。在这一节中，我们来看看在feature分支开发的各个阶段中，rebase有哪些好处。&lt;/p&gt;

&lt;p&gt;第一步是在任何和&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt; 有关的工作流中为每一个feature专门创建一个分支。它会给你带来安全使用rebase的分支结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/4b8c7e7855643d46885f8df41b4dc4de11dc89a3/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f6d657267696e672d76732d7265626173696e672f30362e737667&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;本地清理&quot;&gt;本地清理&lt;/h3&gt;
&lt;p&gt;在你工作流中使用rebase最好的用法之一就是清理本地正在开发的分支。隔一段时间执行一次交互式rebase，你可以保证你feature分支中的每一个提交都是专注和有意义的。你在写代码时不用担心造成孤立的提交——因为你后面一定能修复。&lt;/p&gt;

&lt;p&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt; 的时候，你有两个基(base)可以选择：上游分支（比如master）或者你feature分支中早先的一个提交。我们在“交互式rebase”一节看到了第一种的例子。后一种在当你只需要修改最新几次提交时也很有用。比如说，下面的命令对最新的3次提交进行了交互式rebase：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git checkout feature
git rebase -i HEAD~3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过指定&lt;code class=&quot;highlighter-rouge&quot;&gt;HEAD~3&lt;/code&gt;作为新的基提交，你实际上没有移动分支——你只是将之后的3次提交重写了。注意它不会把上游分支的更改并入到feature分支中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/890e91bbd54876ff01865403164de70fe47b555b/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f6d657267696e672d76732d7265626173696e672f30372e737667&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果你想用这个方法重写整个feature分支，&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge-base&lt;/code&gt; 命令非常方便地找出feature分支开始分叉的基。下面这段命令返回基提交的ID，你可以接下来将它传给&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git merge-base feature master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;交互式rebase是在你工作流中引入git rebase 的的好办法，因为它只影响本地分支。其他开发者只能看到你已经完成的结果，那就是一个非常整洁、易于追踪的分支历史。&lt;/p&gt;

&lt;p&gt;但同样的，这只能用在私有分支上。如果你在同一个feature分支和其他开发者合作的话，这个分支是公开的，你不能重写这个历史。&lt;/p&gt;

&lt;p&gt;用带有交互式的rebase清理本地提交，这是无法用&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt; 命令代替的。&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;将上游分支上的更改并入feature分支&quot;&gt;将上游分支上的更改并入feature分支&lt;/h3&gt;
&lt;p&gt;在概览一节，我们看到了feature分支如何通过&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt; 或&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt; 来并入上游分支。merge是保留你完整历史的安全选择，rebase将你的feature分支移动到master分支后面，创建一个线性的历史。&lt;/p&gt;

&lt;p&gt;git rebase 的用法和本地清理非常类似（而且可以同时使用），但之间并入了master上的上游更改。&lt;/p&gt;

&lt;p&gt;记住，rebase到远程分支而不是master也是完全合法的。当你和另一个开发者在同一个feature分之上协作的时候，你会用到这个用法，将他们的更改并入你的项目。&lt;/p&gt;

&lt;p&gt;比如说，如果你和另一个开发者——John——往feature分支上添加了几个提交，在从John的仓库中fetch之后，你的仓库可能会像下面这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/6758dd2be664491c52dc4c246939f1ad5a14fba9/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f6d657267696e672d76732d7265626173696e672f30382e737667&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;就和并入master上的上游更改一样，你可以这样解决这个Fork：要么merge你的本地分支和John的分支，要不把你的本地分支rebase到John的分支后面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/c45e2609be5941aaedac397b08770be35d490db7/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f6d657267696e672d76732d7265626173696e672f30392e737667&quot; alt=&quot;此处输入图片的描述&quot; /&gt;
&lt;img src=&quot;https://camo.githubusercontent.com/c45e2609be5941aaedac397b08770be35d490db7/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f6d657267696e672d76732d7265626173696e672f30392e737667&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意，这里的rebase没有违反Rebase黄金法则，因为只有你的本地分支上的commit被移动了，之前的所有东西都没有变。这就像是在说“把我的改动加到John的后面去”。在大多数情况下，这比通过合并提交来同步远程分支更符合直觉。&lt;/p&gt;

&lt;p&gt;默认情况下，&lt;code class=&quot;highlighter-rouge&quot;&gt;git pull&lt;/code&gt; 命令会执行一次merge，但你可以传入&lt;code class=&quot;highlighter-rouge&quot;&gt;--rebase&lt;/code&gt; 来强制它通过rebase来整合远程分支。&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;通过pull-request进行审查&quot;&gt;通过Pull Request进行审查&lt;/h3&gt;
&lt;p&gt;如果你将pull request作为你代码审查过程中的一环，你需要避免在创建pull request之后使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt;。只要你发起了pull request，其他开发者能看到你的代码，也就是说这个分支变成了公共分支。重写历史会造成Git和你的同事难以找到这个分支接下来的任何提交。&lt;/p&gt;

&lt;p&gt;来自其他开发者的任何更改都应该用&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt; 而不是&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt; 来并入。&lt;/p&gt;

&lt;p&gt;因此，在提交pull request前用交互式的rebase进行代码清理通常是一个好的做法。&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;并入通过的功能分支&quot;&gt;并入通过的功能分支&lt;/h3&gt;

&lt;p&gt;如果某个功能被你们团队通过了，你可以选择将这个分支rebase到master分支之后，或是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt; 来将这个功能并入主代码库中。&lt;/p&gt;

&lt;p&gt;这和将上游改动并入feature分支很相似，但是你不可以在master分支重写提交，你最后需要用&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt; 来并入这个feature。但是，在merge之前执行一次rebase，你可以确保merge是一直向前的，最后生成的是一个完全线性的提交历史。这样你还可以加入pull request之后的提交。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/7a158568c55aa3b65bc58a648aabb17b36573eaa/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f6d657267696e672d76732d7265626173696e672f31302e737667&quot; alt=&quot;此处输入图片的描述&quot; /&gt;
&lt;img src=&quot;https://camo.githubusercontent.com/7a158568c55aa3b65bc58a648aabb17b36573eaa/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f6d657267696e672d76732d7265626173696e672f31302e737667&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果你还没有完全熟悉git rebase，你还可以在一个临时分支中执行&lt;code class=&quot;highlighter-rouge&quot;&gt;rebase&lt;/code&gt;。这样的话，如果你意外地弄乱了你feature分支的历史，你还可以查看原来的分支然后重试。&lt;/p&gt;

&lt;p&gt;比如说：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git checkout feature
git checkout -b temporary-branch
git rebase -i master
# [清理目录]
git checkout master
git merge temporary-branch
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;你使用rebase之前需要知道的知识点都在这了。如果你想要一个干净的、线性的提交历史，没有不必要的合并提交，你应该使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt; 而不是&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt; 来并入其他分支上的更改。&lt;/p&gt;

&lt;p&gt;另一方面，如果你想要保存项目完整的历史，并且避免重写公共分支上的commit， 你可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt;。两种选项都很好用，但至少你现在多了&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt;这个选择。
&lt;br /&gt; 
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Tue, 21 Feb 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/02/21/github-rebase-merge.markup/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/02/21/github-rebase-merge.markup/</guid>
        
        <category>笔记</category>
        
        <category>GitHub</category>
        
        
      </item>
    
      <item>
        <title>土耳其图集</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“Türk Marşı”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/WechatIMG5.jpeg&quot; alt=&quot;&quot; /&gt;
 &lt;small class=&quot;img-hint&quot;&gt;烤肉！烤肉！烤肉！—-伊斯坦布尔&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E5%95%8A%E5%95%8A%E5%95%8A.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;啊啊啊啊啊—-伊斯坦布尔&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E6%97%A0%E5%A3%B0.png&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;无声的表演—-伊斯坦布尔&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E4%BC%8A%E6%96%AF%E5%9D%A6%E5%B8%83%E5%B0%94%E6%AD%A5%E8%A1%8C%E8%A1%97.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;步行街—-伊斯坦布尔&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E4%BC%8A%E6%96%AF%E5%9D%A6%E5%B8%83%E5%B0%94%E5%A4%9C%E6%99%AF.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;夜—-伊斯坦布尔&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E6%B0%B4%E5%AE%AB.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;水宫—-伊斯坦布尔&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E6%B0%B4%E5%AE%AB2.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;水宫—-伊斯坦布尔&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E6%B0%B4%E5%AE%AB3.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;水宫—-伊斯坦布尔&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E4%BC%8A%E5%85%B9%E5%AF%86%E5%B0%94.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;盘旋—-伊兹密尔&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E4%BB%A5%E4%BD%9B%E6%89%80.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;以佛所—-伊兹密尔&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E9%BB%91%E6%B5%B7%E6%B5%B7%E5%B3%A11.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;黑海海峡&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E9%BB%91%E6%B5%B7%E6%B5%B7%E5%B3%A12.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;黑海海峡&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E9%87%91%E8%A7%92%E6%B9%BE1.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;金角湾&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E9%87%91%E8%A7%92%E6%B9%BE2.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;金角湾&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E9%87%91%E8%A7%92%E6%B9%BE3.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;金角湾&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E9%87%91%E8%A7%92%E6%B9%BE4.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;金角湾&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E6%A3%89%E8%8A%B1%E5%A0%A11.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;棉花堡&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E6%A3%89%E8%8A%B1%E5%A0%A1.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;棉花堡的…&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E5%8D%A1%E5%B8%95%E5%A4%9A%E5%A5%87%E4%BA%9A.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;卡帕多奇亚&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E5%8D%A1%E5%B8%95%E5%A4%9A%E5%A5%87%E4%BA%9A%E5%A5%A5%E7%89%B9%E6%9B%BC.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;卡帕多奇亚&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E5%8C%85%E5%AD%90%E8%80%81%E7%A6%8F%E7%89%B9.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;包子-82年老福特&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E5%8C%85%E5%AD%90%E8%80%81%E7%A6%8F%E7%89%B92.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;包子-82年老福特&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E9%BE%9F%E9%BE%9F%E8%80%81%E7%A6%8F%E7%89%B9.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;龟龟-82年老福特&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E5%AE%89%E5%A1%94%E5%88%A9%E4%BA%9A1.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;爱琴海-安塔利亚&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E5%AE%89%E5%A1%94%E5%88%A9%E4%BA%9A2.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;安塔利亚&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E5%AE%89%E5%A1%94%E5%88%A9%E4%BA%9A3.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;龟龟—-安塔利亚&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E6%B3%A1%E8%84%9A1.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;泡脚&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E6%B3%A1%E8%84%9A2.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;继续泡脚&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E7%BA%A2%E8%8C%B6.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;土耳其红茶&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E5%85%89%E8%8A%B1.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;日落&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/%E5%85%89%E6%9D%9F%E5%8C%85%E5%AD%90.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;最后摆拍两下&lt;/small&gt;
&lt;img src=&quot;http://image.lawootrip.com/%E5%8C%85%E5%AD%90%E5%A2%99%E8%A7%92.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;最后摆拍一下&lt;/small&gt;
&lt;img src=&quot;http://image.lawootrip.com/%E8%80%81%E5%A4%B4.JPG&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;变身&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt; 
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Sun, 19 Feb 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/02/19/turkey.markup/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/02/19/turkey.markup/</guid>
        
        <category>图集</category>
        
        <category>旅行</category>
        
        
      </item>
    
      <item>
        <title>克什米尔之殇</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“اپ سے مل کر خوشی ہوی ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;缘起&quot;&gt;缘起&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://p1.bqimg.com/567571/f6b44c6abca1eb36.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　这里的房屋大多是木质结构，尖顶，条件好的人家还带有一个进行穆斯林祈祷仪式的砖砌塔楼。Ghulam家算条件好的，但家中家具很少，客厅几乎没有家具，只有一张五米见方精致的手工地毯铺满房间，他们平常就在这里看书看报、吃饭喝茶，我们也都席地坐在地毯上，面前摆着克什米尔藏红花茶，醇香扑鼻。&lt;/p&gt;

&lt;p&gt;　　克什米尔传统大袍套在老人的身上，两只袖子总是空空的耷拉着，隐藏在袍子里的手握着肚子前的特色火炉——藤蔓编制而成的篮子，盛着些许燃着的炭灰用来取暖。
老人吸了一口水烟，往事立马随着烟气将我们笼罩。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://p1.bqimg.com/567571/cac33d40135de4f6.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;http://i1.piimg.com/567571/5fdacaed4f06ab67.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;过去即他乡&quot;&gt;过去即他乡&lt;/h3&gt;

&lt;p&gt;　　1965年一颗炮弹落到他家的祈祷塔楼上，门窗都被炸飞了。这被认为是真主不满的表示，他们延长了每天祈祷的时间。几天后，他的母亲去邻居家借纺轮，在回来的路上被流弹击中后脑，于是他在剩下的岁月里只能依靠照片来怀念母亲。没过多久，印巴实现第二次停火，克什米尔迎来了短暂的和平期，印度兵的吉普车和坦克从南边开进了克什米尔，七岁的Ghulam对他们并无厌恶，成年人的恐惧在孩子们看来无法理解，他甚至有些庆幸，因为印度军方禁止他们每天五次的礼拜，这给了他更多玩耍的时间，但“好景”不长，十岁开始他就被送进了老师家学习制作披肩。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://p1.bpimg.com/567571/f8c0edb5bea2054e.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　在那个年代里，每个人的睡眠时间都很少，每天要劳动，要打扫院子，要种地，学习披肩技艺和印度语，吃的是万变不离其宗的菜汤米饭，冬天异常寒冷，屋子里没有取暖的设备，在零下十几度的房间学习织作，一坐就是十个小时，不能燃炭炉，因为那样会烤坏羊绒，只能靠手指不停的穿梭织作，一天下来，总是要花一个多小时让自己已经被冻紫的脚恢复知觉。&lt;/p&gt;

&lt;p&gt;　　问他为什么在那种时候还要学习做披肩，长达数十年的战乱把这里变成贸易和旅游的禁地，披肩又能卖给谁呢？&lt;/p&gt;

&lt;p&gt;　　老人说克什米尔人做披肩不是为了赚钱，这是很多很多年前波斯居鲁士大帝的带来的文明，我们要传承下去，这是我们的命。&lt;/p&gt;

&lt;p&gt;　　老人说我们跟谁都不争，双手烤着生命之火取暖；火萎了，我就准备走了，但披肩的手艺还有我的儿子传下去。&lt;/p&gt;

&lt;p&gt;　　57岁的Ghulam看起来像古稀之年的老人，满脸沟壑却的他似乎已不太认识几十年前那个在夹缝中长大的自己。不过对于那个十几岁的少年来说，也许并不觉得苦。对于一辈子只做一件事的人来说，还有什么苦难可以打败他呢？&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;方生方死&quot;&gt;方生方死&lt;/h3&gt;
&lt;p&gt;　　这块美丽土地曾享受过长时间的和平，但早在印度、巴基斯坦为之大肆操戈前，它已受到各类争斗的蹂躏。&lt;/p&gt;

&lt;p&gt;　　早在公元前300年波斯人就武力打通了外界到克什米尔的通路，同时带来披肩的原始工艺，公元326年亚历山大大帝沿着波斯人的轨迹来到克什米尔，怀着解救被缚普罗米修斯之心的亚历山大终究没能杀死啃噬其肝脏的秃鹰，饱受痢疾之苦的马其顿人在征服了克什米尔后回到巴比伦不久就病逝了。
　　接下来到达克什米尔的是自东土大唐而来的唐僧，唐僧在古称迦湿弥罗的克什米尔学习三年，孙悟空显然没对师傅的高反帮上什么忙，法师用了一年时间才适应高海拔地区的环境。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“此北二千余里，经途艰阻，寒风飞雪，至秣逻娑国。”——《大唐西域记》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　此后的一千年只能用混战概括。8世纪开始阿拉伯势力进入克什米尔，克什米尔开始穆斯林化，17世纪因为佛教天主教之争，克什米尔的拉达克人和现今西藏阿里扎达县的古格人发生战争，最终古格王朝一夜之间被屠城，古格宏伟的宫殿和华美的壁画，直到20世纪才被意大利人杜奇教授重新发现。
古格王朝的惨败传到北京，康熙震怒，增派2500蒙古骑兵支援吐蕃，又在克什米尔的土地上同拉达克背后的莫卧儿王朝鏖战连年。&lt;/p&gt;

&lt;p&gt;　　尚未得到片刻喘气，1829年英国人在克什米尔宣布殖民，接下来的近代史更是被接连不断的暴力和恐怖事件充斥，三次印巴战争受伤最深的总是克什米尔，就在我写下这篇文章的时候克什米尔的朋友告诉我他们那里又发生了一次大规模罢工，人们向印度军警投掷石块，被暴力镇压…
&lt;img src=&quot;http://i1.piimg.com/567571/d31f4a653ff1efe7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;何去何从&quot;&gt;何去何从？&lt;/h3&gt;

&lt;p&gt;　　一千个克什米尔人有一千个答案，年轻人如Asif说我们只是要和平，上了年纪的人如Ghulam说我只希望手艺传下去。但对于地处大国文明交汇地带的克什米尔来说，和平很可能是永远的奢望。正如法国学者鲁保罗所说，自波斯以降，克什米尔人习惯了一个帝国的存在。&lt;/p&gt;

&lt;p&gt;　　聊到这里，城里每日五次响彻全城的祷告声准时响起，他们放下手中的事情全身心的投入礼拜的状态。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ghulam给我讲过《古兰经》关于末日的描述：“或如重重黑暗﹐笼罩着汪洋大海﹐波涛澎湃﹐上有黑云﹐黑暗重重迭迭﹐观者伸出手来时﹐几乎不见五指。 真主没有给谁光明﹐谁就绝无光明。”(古兰经﹐24﹕40)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;后记&quot;&gt;后记&lt;/h3&gt;

&lt;p&gt;　　好像看一部规模宏大的电影，居鲁士时代的坟墓、丝绸之路的商队、唐朝的高僧、阿拉伯人的征伐、印巴的战俘营，被污染但依然壮丽的风光。在影片最后，男主人公站在克什米尔最高的山峰上，影片没有告诉我们他是否能够活着下山。&lt;/p&gt;

&lt;p&gt;　　住在地球小屋里的人们，烧漆黑的松枝照明，从前的一场场雪，炭火之光和燃烧的松枝——夜晚说故事，无需太亮。
&lt;img src=&quot;http://p1.bqimg.com/567571/e18f0ca8b67baf1e.png&quot; alt=&quot;&quot; /&gt;
&lt;br /&gt; 
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Wed, 15 Feb 2017 19:05:00 +0000</pubDate>
        <link>http://localhost:4000/2017/02/15/Kashmir-tear/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/02/15/Kashmir-tear/</guid>
        
        <category>旅行</category>
        
        
      </item>
    
      <item>
        <title>Welcome to LawooTrip</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“Yeah It’s on. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;历时大半个月，断断续续的，终于把个人博客站搭建起来。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;目录&quot;&gt;目录&lt;/h1&gt;

&lt;h3 id=&quot;1创建属于你的gitpages&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1.创建属于你的GitPages&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&quot;2配置和使用你的gitpages&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2.配置和使用你的GitPages&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&quot;3使用jekyll搭建博客系统&quot;&gt;&lt;a href=&quot;#3&quot;&gt;3.使用Jekyll搭建博客系统&lt;/a&gt;&lt;/h3&gt;

&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;1创建属于你的gitpages-1&quot;&gt;1.创建属于你的GitPages&lt;/h2&gt;

&lt;p&gt;既然是在GitHub上搭建博客，当然要先去人家平台上&lt;a href=&quot;https://github.com&quot;&gt;注册&lt;/a&gt;自己的账号。&lt;/p&gt;

&lt;p&gt;注册流程很简单，基本就是根据官方引导往下走就可以了。&lt;/p&gt;

&lt;p&gt;注册号账号后，创建一个属于自己的repository，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;注意：repository名称的格式必须是：&quot;ID.github.io&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-02-15-01&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;&lt;a href=&quot;http://www.jianshu.com/p/0ea178531ac8&quot;&gt;细节流程参考这个教程&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;推荐勾选自带README的选项，免去日后还得添加README的麻烦。&lt;/p&gt;

&lt;p id=&quot;2&quot;&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;2配置和使用你的gitpages-1&quot;&gt;2.配置和使用你的GitPages&lt;/h2&gt;

&lt;h5 id=&quot;配置和使用github&quot;&gt;配置和使用GitHub&lt;/h5&gt;

&lt;p&gt;本块教程主要参考wayne23的&lt;a href=&quot;http://www.cnblogs.com/wayne23/p/4313630.html&quot;&gt;Github的基本配置与使用&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&quot;配置ssh-keys&quot;&gt;配置SSH keys&lt;/h5&gt;
&lt;p&gt;首先我们需要检查你电脑上现有的ssh key：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ~/. ssh //检查本机的ssh密钥
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果提示：No such file or directory 说明你是第一次使用git。&lt;/p&gt;

&lt;h5 id=&quot;生成新的ssh-keys&quot;&gt;生成新的SSH keys&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh-keygen -t rsa -C &quot;你用来注册的邮件地址@xxx.com&quot;
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):
&amp;lt;回车就好&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;注意: 此处的「-C」的是大写的「C」&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后系统会要你输入密码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Enter passphrase (empty for no passphrase):&amp;lt;输入加密串&amp;gt;
Enter same passphrase again:&amp;lt;再次输入加密串&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;注意：输入密码的时候没有*字样的，你直接输入就可以了。&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;添加ssh-key到github&quot;&gt;添加SSH Key到GitHub&lt;/h5&gt;
&lt;p&gt;在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。&lt;/p&gt;

&lt;p&gt;MAC下路径&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/Users/lizhimin/.ssh/id_rsa.pub.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;WINDOWS下路径&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\Documents and Settings\Administrator.ssh\id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此文件里面内容为刚才生成的密钥。如果看不到这个文件，你需要设置显示&lt;a href=&quot;http://jingyan.baidu.com/article/d2b1d1027c6dc65c7e37d435.html&quot;&gt;隐藏文件&lt;/a&gt;。准确的复制这个文件的内容，才能保证设置的成功。&lt;/p&gt;

&lt;p&gt;登陆github系统。点击右上角的 Account Settings—&amp;gt;SSH Public keys —&amp;gt; add another public keys&lt;/p&gt;

&lt;p&gt;把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了&lt;/p&gt;

&lt;h5 id=&quot;测试&quot;&gt;测试&lt;/h5&gt;
&lt;p&gt;可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh -T git@github.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果是下面的反馈：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The authenticity of host 'github.com (207.97.227.239)' can't be established.
RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
Are you sure you want to continue connecting (yes/no)?
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不要紧张，输入yes就好，然后会看到：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hi 你的名字! You've successfully authenticated, but GitHub does not provide shell access.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;设置用户信息&quot;&gt;设置用户信息&lt;/h5&gt;
&lt;p&gt;现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。&lt;/p&gt;

&lt;p&gt;Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git config --global user.name &quot;cnfeat&quot;//用户名
git config --global user.email  &quot;cnfeat@gmail.com&quot;//填写自己的邮箱
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;ssh-key配置成功&quot;&gt;SSH Key配置成功&lt;/h5&gt;
&lt;p&gt;本机已成功连接到github。&lt;/p&gt;

&lt;p&gt;若有问题，请&lt;a href=&quot;#0&quot;&gt;重新设置&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;常见错误请参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://help.github.com/articles/connecting-to-github-with-ssh/&quot;&gt;GitHub Help - Generating SSH Keys&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://help.github.com/articles/error-permission-denied-publickey/&quot;&gt;GitHub Help - Error Permission denied (publickey)&lt;/a&gt;&lt;/p&gt;

&lt;p id=&quot;3&quot;&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;3使用jekyll搭建博客系统-1&quot;&gt;3.使用Jekyll搭建博客系统&lt;/h2&gt;

&lt;p&gt;这里仅以MAC下的OSX系统为例,Jekyll是用ruby开发的，所以安装Jekyll之前需要执行下面的命令安装一些依赖。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install ruby ruby1.9.1-dev nodejs

sudo gem install jekyll
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;至此，你的MAC电脑上已经安装并配置了搭建博客需要的所有的依赖环境。&lt;/p&gt;

&lt;p&gt;去&lt;a href=&quot;http://jekyllthemes.org&quot;&gt;jekyllthemes&lt;/a&gt; 或者&lt;a href=&quot;https://www.zhihu.com/question/20223939&quot;&gt;知乎&lt;/a&gt;挑选一个Jekyll主题，并按照主题的README进行CLONE安装即可。&lt;/p&gt;

&lt;p&gt;以本站为例，我选用了&lt;a href=&quot;https://github.com/Huxpro&quot;&gt;Huang Xuan&lt;/a&gt;原创的&lt;a href=&quot;https://github.com/Huxpro/huxpro.github.io&quot;&gt;Jekyll主题&lt;/a&gt;，主题文档里有中英文的README，十分清晰可靠，强烈推荐。&lt;/p&gt;

&lt;p&gt;其他常见问题和基础知识可参见&lt;a href=&quot;http://jekyll.com.cn&quot;&gt;Jekyll官网&lt;/a&gt; ，有中文文档，也十分清晰可靠，强烈推荐。&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;后记&quot;&gt;后记&lt;/h1&gt;

&lt;p&gt;配置的过程中遇到了不少坑，毕竟不是码农，git从零入手，遇到了merge、fetch各种branch傻傻分不清楚。几度几乎放弃，缺总是被一丝丝的曙光召唤着继续坑自己。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;此处强烈推荐&lt;a href=&quot;https://github.com/geeeeeeeeek&quot;&gt;geeeeeeeeek-童仲毅&lt;/a&gt;关于GitHub的&lt;a href=&quot;https://github.com/geeeeeeeeek/git-recipes/wiki&quot;&gt;“Git 中文教程”&lt;/a&gt;，悉心细读，获益匪浅。**&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;还有本地调试环境需要 &lt;code class=&quot;highlighter-rouge&quot;&gt;gem install jekyll&lt;/code&gt;，结果 rubygem 的源居然被墙了……后来手动改成了我大淘宝的镜像源才成功&lt;/p&gt;

&lt;p&gt;Theme 的 CSS 是基于 Bootstrap 定制的，看得不爽的地方直接在 Less 里改就好了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;回顾这个博客的诞生，纯粹是出于个人兴趣。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我不是程序猿，也不是Github的重度用户，只是在找一些产品源码的时候偶遇了GitPages，前几次的碰壁愈发激起了我要攻克他的信念。&lt;/p&gt;

&lt;p&gt;今日终于&lt;/p&gt;

&lt;p&gt;跑起来了&lt;/p&gt;

&lt;p&gt;—— 龟龟 后记于 2017.02
&lt;br /&gt; 
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; 
&lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;
&lt;/td&gt;
&lt;/table&gt;
</description>
        <pubDate>Wed, 15 Feb 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/02/15/hello-2017.markup/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/02/15/hello-2017.markup/</guid>
        
        <category>GitHub</category>
        
        
      </item>
    
  </channel>
</rss>
