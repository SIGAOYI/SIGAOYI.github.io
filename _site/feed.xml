<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LawooTrip</title>
    <description>龟龟的个人博客-乐物旅行</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 06 Feb 2018 11:40:23 +0000</pubDate>
    <lastBuildDate>Tue, 06 Feb 2018 11:40:23 +0000</lastBuildDate>
    <generator>Jekyll v3.6.2</generator>
    
      <item>
        <title>Ubuntu 常用命令整理</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Vue.js 放弃中…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;目录&quot;&gt;&lt;strong&gt;目录:&lt;/strong&gt;&lt;/h2&gt;

&lt;h2 id=&quot;一用户操作&quot;&gt;&lt;a href=&quot;#0&quot;&gt;一、用户操作&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&quot;二文件操作&quot;&gt;&lt;a href=&quot;#1&quot;&gt;二、文件操作&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&quot;三系统操作&quot;&gt;&lt;a href=&quot;#2&quot;&gt;三、系统操作&lt;/a&gt;&lt;/h2&gt;

&lt;p id=&quot;0&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;一用户操作-1&quot;&gt;一、用户操作&lt;/h2&gt;

&lt;p&gt;在root用户下，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;who&lt;/code&gt;查看目前有哪些用户登录了服务器；&lt;/li&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;pkill -kill -t pts/1&lt;/code&gt;（数字1就是用户的&lt;a href=&quot;https://en.wikipedia.org/wiki/Tty_(unix)&quot;&gt;TTY&lt;/a&gt;）强制退出对应用户的登陆；&lt;/li&gt;
  &lt;li&gt;增加用户：&lt;code class=&quot;highlighter-rouge&quot;&gt;useradd test&lt;/code&gt;；为新增用户添加密码：&lt;code class=&quot;highlighter-rouge&quot;&gt;passwd test&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;删除用户：&lt;code class=&quot;highlighter-rouge&quot;&gt;userdel test&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;用户登陆记录：&lt;code class=&quot;highlighter-rouge&quot;&gt;last&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;用户登陆失败记录：&lt;code class=&quot;highlighter-rouge&quot;&gt;lastb&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;查看系统下所有用户：&lt;code class=&quot;highlighter-rouge&quot;&gt;cat /etc/passwd |awk -F \: '{print $1}'&lt;/code&gt;;&lt;/li&gt;
&lt;/ol&gt;

&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;二文件操作-1&quot;&gt;二、文件操作&lt;/h2&gt;

&lt;p id=&quot;2&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;三系统操作-1&quot;&gt;三、系统操作&lt;/h2&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Tue, 06 Feb 2018 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2018/02/06/Linux-orders-note/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/02/06/Linux-orders-note/</guid>
        
        <category>笔记</category>
        
        <category>Linux</category>
        
        <category>Ubuntu</category>
        
        
      </item>
    
      <item>
        <title>用DiscuzX3.2建站原来这么简单！</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Vue.js 放弃中…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;目录&quot;&gt;&lt;strong&gt;目录:&lt;/strong&gt;&lt;/h2&gt;

&lt;h2 id=&quot;一简述&quot;&gt;&lt;a href=&quot;#0&quot;&gt;一、简述&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&quot;二安装配置&quot;&gt;&lt;a href=&quot;#1&quot;&gt;二、安装配置&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&quot;三配置文件&quot;&gt;&lt;a href=&quot;#2&quot;&gt;三、配置文件&lt;/a&gt;&lt;/h2&gt;

&lt;p id=&quot;0&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;一简述-1&quot;&gt;一、简述&lt;/h2&gt;

&lt;p&gt;Discuz是主流的社区论坛管理方案，小米论坛、威锋论坛等国内知名论坛均使用的是Discuz的框架进行二次开发和内容管理，这里不多赘述。&lt;/p&gt;

&lt;p&gt;有一件轶事可以分享一下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Discuz的第一位商业用户是“香港警察俱乐部”（Discuz亦为其量身订造了特有的程序），当时候Discuz的作者戴志康还在念大学，在沈阳的大学宿舍居住，香港警察俱乐部的网主每次打电话找他都要经过大学的总机转接他来听电话，那时候他连手机都还没有，可是今天他已经成为百万美元注册的集团董事了，香港警察俱乐部亦顺理成章成了他第一个商业客户，后来他的同事还跟香港警察俱乐部的网主说，正因为当初香港警察俱乐部向他购买了他写的这款程序，所以坚定了他们后来的创业道路，他笑着说：“你（香港警察俱乐部的网主）的一个不经意的决定，改变了另一个人的命运。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;二安装配置-1&quot;&gt;二、安装配置&lt;/h2&gt;

&lt;p&gt;首先去&lt;a href=&quot;http://www.discuz.net/forum-10-1.html&quot;&gt;官网&lt;/a&gt;下载程序安装包，我选择的是X3.2版本。&lt;/p&gt;

&lt;p&gt;解压后部署到自己的服务器上、&lt;/p&gt;

&lt;p&gt;关于如何部署服务器有一万种方法，这里我用的是&lt;a href=&quot;https://blog.izgq.net/archives/763/&quot;&gt;Ubuntu+Nginx+Mysql&lt;/a&gt;的方案。&lt;/p&gt;

&lt;p&gt;完成服务器的部署后，就是选择一个域名解析并指向服务器。&lt;/p&gt;

&lt;p&gt;这里以&lt;a href=&quot;http://www.freedivefamily.com&quot;&gt;http://www.freedivefamily.com&lt;/a&gt;为例。&lt;/p&gt;

&lt;p&gt;接下来开始在本地浏览器中安装 Discuz! X3，在浏览器中运行： http://www.freedivefamily.com/bbs/install/ 开始全新安装。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.discuz.net/data/attachment/forum/201304/28/133039m7f83jye3fsqgf0q.gif.thumb.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;阅读授权协议后点击“我同意”，系统会自动检查环境及文件目录权限，这里文件读写状态出现异常的同学请自行谷歌解决，因为我一次通关。&lt;/p&gt;

&lt;p&gt;检测成功，点击“下一步”，即进入检测服务器环境以及设置 UCenter 界面，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.discuz.net/data/attachment/forum/201304/28/133039wn8cihhf1fk8chnk.gif.thumb.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击“下一步”，进入安装数据库的界面，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.discuz.net/data/attachment/forum/201304/28/133040b7b3g7z7b7urg2bp.gif.thumb.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;填写好 Discuz! X 数据库信息及管理员信息。
点击“下一步”，系统会自动安装数据库直至完毕。&lt;/p&gt;

&lt;p&gt;安装成功后，就会自动跳转到Discuz的欢迎界面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.discuz.net/data/attachment/forum/201304/28/133041r7g9ux7geq557rx7.gif.thumb.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里，建议直接开通云平台，因为后期通过后台再开通会遇到很多问题，亲测采坑。&lt;/p&gt;

&lt;p&gt;至此，Discuz! X3.2 已经成功地安装完毕!&lt;/p&gt;

&lt;p id=&quot;2&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;三配置文件-1&quot;&gt;三、配置文件&lt;/h2&gt;

&lt;p&gt;Discuz！安装成功后，后台配置都很简单，难度就在于站内优化和SEO相关设置了。&lt;/p&gt;

&lt;p&gt;简单总结就是：生命不息，优化不止……&lt;/p&gt;

&lt;p&gt;除此之外，特别介绍一下几个基本的配置文件&lt;/p&gt;

&lt;p&gt;配置文件：&lt;/p&gt;

&lt;p&gt;config下config_global.php，config_ucenter.php，uc_server\data下的config.inc.php&lt;/p&gt;

&lt;p&gt;主要说配置文件config下config_ucenter.php和uc_server\data下的config.inc.php&lt;/p&gt;

&lt;p&gt;配置文件config下config_ucenter.php对应后台–站长–ucenter设置&lt;/p&gt;

&lt;p&gt;UCenter 应用 ID:1 　　　define(‘UC_APPID’, ‘1’);&lt;/p&gt;

&lt;p&gt;UCenter 通信密钥:B0Z9k2pbX7j5J1H9zfgdVeDaY8I2I2zfUc00C1J4B4ga9fNdOed7X7p3S5ubD2ba&lt;/p&gt;

&lt;p&gt;define(‘UC_KEY’, ‘B0Z9k2pbX7j5J1H9zfgdVeDaY8I2I2zfUc00C1J4B4ga9fNdOed7X7p3S5ubD2ba’);&lt;/p&gt;

&lt;p&gt;UCenter 访问地址:http://localhost/uc_server 　　define(‘UC_API’, ‘http://localhost/uc_server’);&lt;/p&gt;

&lt;p&gt;UCenter IP 地址:127.0.0.1 　　define(‘UC_IP’, ‘127.0.0.1’);&lt;/p&gt;

&lt;p&gt;UCenter 连接方式:数据库方式 　　define(‘UC_CONNECT’, ‘mysql’);&lt;/p&gt;

&lt;p&gt;UCenter 数据库服务器:localhost 　　define(‘UC_DBHOST’, ‘localhost’);&lt;/p&gt;

&lt;p&gt;UCenter 数据库用户名:root 　　define(‘UC_DBUSER’, ‘root’);&lt;/p&gt;

&lt;p&gt;UCenter 数据库密码:***　　 define(‘UC_DBPW’, ‘123’);&lt;/p&gt;

&lt;p&gt;UCenter 数据库名:x2 　　define(‘UC_DBNAME’, ‘x2’);&lt;/p&gt;

&lt;p&gt;UCenter 表前缀:pre_ucenter_ 　　define(‘UC_DBTABLEPRE’, ‘&lt;code class=&quot;highlighter-rouge&quot;&gt;x2&lt;/code&gt;.pre_ucenter_’);&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Fri, 22 Dec 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/12/22/Discuzu-Build-Config/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/12/22/Discuzu-Build-Config/</guid>
        
        <category>笔记</category>
        
        <category>Discuz</category>
        
        <category>论坛</category>
        
        <category>建站</category>
        
        <category>站长</category>
        
        
      </item>
    
      <item>
        <title>Ubuntu搭建Shadowsocks原来这么简单！！</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Vue.js 放弃中…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;目录:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#0&quot;&gt;一、简述&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#1&quot;&gt;二、基本环境&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#2&quot;&gt;三、配置文件&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#3&quot;&gt;四、配置自动运行&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#4&quot;&gt;五、常用命令&lt;/a&gt;&lt;/p&gt;

&lt;p id=&quot;0&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;一简述&quot;&gt;一、简述&lt;/h2&gt;

&lt;p&gt;本教程旨在提供简明的Ubuntu 16.04下安装服务器端Shadowsocks。不同于Ubuntu 16.04之前的教程，本文抛弃initd，转而使用Ubuntu 16.04支持的Systemd管理Shadowsocks的启动与停止，显得更为便捷。优化部分包括BBR、TCP Fast Open以及吞吐量优化。&lt;/p&gt;

&lt;p&gt;本教程仅适用于Ubuntu 16.04及之后的版本，基于Python 3，支持IPv6。&lt;/p&gt;

&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;二基本环境&quot;&gt;二、基本环境&lt;/h2&gt;

&lt;p&gt;本教程使用Python 3为载体，因Python 3对应的包管理器&lt;code class=&quot;highlighter-rouge&quot;&gt;pip3&lt;/code&gt;并未预装，首先安装&lt;code class=&quot;highlighter-rouge&quot;&gt;pip3&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 获取root权限
sudo -s

# 更新apt-get
apt-get update

# 安装python包管理工具
apt-get install python-setuptools
sudo apt install python3-pip
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;因Shadowsocks作者不再维护pip中的Shadowsocks（定格在了2.8.2），我们使用下面的命令来安装最新版的Shadowsocks：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip3 install https://github.com/shadowsocks/shadowsocks/archive/master.zip
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装完成后可以使用下面这个命令查看Shadowsocks版本：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo ssserver --version
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;目前会显示“Shadowsocks 3.0.0”。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;注意！&lt;/strong&gt;如果报错&lt;code class=&quot;highlighter-rouge&quot;&gt;unsupported locale setting&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;只需要转化一下语言配置即可：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export LC_ALL=C
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p id=&quot;2&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;三配置文件&quot;&gt;三、配置文件&lt;/h2&gt;

&lt;p&gt;创建Shadowsocks配置文件所在文件夹：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo mkdir /etc/shadowsocks
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后创建配置文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo nano /etc/shadowsocks/config.json
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;复制粘贴如下内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;server&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;your_server_ip&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//注意：这里指本地IP或云服务器内网IP;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;server_port&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8388&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;local_address&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;127.0.0.1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;local_port&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1080&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;password&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;mypassword&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//注意修改密码“password”;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;timeout&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;method&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;aes-256-cfb&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;fast_open&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后按Ctrl + O保存文件，Ctrl + X退出。&lt;/p&gt;

&lt;p&gt;测试下Shadowsocks能不能正常工作了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssserver -c /etc/shadowsocks/config.json
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在Shadowsocks客户端添加服务器，如果你使用的是我提供的那个配置文件的话，地址填写你的IPv4地址或IPv6地址，端口号为8388，加密方法为aes-256-cfb，密码为你设置的密码。然后设置客户端使用全局模式，浏览器登录Google试试应该能直接打开了。&lt;/p&gt;

&lt;p&gt;这时浏览器登录http://ip138.com/就会显示Shadowsocks服务器的IP啦！&lt;/p&gt;

&lt;p&gt;测试完毕，按Ctrl + C关闭Shadowsocks。&lt;/p&gt;

&lt;p id=&quot;3&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;四配置自动运行&quot;&gt;四、配置自动运行&lt;/h2&gt;

&lt;p&gt;新建Shadowsocks管理文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo nano /etc/systemd/system/shadowsocks-server.service
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;复制粘贴：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[Unit]
Description=Shadowsocks Server
After=network.target

[Service]
ExecStart=/usr/local/bin/ssserver -c /etc/shadowsocks/config.json
Restart=on-abort

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Ctrl + O保存文件，Ctrl + X退出。&lt;/p&gt;

&lt;p&gt;启动Shadowsocks：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl start shadowsocks-server
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;设置开机启动Shadowsocks：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl enable shadowsocks-server
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;至此，Shadowsock服务器端的基本配置已经全部完成了！&lt;/p&gt;

&lt;p id=&quot;4&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;常用命令&quot;&gt;&lt;strong&gt;常用命令：&lt;/strong&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;systemctl start shadowsocks //启动SS
systemctl enable shadowsocks //停止SS
systemctl status shadowsocks//查看SS状态
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;厉害的一个命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tcpdump -i any -nn 'port 8338' -vv -X //监听端口数据
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;-i interface，网卡的名称，后面可以跟具体的网卡名称(ifconfig后者tcpdump -D)获取，笔者的电脑上看到any，似乎是指所有的网卡&lt;/p&gt;

  &lt;p&gt;-nn 监听host或者port名，这个网上解释有一大堆，什么src host，dist host  ，比如我要抓，ip地址为127.0.0.1，端口为9002的服务器的数据包，那么命令可以写成-nn ‘src host 127.0.0.1 and &amp;gt;port 9002’.不过实际来讲，端口肯定是被一个ip地址使用的，而且对于我来说，服务器抓包比较有意义，所以，其实有没有ip地址，似乎显得不那么重要，有端口就可以。&lt;/p&gt;

  &lt;p&gt;-vv 详细信息&lt;/p&gt;

  &lt;p&gt;-X 以16进制的格式输出&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;附加题优化吞吐量&quot;&gt;附加题、优化吞吐量&lt;/h2&gt;

&lt;p&gt;新建配置文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo nano /etc/sysctl.d/local.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;复制粘贴：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# max open files
fs.file-max = 51200
# max read buffer
net.core.rmem_max = 67108864
# max write buffer
net.core.wmem_max = 67108864
# default read buffer
net.core.rmem_default = 65536
# default write buffer
net.core.wmem_default = 65536
# max processor input queue
net.core.netdev_max_backlog = 4096
# max backlog
net.core.somaxconn = 4096

# resist SYN flood attacks
net.ipv4.tcp_syncookies = 1
# reuse timewait sockets when safe
net.ipv4.tcp_tw_reuse = 1
# turn off fast timewait sockets recycling
net.ipv4.tcp_tw_recycle = 0
# short FIN timeout
net.ipv4.tcp_fin_timeout = 30
# short keepalive time
net.ipv4.tcp_keepalive_time = 1200
# outbound port range
net.ipv4.ip_local_port_range = 10000 65000
# max SYN backlog
net.ipv4.tcp_max_syn_backlog = 4096
# max timewait sockets held by system simultaneously
net.ipv4.tcp_max_tw_buckets = 5000
# turn on TCP Fast Open on both client and server side
net.ipv4.tcp_fastopen = 3
# TCP receive buffer
net.ipv4.tcp_rmem = 4096 87380 67108864
# TCP write buffer
net.ipv4.tcp_wmem = 4096 65536 67108864
# turn on path MTU discovery
net.ipv4.tcp_mtu_probing = 1

net.ipv4.tcp_congestion_control = bbr
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sysctl --system
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;编辑之前的shadowsocks-server.service文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo nano /etc/systemd/system/shadowsocks-server.service
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecStart&lt;/code&gt;前插入一行，内容为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ExecStartPre=/bin/sh -c 'ulimit -n 51200'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;即修改后的shadowsocks-server.service内容为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[Unit]
Description=Shadowsocks Server
After=network.target

[Service]
ExecStartPre=/bin/sh -c 'ulimit -n 51200'
ExecStart=/usr/local/bin/ssserver -c /etc/shadowsocks/config.json
Restart=on-abort

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Ctrl + O保存文件，Ctrl + X退出。&lt;/p&gt;

&lt;p&gt;重载shadowsocks-server.service：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl daemon-reload
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重启Shadowsocks：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl restart shadowsocks-server
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;TCP Fast Open可以降低Shadowsocks服务器和客户端的延迟。实际上在上一步已经开启了TCP Fast Open，现在只需要在Shadowsocks配置中启用TCP Fast Open。&lt;/p&gt;

&lt;p&gt;编辑config.json：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo nano /etc/shadowsocks/config.json
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将fast_open的值由false修改为true。Ctrl + O保存文件，Ctrl + X退出。&lt;/p&gt;

&lt;p&gt;重启Shadowsocks：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl restart shadowsocks-server

注意：TCP Fast Open同时需要客户端的支持，即客户端Linux内核版本为3.7.1及以上；你可以在Shadowsocks客户端中启用TCP Fast Open。

至此，Shadowsock服务器端的优化已经全部完成了！
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://www.polarxiong.com/archives/Ubuntu-16-04%E4%B8%8BShadowsocks%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BC%98%E5%8C%96.html&quot;&gt;启蒙教程&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Tue, 14 Nov 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/11/14/shadowsocks-ubuntu/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/11/14/shadowsocks-ubuntu/</guid>
        
        <category>笔记</category>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Ubuntu下Nginx配置笔记</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Vue.js 放弃中…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;阿里云双十一活动还算良心,赶紧买个服务器自己玩.&lt;/p&gt;

&lt;p&gt;本着日后方便科学上网的原则,买了2核4G,1M带宽的香港节点3年,搭载Ubuntu 16.0402系统镜像.&lt;/p&gt;

&lt;p&gt;本地环境:MAC OS Sierra 10.12.3&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本文分四个部分:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#0&quot;&gt;一、使用SSH通过MAC同Ubuntu建立连接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#1&quot;&gt;二、Ubuntu服务器基本设置&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#2&quot;&gt;三、环境搭建&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#3&quot;&gt;四、配置多个站点&lt;/a&gt;&lt;/p&gt;

&lt;p id=&quot;0&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一使用ssh通过mac同ubuntu建立连接&quot;&gt;一、使用SSH通过MAC同Ubuntu建立连接&lt;/h3&gt;

&lt;h4 id=&quot;1ubuntu端&quot;&gt;1.Ubuntu端&lt;/h4&gt;

&lt;p&gt;在ubuntu终端上输入&lt;code class=&quot;highlighter-rouge&quot;&gt;root@ubuntu:~$ sudo apt-get install openssh-server&lt;/code&gt;命令安装openssh-server.(阿里云生成的系统登陆后,默认是root角色)&lt;/p&gt;

&lt;p&gt;一般报错有两个可能的原因,一个是apt版本过老,办法是update一下;另一个是apt的lists损坏,办法是用如下命令来删除已经损坏的lists.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`root@ubuntu:~$ sudo rm /var/lib/apt/lists/* -vf`
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2mac端&quot;&gt;2.MAC端&lt;/h4&gt;

&lt;p&gt;在终端上输入&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh root@your_server_ip
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;跟着指引输入服务器密码即可,是不是敲简单.&lt;/p&gt;

&lt;p&gt;如果不想每次输入IP,可以在 /.ssh/config 里进行配置,🌰如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Host mylinux
    HostName ***.***.***.***
    Port 22
    User root
    IdentityFile /Users/***/.ssh/mylinux \\这里是ssh私钥的路径,不作不用动
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;像上面这样配置后,每次只需要在终端敲入:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh mylinux
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;即可!&lt;/p&gt;

&lt;p&gt;找不到&lt;code class=&quot;highlighter-rouge&quot;&gt;/Users/***/.ssh&lt;/code&gt;文件夹?
用下面的命令可以显示MAC隐藏文件.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;defaults write com.apple.finder AppleShowAllFiles -bool true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;二ubuntu服务器基本设置&quot;&gt;二、Ubuntu服务器基本设置&lt;/h3&gt;

&lt;h4 id=&quot;使用root登录服务器&quot;&gt;使用root登录服务器&lt;/h4&gt;

&lt;p&gt;首先我们需要使用刚刚配置好的root用户ssh登录服务器:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;local$ ssh root@SERVER_IP_ADDRESS
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;前面的local$表示是在本地机器操作,在服务器端,该提示符会类似&lt;code class=&quot;highlighter-rouge&quot;&gt;root@my-remote-server:~$&lt;/code&gt;这种形式,后边会看到。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Tips: 如果使用的是腾讯云，其初始登录默认使用的是用户ubuntu，并不是root。因此，使用ssh ubuntu@your_server_ip登录之后可以修改下root的密码，然后就可以切换到用户root了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;修改密码命令如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ubuntu@VM-42-158-ubuntu:~$ sudo passwd root
Enter new UNIX password:
Retype new UNIX password:
passwd: password updated successfully
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有可能还需要编辑配置文件/etc/ssh/sshd_config中的PermitRootLogin的设置。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;buntu@VM-42-158-ubuntu:~$ su
Password:
root@VM-42-158-ubuntu:/#
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;新增超级用户权限用户&quot;&gt;新增超级用户权限用户&lt;/h4&gt;

&lt;p&gt;root用户虽然强大,但是正是由于太强大了,所以显得不够安全,因此通常情况下我们需要创建一个新的用户,然后给他设置超级用户(superuser)权限,这样就可以安全的进行各种操作了。&lt;/p&gt;

&lt;p&gt;使用root用户登录,做如下操作:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@my-remote-server:~$ adduser dennis
root@my-remote-server:~$ usermod -aG sudo dennis
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里就将新创建的用户加入了sudo用户组,就具有了超级用户的权限。更详细的信息可以参考&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-edit-the-sudoers-file-on-ubuntu-and-centos&quot;&gt;这个教程&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;然后我们就可以以新创建的用户登录了:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@my-remote-server:~# su - dennis
dennis@my-remote-server:~$
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p id=&quot;2&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;三环境搭建&quot;&gt;三、环境搭建&lt;/h3&gt;

&lt;h4 id=&quot;安装nginx&quot;&gt;安装Nginx&lt;/h4&gt;

&lt;p&gt;在ubuntu上安装软件很简单,使用apt-get即可。注意由于权限问题,需要在前面加sudo。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get update
sudo apt-get install nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;踩坑提醒&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;安装nginx时出现错误&quot;&gt;安装Nginx时出现错误&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dennis@my-remote-server:~$ sudo apt-get install nginx
Reading package lists... Done
Building dependency tree
Reading state information... Done
nginx is already the newest version (1.10.0-0ubuntu0.16.04.2).
0 upgraded, 0 newly installed, 0 to remove and 42 not upgraded.
2 not fully installed or removed.
After this operation, 0 B of additional disk space will be used.
Do you want to continue? [Y/n]
Setting up nginx-core (1.10.0-0ubuntu0.16.04.2) ...
Job for nginx.service failed because the control process exited with error code. See &quot;systemctl status nginx.service&quot; and &quot;journalctl -xe&quot; for details.
invoke-rc.d: initscript nginx, action &quot;start&quot; failed.
dpkg: error processing package nginx-core (--configure):
 subprocess installed post-installation script returned error exit status 1
dpkg: dependency problems prevent configuration of nginx:
 nginx depends on nginx-core (&amp;gt;= 1.10.0-0ubuntu0.16.04.2) | nginx-full (&amp;gt;= 1.10.0-0ubuntu0.16.04.2) | nginx-light (&amp;gt;= 1.10.0-0ubuntu0.16.04.2) | nginx-extras (&amp;gt;= 1.10.0-0ubuntu0.16.04.2); however:
  Package nginx-core is not configured yet.
  Package nginx-full is not installed.
  Package nginx-light is not installed.
  Package nginx-extras is not installed.
 nginx depends on nginx-core (&amp;lt;&amp;lt; 1.10.0-0ubuntu0.16.04.2.1~) | nginx-full (&amp;lt;&amp;lt; 1.10.0-0ubuntu0.16.04.2.1~) | nginx-light (&amp;lt;&amp;lt; 1.10.0-0ubuntu0.16.04.2.1~) | nginx-extras (&amp;lt;&amp;lt; 1.10.0-0ubuntu0.16.04.2.1~); however:
  Package nginx-core is not configured yet.
  Package nginx-full is not installed.
  Package nginx-light is not installed.
  Package nginx-extras is not installed.
dpkg: error processing package nginx (--configure):
 dependency problems - leaving unconfigured
Errors were encountered while processing:
 nginx-core
 nginx
E: Sub-process /usr/bin/dpkg returned an error code (1)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;原因分析&lt;/p&gt;

&lt;p&gt;Google了一下,发现出现这种错误,一般应该是由于其他应用占用了80端口。可以这样来看下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dennis@myserver:~$ sudo netstat -nlp
sudo: unable to resolve host myserver
[sudo] password for dennis:
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      132/rpcbind
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      332/apache2
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      269/sshd
tcp        0      0 0.0.0.0:25              0.0.0.0:*               LISTEN      454/master
tcp6       0      0 :::111                  :::*                    LISTEN      132/rpcbind
tcp6       0      0 :::22                   :::*                    LISTEN      269/sshd
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;果然80端口被默认安装的apache给占掉了,所以需要干掉占用80端口的apache2：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo kill -9 332
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行apt-get命令更新或安装软件出现Setting locale failed错误&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
	LANGUAGE = (unset),
	LC_ALL = (unset),
	LC_CTYPE = &quot;en_US.UTF-8&quot;,
	LANG = &quot;en_US.UTF-8&quot;
    are supported and installed on your system.
perl: warning: Falling back to the standard locale (&quot;C&quot;).
locale: Cannot set LC_CTYPE to default locale: No such file or directory
locale: Cannot set LC_MESSAGES to default locale: No such file or directory
locale: Cannot set LC_ALL to default locale: No such file or directory
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;解决办法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo ap-get update
apt-get install language-pack-en
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;nginx-常用目录&quot;&gt;Nginx 常用目录&lt;/h5&gt;

&lt;p&gt;内容&lt;/p&gt;

&lt;p&gt;/var/www/html: 保存web网页内容的默认目录&lt;/p&gt;

&lt;p&gt;服务器配置&lt;/p&gt;

&lt;p&gt;/etc/nginx: nginx 配置目录。所有Nginx相关的配置文件都在这里。
/etc/nginx/nginx.conf: Nginx主配置文件,进行全局默认设置。
/etc/nginx/sites-available: 针对每个”server blocks”独立的配置文件。这里的配置文件并不被直接使用,只有软连接到site-enabled的配置才会真正生效。
/etc/nginx/sites-enabled/: 针对每个”server blocks”独立的配置文件。由sites-available链接过来。
/etc/nginx/snippets: 一些配置脚本片段。&lt;/p&gt;

&lt;p&gt;服务器日志&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/nginx/access.log: &lt;/code&gt;默认保存所有与web服务交互的请求。
&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/nginx/error.log: &lt;/code&gt;Nginx的错误日志&lt;/p&gt;

&lt;h4 id=&quot;顺便安装一下mysql&quot;&gt;顺便安装一下MySQL&lt;/h4&gt;

&lt;h5 id=&quot;安装&quot;&gt;安装&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get update
sudo apt-get install mysql-server
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;配置&quot;&gt;配置&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo mysql_secure_installation
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;查看mysql的版本&quot;&gt;查看MySQL的版本：&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql --version
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;初始化&quot;&gt;初始化&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo mysqld --initialize
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果是如上面那样通过apt-get安装的，这一步通常已经被做了。因此会有如下错误提示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[ERROR] --initialize specified but the data directory has files in it. Aborting.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;mysql的启动和停止&quot;&gt;MySQL的启动和停止&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo /etc/init.d/mysql start
sudo /etc/init.d/mysql stop
sudo /etc/init.d/mysql restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo start mysql
sudo stop mysql
sudo restart mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;测试连接&quot;&gt;测试连接&lt;/h5&gt;

&lt;p&gt;可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;mysqladmin -p -u root version&lt;/code&gt;命令来测试一下mysql连接是否正常。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dennis@my-remote-server:/var/www/html$ mysqladmin -p -u root version
Enter password:
mysqladmin  Ver 8.42 Distrib 5.7.13, for Linux on x86_64
Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Server version		5.7.13-0ubuntu0.16.04.2
Protocol version	10
Connection		Localhost via UNIX socket
UNIX socket		/var/run/mysqld/mysqld.sock
Uptime:			19 min 14 sec
Threads: 1  Questions: 8  Slow queries: 0  Opens: 115  Flush tables: 1  Open tables: 34  Queries per second avg: 0.006
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;创建数据库及新的数据库用户&quot;&gt;创建数据库及新的数据库用户&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql -u root -p
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;用密码登录成功之后执行下面的sql语句创建一个数据库，名叫lawootrip&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE DATABASE lawootrip DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安全起见，我们为这个数据库创建一个单独的用户：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GRANT ALL ON wordpress.* TO 'lawootripuser'@'localhost' IDENTIFIED BY 'password';
FLUSH PRIVILEGES;
EXIT;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在外网通过IP直接访问操作数据库&lt;/p&gt;

&lt;p&gt;默认情况下,我们只能在服务器上通过localhost访问MySQL,如果需要通过IP从外网访问,需要进行相应的设置。&lt;/p&gt;

&lt;p&gt;1) 修改授权&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GRANT ALL ON lawootrip.* TO 'lawootripuser'@'%' IDENTIFIED BY 'password';
FLUSH PRIVILEGES;
EXIT;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果需要,还可以指定特定的IP地址(替换上面的%即可)。&lt;/p&gt;

&lt;p&gt;或者可以直接修改表:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql -u root -p
mysql&amp;gt; use mysql;
mysql&amp;gt; update user set host = '%' where user = 'root';
mysql&amp;gt; select user, host from user;
+------------------+-----------+
| user             | host      |
+------------------+-----------+
| mysql.sys        | localhost |
| root             | localhost |
| wordpressuser    | %         |
+------------------+-----------+
3 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2) 修改配置文件&lt;/p&gt;

&lt;p&gt;配置文件位置为/etc/mysql/mysql.conf.d/mysqld.cnf,注释掉其中一行:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bind-address  =127.0.0.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重启MySQL即可:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo service mysql restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;配置nginx&quot;&gt;配置Nginx&lt;/h5&gt;

&lt;p&gt;打开配置文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo vim /etc/nginx/sites-available/default
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;作如下修改（具体可以参考&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-install-wordpress-with-lemp-on-ubuntu-16-04&quot;&gt;这里的说明&lt;/a&gt;）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
    . . .
    location = /favicon.ico { log_not_found off; access_log off; }
    location = /robots.txt { log_not_found off; access_log off; allow all; }
    location ~* \.(css|gif|ico|jpeg|jpg|js|png)$ {
        expires max;
        log_not_found off;
    }
    . . .
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对try_files做如下修改：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
    . . .
    location / {
        #try_files $uri $uri/ =404;
        try_files $uri $uri/ /index.php$is_args$args;
    }
    . . .
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后检查配置文件的正确性，并重启Nginx：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo nginx -t
//If no errors were reported, reload Nginx by typing:
sudo systemctl reload nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p id=&quot;3&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;四配置多个站点&quot;&gt;四、配置多个站点&lt;/h3&gt;

&lt;p&gt;通常情况下我们需要在Web服务器上部署多个站点,使用多个不同的域名。&lt;/p&gt;

&lt;h4 id=&quot;设置新的文档目录&quot;&gt;设置新的文档目录&lt;/h4&gt;

&lt;p&gt;默认情况下,在Ubuntu上的Nginx已经默认创建了一个server block,其文档目录为/var/www/html(我们在上面安装wordpress的时候使用的就是这个默认的server block)。&lt;/p&gt;

&lt;p&gt;如果我们需要部署多个站点,那么就需要创建多个不同的server block。假如我们需要部署两个网站:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lawootrip.com
lawoo.cn
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样我们就需要设置两个新的文档目录。为统一起见,我们使用xxx.com/html这种目录结构形式:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo mkdir -p /var/www/lawootrip.com/html
sudo mkdir -p /var/www/lawoo.cn/html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;修改一下这两个文档目录的权限:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo chown -R $USER:$USER /var/www/lawootrip.com/html
sudo chown -R $USER:$USER /var/www/lawoo.cn/html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里用到了环境变量&lt;code class=&quot;highlighter-rouge&quot;&gt;$USER&lt;/code&gt;,请确保没有使用root账号进行操作。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dennis@my-remote-server:~$ echo $USER
dennis
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;至此文档目录应该配置好了。如果需要,我们可以通过下面的命令设置一下上层目录的权限:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo chmod -R 755 /var/www
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要提醒的是,暂时不需要担心这两个测试域名是否可以访问的问题,后边我们会介绍在本地浏览器如何访问这两个测试域名。&lt;/p&gt;

&lt;h4 id=&quot;为每个站点创建测试文件&quot;&gt;为每个站点创建测试文件&lt;/h4&gt;

&lt;p&gt;创建文件/var/www/lawootrip.com/html/index.html&lt;/p&gt;

&lt;p&gt;创建文件/var/www/lawoo.cn/html/index.html&lt;/p&gt;

&lt;h4 id=&quot;为每个站点创建server-block文件&quot;&gt;为每个站点创建server block文件&lt;/h4&gt;

&lt;p&gt;如前所述,默认情况下Nginx已经配置了一个默认的server block,因此我们可以将默认的server block配置文件拷贝过来稍作修改:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo cp /etc/nginx/sites-available/default /etc/nginx/sites-available/lawootrip.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;打开文件:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo vim /etc/nginx/sites-available/lawootrip.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
        listen 80 default_server;
        listen [::]:80 default_server;
        root /var/www/html;
        index index.html index.htm index.nginx-debian.html;
        server_name _;
        location / {
                try_files $uri $uri/ =404;
        }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对其内容稍作修改,修改之后内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
        listen 80;
        listen [::]:80;
        root /var/www/lawootrip.com/html;
        index index.html index.htm index.nginx-debian.html;
        server_name lawootrip.com www.lawootrip.com;
        location / {
                try_files $uri $uri/ =404;
        }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;主要修改了几个地方:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;去掉了default_server字眼。一台服务器上只能有一个default_server的配置,因此我们保留系统最初的设置为默认设置。&lt;/li&gt;
  &lt;li&gt;修改root目录.&lt;/li&gt;
  &lt;li&gt;修改server_name.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;针对第二个站点lawoo.cn也做类似修改。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo cp /etc/nginx/sites-available/lawoo.cn /etc/nginx/sites-available/lawoo.cn
sudo vim /etc/nginx/sites-available/lawoo.cn
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;激活两个站点的server-block&quot;&gt;激活两个站点的server block&lt;/h4&gt;

&lt;p&gt;使用如下命令:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo ln -s /etc/nginx/sites-available/lawootrip.com /etc/nginx/sites-enabled/
sudo ln -s /etc/nginx/sites-available/lawoo.cn /etc/nginx/sites-enabled/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样这些文件(链接)就位于激活的目录内了。到目前为止我们有3个激活了的server block了。服务器根据listen指令和server_name来确定该访问那个目录。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;lawootrip.com: 响应来自lawootrip.com以及www.lawootrip.com的请求&lt;/li&gt;
  &lt;li&gt;lawoo.cn: 响应来自lawoo.cn以及www.lawoo.cn的请求&lt;/li&gt;
  &lt;li&gt;default: 响应没有匹配到上面两个规则的80端口的请求。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后检查下nginx配置文件的正确性:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo nginx -t
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;**重启一下nginx使修改生效:**&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl restart nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;关于Nginx更多的指令介绍可以参考&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/understanding-nginx-server-and-location-block-selection-algorithms&quot;&gt;这个教程&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;配置二级子域名及代理访问&quot;&gt;配置二级子域名及代理访问&lt;/h4&gt;

&lt;p&gt;举例来说，比如我们在我的服务器上有两个web程序，一个是之前的 lawootrip.com，另一个程序是python应用，使用端口5555，需要映射到二级域名 demo.lawootrip.com。我们应该如何设置呢？&lt;/p&gt;

&lt;h5 id=&quot;1添加域名解析&quot;&gt;1）添加域名解析&lt;/h5&gt;

&lt;p&gt;这个步骤不多说了，在域名服务提供商网站添加一条A记录，设置域名demo.lawootrip.com。&lt;/p&gt;

&lt;h5 id=&quot;2修改nginx配置文件&quot;&gt;2）修改Nginx配置文件&lt;/h5&gt;

&lt;p&gt;就是我们上面提到的文件&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/nginx/sites-available/lawootrip.com&lt;/code&gt;,添加如下内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
    listen 80;
    server_name demo.example.com;
    location / {
        proxy_set_header   X-Real-IP $remote_addr;
        proxy_set_header   Host      $http_host;
        proxy_pass         http://127.0.0.1:5555;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后重启Nginx即可。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl restart nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Tips 阿里云特供&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ubuntu 在每次执行命令的时候，会报如下错误：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo
sudo: unable to resolve host iZj6cfyvsfiajdiy47qddhZ
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;iZj6cfyvsfiajdiy47qddhZ是阿里云创建服务器默认的hostname，错误其实没有什么影响，但看起来很不爽，解决方式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vim /etc/hostname
iZj6cfyvsfiajdiy47qddhZ
$ vim /etc/hosts
127.0.0.1       localhost iZj6cfyvsfiajdiy47qddhZ
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结尾处增加hostname.搞定.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://foofish.net/https-free-for-lets-encrypt.html&quot;&gt;免费HTTPS证书Let’s Encrypt安装教程&lt;/a&gt;
&lt;a href=&quot;http://tengine.taobao.org/book/chapter_02.html&quot;&gt;nginx平台初探(100%)&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a href=&quot;https://linghucong.js.org/2016/08/18/ubuntu_1604_web_server_config_LEMP/&quot;&gt;主要参考教程&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 02 Nov 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/11/02/mylinux-virginnight/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/11/02/mylinux-virginnight/</guid>
        
        <category>笔记</category>
        
        <category>服务器</category>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>用Charles在iOS上抓包</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Vue.js 放弃中…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;来总结一下用Charles在iOS上抓包的方法。&lt;/p&gt;

&lt;p&gt;本文分三个部分：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#0&quot;&gt;一、Mac客户端 下载安装激活&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#1&quot;&gt;二、Mac/iPhone证书 下载安装信任&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#2&quot;&gt;三、抓&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我是看不见的分割线&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p id=&quot;0&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一mac客户端-下载安装激活&quot;&gt;一、Mac客户端 下载安装激活&lt;/h2&gt;

&lt;p&gt;首先安装一枚Charles Mac版，俗称花瓶的抓包神器。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.charlesproxy.com/&quot;&gt;官网下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-10-17-1.png&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;如图所示下载最新版本&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;下载并安装后打开并激活,Charles提供15天的免费试用，购买正价为30$。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;顺便说一句，破解版Charles偶发中文乱码，抓包数据不显示等问题,而且更新也不及时，建议购买正版神器。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;打开Charles后，点击菜单栏的Proxy-&amp;gt;Proxy Settings…&lt;/p&gt;

&lt;p&gt;勾选：HTTP Proxy，并设置Port为8888。&lt;/p&gt;

&lt;p&gt;如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-10-17-2.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;http://image.lawootrip.com/2017-10-17-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;二iphone证书-下载安装信任&quot;&gt;二、iPhone证书 下载安装信任&lt;/h2&gt;

&lt;p&gt;安装好Mac客户端，就拿起手机开始配置iPhone了。&lt;/p&gt;

&lt;h3 id=&quot;先用mac建立同iphone的代理通道&quot;&gt;先用Mac建立同iPhone的代理通道&lt;/h3&gt;

&lt;p&gt;打开自己电脑的系统偏好设置-&amp;gt;网络-&amp;gt;选中现在连着的wifi,以查到自己这个电脑在现在这个wifi里的IP地址，比如我现在这个就是192.168.0.115（建议最好用私人或普通开放网络，用公司内网可能会有限制会出现代理失败的问题）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2155136-404b2e0bea921839.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后确保手机也连接了同一个wifi，然后进入手机的wifi配置(wifi名称右边的蓝色“i”图标)，将http代理改为:192.168.0.115；端口：8888。点击左上角返回。返回后系统会自动设置代理重新连接。&lt;/p&gt;

&lt;p&gt;这时候你的手机上网的过程中就要经过你的电脑了。刚用手机打开一个联网的程序，你的电脑上应该会显示一个弹窗问你【allow】还是【deny】肯定不能拒绝啊就点allow吧。这个只有第一次才弹窗。点了同意之后你手机发出的每一个请求都会被拦截出痕迹。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2469183-8630cf0087d20187.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2469183-874a256420dcae1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;注意：开启花瓶代理后，要关闭所有其他形式的代理，如爱国SS、爱国VPN等。&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;再安装ssl证书到手机设备&quot;&gt;再安装SSL证书到手机设备&lt;/h3&gt;

&lt;p&gt;点击 Help -&amp;gt; SSL Proxying -&amp;gt; Install Charles Root Certificate on a Mobile Device&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2469183-8f47a1b1c1540ef7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2469183-c7f6ad4a204b0bd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;出现弹窗得到地址&lt;a href=&quot;chls.pro/ssl&quot;&gt;chls.pro/ssl&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;在手机Safari浏览器输入地址 chls.pro/ssl，出现证书安装页面，点击安装
手机设置有密码的输入密码进行安装&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2469183-7ed4a5c8c2a36217.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;注意：安装信任证书需保持电脑对手机的代理状态&lt;/code&gt;&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;iOS 10.3及以上的系统，需要在 设置→通用→关于本机→证书信任设置 里面启用完全信任Charles证书&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-10-17-4.png&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;图示为iOS11界面&lt;/small&gt;&lt;/p&gt;

&lt;h3 id=&quot;最后charles设置proxy&quot;&gt;最后Charles设置Proxy&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2469183-2c460b4652797ccf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;Proxy -&amp;gt; SSL Proxying Settings…&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2469183-11eb2be75eae13fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;勾选Enable SSL Proxying,点击Add&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Host填写：*&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Port填写：443&lt;/code&gt;&lt;/p&gt;

&lt;p id=&quot;2&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;三抓&quot;&gt;三、抓&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;大

功

告

成

！
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;让手机重新发送https请求，可看到抓包&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2469183-5f1b21912781d466.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;注意：不抓包请关闭手机HTTP代理，否则断开与电脑连接后会连不上网&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Charles还有不少好玩的网络调试功能，等我放弃Vue了再来说说。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Tue, 17 Oct 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/10/17/charles-ssl/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/10/17/charles-ssl/</guid>
        
        <category>笔记</category>
        
        <category>效率</category>
        
        <category>前端</category>
        
        
      </item>
    
      <item>
        <title>Mac下重置MySQL的权限、密码</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Vue.js 放弃中…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;每次重启Mac后，我的Navicat都会提示本地的MySQL服务密码不对。&lt;/p&gt;

&lt;p&gt;每次都需要用sudo刷新MySQL权限才可以正常连接，即使重置密码，再次重启MySQL服务后，又提示密码不对。&lt;/p&gt;

&lt;p&gt;所以暂时先把命令行强行重置MySQL密码的方法记录如下，日后再研究如何彻底解决。&lt;/p&gt;

&lt;h2 id=&quot;mysql的三个基本命令&quot;&gt;MySQL的三个基本命令&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    sudo /usr/local/mysql/support-files/mysql.server start //启动

    sudo /usr/local/mysql/support-files/mysql.server stop //停止

    sudo /usr/local/mysql/support-files/mysql.server restart //重启

    sudo pkill -9 mysql //强制关闭进程
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;-三步重置mysql权限和密码&quot;&gt;* 三步重置MySQL权限和密码&lt;/h2&gt;

&lt;h4 id=&quot;第一步&quot;&gt;第一步&lt;/h4&gt;

&lt;p&gt;停止 mysql server.  通常是在 ‘系统偏好设置’ &amp;gt; MySQL &amp;gt; ‘Stop MySQL Server’&lt;/p&gt;

&lt;p&gt;也可以在命令行中用上面的命令终止MySQL。&lt;/p&gt;

&lt;h4 id=&quot;第二步&quot;&gt;第二步&lt;/h4&gt;

&lt;p&gt;新开一个终端，输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    sudo /usr/local/mysql/bin/mysqld_safe --skip-grant-tables
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此时MySQl应该又重新启动了。&lt;/p&gt;

&lt;h4 id=&quot;第三步&quot;&gt;第三步&lt;/h4&gt;

&lt;p&gt;再新开一个终端，依次输入并回车：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    sudo /usr/local/mysql/bin/mysql -u root

    UPDATE mysql.user SET authentication_string=PASSWORD('新密码') WHERE User='root';

　　 FLUSH PRIVILEGES;

 　　\q
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重启MySQL即可&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/WX20170812-125719@2x.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;清爽&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/08/12/mysql-psw/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/12/mysql-psw/</guid>
        
        <category>笔记</category>
        
        <category>MySQL</category>
        
        <category>数据库</category>
        
        
      </item>
    
      <item>
        <title>Web缓存的一些细碎02</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Vue.js 放弃中…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。&lt;/p&gt;

&lt;p&gt;本次从三个方面对学习进行小结。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#0&quot;&gt;一、H5缓存机制介绍&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#1&quot;&gt;二、H5缓存机制原理分析&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#2&quot;&gt;三、移动端Web加载性能（缓存）优化&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我是看不见的分割线&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p id=&quot;0&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一web缓存的作用&quot;&gt;一、web缓存的作用&lt;/h2&gt;

&lt;p&gt;H5，即 HTML5，是新一代的 HTML 标准，加入很多新的特性。离线存储（也可称为缓存机制）是其中一个非常重要的特性。H5 引入的离线存储，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。&lt;/p&gt;

&lt;p&gt;H5 应用程序缓存为应用带来三个优势：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;离线浏览，用户可以在无网络时使用产品&lt;/li&gt;
  &lt;li&gt;速度，已缓存的资源加载的更快&lt;/li&gt;
  &lt;li&gt;负载优化，浏览器只从服务器下载更新过或更改过的资源&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;H5目前的6种缓存机制在&lt;a href=&quot;http://www.lawootrip.com/2017/07/17/web-localstorage-Volume01/&quot;&gt;前一篇文章&lt;/a&gt;有提及。&lt;/p&gt;

&lt;p&gt;下面将首先分析各种缓存机制的原理、用法及特点；然后针对 Anroid 移动端 Web 性能加载优化的需求，看如果利用适当缓存机制来提高 Web 的加载性能。&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;二h5-缓存机制原理&quot;&gt;二、H5 缓存机制原理&lt;/h2&gt;

&lt;h3 id=&quot;21-浏览器缓存机制详解&quot;&gt;2.1 浏览器缓存机制详解&lt;/h3&gt;

&lt;p&gt;浏览器缓存机制是指通过 HTTP 协议头里的 Cache-Control（或 Expires）和 Last-Modified（或 Etag）等字段来控制文件缓存的机制。这应该是 WEB 中最早的缓存机制了，是在 HTTP 协议中实现的，有点不同于 Dom Storage、AppCache 等缓存机制，但本质上是一样的。可以理解为，一个是协议层实现的，一个是应用层实现的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cache-Control&lt;/strong&gt; 用于控制文件在本地缓存有效时长。最常见的，比如服务器回包：Cache-Control:max-age=600 表示文件在本地应该缓存，且有效时长是600秒（从发出请求算起）。在接下来600秒内，如果有请求这个资源，浏览器不会发出 HTTP 请求，而是直接使用本地缓存的文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Last-Modified&lt;/strong&gt; 是标识文件在服务器上的最新更新时间。下次请求时，如果文件缓存过期，浏览器通过 If-Modified-Since 字段带上这个时间，发送给服务器，由服务器比较时间戳来判断文件是否有修改。如果没有修改，服务器返回304告诉浏览器继续使用缓存；如果有修改，则返回200，同时返回最新的文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cache-Control&lt;/strong&gt; 通常与 Last-Modified 一起使用。一个用于控制缓存有效时间，一个在缓存失效后，向服务查询是否有更新。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cache-Control&lt;/strong&gt; 还有一个同功能的字段：Expires。Expires 的值一个绝对的时间点，如：Expires: Thu, 10 Nov 2015 08:45:11 GMT，表示在这个时间点之前，缓存都是有效的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Expires&lt;/strong&gt; 是 HTTP1.0 标准中的字段，Cache-Control 是 HTTP1.1 标准中新加的字段，功能一样，都是控制缓存的有效时间。当这两个字段同时出现时，Cache-Control 是高优化级的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Etag&lt;/strong&gt; 也是和 Last-Modified 一样，对文件进行标识的字段。不同的是，Etag 的取值是一个对文件进行标识的特征字串。在向服务器查询文件是否有更新时，浏览器通过 If-None-Match 字段把特征字串发送给服务器，由服务器和文件最新特征字串进行匹配，来判断文件是否有更新。没有更新回包304，有更新回包200。Etag 和 Last-Modified 可根据需求使用一个或两个同时使用。两个同时使用时，只要满足基中一个条件，就认为文件没有更新。&lt;/p&gt;

&lt;p&gt;另外有两种特殊的情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;手动刷新页面（F5)，浏览器会直接认为缓存已经过期（可能缓存还没有过期），在请求中加上字段：&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache-Control:max-age=0&lt;/code&gt;，发包向服务器查询是否有文件是否有更新。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;强制刷新页面（Ctrl+F5)，浏览器会直接忽略本地的缓存（有缓存也会认为本地没有缓存），在请求中加上字段：&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache-Control:no-cache&lt;/code&gt;（或 &lt;code class=&quot;highlighter-rouge&quot;&gt;Pragma:no-cache&lt;/code&gt;），发包向服务重新拉取文件。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面是通过 Google Chrome 浏览器（用其他浏览器+抓包工具也可以）自带的开发者工具，对一个资源文件不同情况请求与回包的截图。&lt;/p&gt;

&lt;p&gt;首次请求：200&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/241/923/2419230919-56fdeab9a8ba6_articlex&quot; alt=&quot;200&quot; /&gt;&lt;/p&gt;

&lt;p&gt;缓存有效期内请求：200(from cache)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/122/114/1221141305-56fdeaba76fb8_articlex&quot; alt=&quot;200 from cache&quot; /&gt;&lt;/p&gt;

&lt;p&gt;缓存过期后请求：304（Not Modified)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/135/686/135686075-56fdeabb2c2bc_articlex&quot; alt=&quot;304 from cache&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一般浏览器会将缓存记录及缓存文件存在本地 Cache 文件夹中。Android 下 App 如果使用 Webview，缓存的文件记录及文件内容会存在当前 app 的 data 目录中。&lt;/p&gt;

&lt;p&gt;分析：Cache-Control 和 Last-Modified 一般用在 Web 的静态资源文件上，如 JS、CSS 和一些图像文件。通过设置资源文件缓存属性，对提高资源文件加载速度，节省流量很有意义，特别是移动网络环境。但问题是：缓存有效时长该如何设置？如果设置太短，就起不到缓存的使用；如果设置的太长，在资源文件有更新时，浏览器如果有缓存，则不能及时取到最新的文件。&lt;/p&gt;

&lt;p&gt;Last-Modified 需要向服务器发起查询请求，才能知道资源文件有没有更新。虽然服务器可能返回304告诉没有更新，但也还有一个请求的过程。对于移动网络，这个请求可能是比较耗时的。有一种说法叫“消灭304”，指的就是优化掉304的请求。&lt;/p&gt;

&lt;p&gt;抓包发现，带 if-Modified-Since 字段的请求，如果服务器回包304，回包带有 Cache-Control:max-age 或 Expires 字段，文件的缓存有效时间会更新，就是文件的缓存会重新有效。304回包后如果再请求，则又直接使用缓存文件了，不再向服务器查询文件是否更新了，除非新的缓存时间再次过期。&lt;/p&gt;

&lt;p&gt;另外，Cache-Control 与 Last-Modified 是浏览器内核的机制，一般都是标准的实现，不能更改或设置。以 QQ 浏览器的 X5为例，Cache-Control 与 Last-Modified 缓存不能禁用。缓存容量是12MB，不分HOST，过期的缓存会最先被清除。如果都没过期，应该优先清最早的缓存或最快到期的或文件大小最大的；过期缓存也有可能还是有效的，清除缓存会导致资源文件的重新拉取。&lt;/p&gt;

&lt;p&gt;还有，浏览器，如 X5，在使用缓存文件时，是没有对缓存文件内容进行校验的，这样缓存文件内容被修改的可能。&lt;/p&gt;

&lt;p&gt;分析发现，浏览器的缓存机制还不是非常完美的缓存机制。完美的缓存机制应该是这样的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;缓存文件没更新，尽可能使用缓存，不用和服务器交互；&lt;/li&gt;
  &lt;li&gt;缓存文件有更新时，第一时间能使用到新的文件；&lt;/li&gt;
  &lt;li&gt;缓存的文件要保持完整性，不使用被修改过的缓存文件；&lt;/li&gt;
  &lt;li&gt;缓存的容量大小要能设置或控制，缓存文件不能因为存储空间限制或过期被清除。以X5为例，第1、2条不能同时满足，第3、4条都不能满足。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在实际应用中，为了解决 Cache-Control 缓存时长不好设置的问题，以及为了”消灭304“，Web前端采用的方式是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在要缓存的资源文件名中加上版本号或文件 MD5值字串，如 common.d5d02a02.js，common.v1.js，同时设置 Cache-Control:max-age=31536000，也就是一年。在一年时间内，资源文件如果本地有缓存，就会使用缓存；也就不会有304的回包。&lt;/li&gt;
  &lt;li&gt;如果资源文件有修改，则更新文件内容，同时修改资源文件名，如 common.v2.js，html页面也会引用新的资源文件名。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过这种方式，实现了：缓存文件没有更新，则使用缓存；缓存文件有更新，则第一时间使用最新文件的目的。即上面说的第1、2条。第3、4条由于浏览器内部机制，目前还无法满足。&lt;/p&gt;

&lt;h3 id=&quot;22-dom-storage-存储机制&quot;&gt;2.2 Dom Storage 存储机制&lt;/h3&gt;

&lt;p&gt;DOM 存储是一套在 Web Applications 1.0 规范中首次引入的与存储相关的特性的总称，现在已经分离出来，单独发展成为独立的 W3C Web 存储规范。 DOM 存储被设计为用来提供一个更大存储量、更安全、更便捷的存储方法，从而可以代替掉将一些不需要让服务器知道的信息存储到 cookies 里的这种传统方法。&lt;/p&gt;

&lt;p&gt;上面一段是对 Dom Storage 存储机制的官方表述。看起来，Dom Storage 机制类似 Cookies，但有一些优势。&lt;/p&gt;

&lt;p&gt;Dom Storage 是通过存储字符串的 Key/Value 对来提供的，并提供 5MB （不同浏览器可能不同，分 HOST)的存储空间（Cookies 才 4KB)。另外 Dom Storage 存储的数据在本地，不像 Cookies，每次请求一次页面，Cookies 都会发送给服务器。&lt;/p&gt;

&lt;p&gt;DOM Storage 分为 sessionStorage 和 localStorage。localStorage 对象和 sessionStorage 对象使用方法基本相同，它们的区别在于作用的范围不同。sessionStorage 用来存储与页面相关的数据，它在页面关闭后无法使用。而 localStorage 则持久存在，在页面关闭后也可以使用。&lt;/p&gt;

&lt;p&gt;Dom Storage 提供了以下的存储接口：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface Storage { 
readonly attribute unsigned long length; 
[IndexGetter] DOMString key(in unsigned long index); 
[NameGetter] DOMString getItem(in DOMString key); 
[NameSetter] void setItem(in DOMString key, in DOMString data); 
[NameDeleter] void removeItem(in DOMString key); 
void clear();
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;sessionStorage 是个全局对象，它维护着在页面会话(page session)期间有效的存储空间。只要浏览器开着，页面会话周期就会一直持续。当页面重新载入(reload)或者被恢复(restores)时，页面会话也是一直存在的。每在新标签或者新窗口中打开一个新页面，都会初始化一个新的会话。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
// 当页面刷新时，从sessionStorage恢复之前输入的内容
window.onload = function(){
  if (window.sessionStorage) {
      var name = window.sessionStorage.getItem(&quot;name&quot;);
      if (name != &quot;&quot; || name != null){
          document.getElementById(&quot;name&quot;).value = name;
      }
  }
};

// 将数据保存到sessionStorage对象中
function saveToStorage() {
  if (window.sessionStorage) {
     var name = document.getElementById(&quot;name&quot;).value;
     window.sessionStorage.setItem(&quot;name&quot;, name);
     window.location.href=&quot;session_storage.html&quot;;
 }
}
 &amp;lt;/script&amp;gt;

&amp;lt;form action=&quot;./session_storage.html&quot;&amp;gt;
  &amp;lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot;/&amp;gt;
  &amp;lt;input type=&quot;button&quot; value=&quot;Save&quot; onclick=&quot;saveToStorage()&quot;/&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当浏览器被意外刷新的时候，一些临时数据应当被保存和恢复。sessionStorage 对象在处理这种情况的时候是最有用的。比如恢复我们在表单中已经填写的数据。&lt;/p&gt;

&lt;p&gt;把上面的代码复制到 session_storage.html（也可以从附件中直接下载）页面中，用 Google Chrome 浏览器的不同 PAGE 或 WINDOW 打开，在输入框中分别输入不同的文字，再点击“Save”，然后分别刷新。每个 PAGE 或 WINDOW 显示都是当前PAGE输入的内容，互不影响。关闭 PAGE，再重新打开，上一次输入保存的内容已经没有了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/220/256/2202563205-56fe424093728_articlex&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/935/566/93556648-56fe423f1827f_articlex&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Local Storage 的接口、用法与 Session Storage 一样，唯一不同的是：Local Storage 保存的数据是持久性的。当前 PAGE 关闭（Page Session 结束后），保存的数据依然存在。重新打开PAGE，上次保存的数据可以获取到。另外，Local Storage 是全局性的，同时打开两个 PAGE 会共享一份存数据，在一个PAGE中修改数据，另一个 PAGE 中是可以感知到的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;
  //通过localStorage直接引用key, 另一种写法，等价于：
  //localStorage.getItem(&quot;pageLoadCount&quot;);
  //localStorage.setItem(&quot;pageLoadCount&quot;, value);
  if (!localStorage.pageLoadCount)
localStorage.pageLoadCount = 0;
     localStorage.pageLoadCount = parseInt(localStorage.pageLoadCount) + 1;
     document.getElementById('count').textContent = localStorage.pageLoadCount;
&amp;lt;/script&amp;gt;

&amp;lt;p&amp;gt;
    You have viewed this page
    &amp;lt;span id=&quot;count&quot;&amp;gt;an untold number of&amp;lt;/span&amp;gt;
    time(s).
&amp;lt;/p&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将上面代码复制到 local_storage.html 的页面中，用浏览器打开，pageLoadCount 的值是1；关闭 PAGE 重新打开，pageLoadCount 的值是2。这是因为第一次的值已经保存了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/202/620/2026209678-56fe4241451ef_articlex&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/836/137/836137524-56fe424228af7_articlex&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用两个 PAGE 同时打开 local_storage.html，并分别交替刷新，发现两个 PAGE 是共享一个 pageLoadCount 的。&lt;/p&gt;

&lt;p&gt;分析：Dom Storage 给 Web 提供了一种更录活的数据存储方式，存储空间更大（相对 Cookies)，用法也比较简单，方便存储服务器或本地的一些临时数据。&lt;/p&gt;

&lt;p&gt;从 DomStorage 提供的接口来看，DomStorage 适合存储比较简单的数据，如果要存储结构化的数据，可能要借助 JASON了，将要存储的对象转为 JASON 字串。不太适合存储比较复杂或存储空间要求比较大的数据，也不适合存储静态的文件等。&lt;/p&gt;

&lt;h4 id=&quot;23-web-sql-database存储机制&quot;&gt;2.3 Web SQL Database存储机制&lt;/h4&gt;

&lt;p&gt;H5 也提供基于 SQL 的数据库存储机制，用于存储适合数据库的结构化数据。根据官方的标准文档，Web SQL Database 存储机制不再推荐使用，将来也不再维护，而是推荐使用 AppCache 和 IndexedDB。&lt;/p&gt;

&lt;p&gt;现在主流的浏览器（点击查看浏览器支持情况）都还是支持 Web SQL Database 存储机制的。Web SQL Database 存储机制提供了一组 API 供 Web App 创建、存储、查询数据库。&lt;/p&gt;

&lt;p&gt;下面通过简单的例子，演示下 Web SQL Database 的使用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;
    if(window.openDatabase){
      //打开数据库，如果没有则创建
      var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024);

       //通过事务，创建一个表，并添加两条记录
      db.transaction(function (tx) {
           tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)');
           tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, &quot;foobar&quot;)');
           tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, &quot;logmsg&quot;)');
       });

      //查询表中所有记录，并展示出来
     db.transaction(function (tx) {
         tx.executeSql('SELECT * FROM LOGS', [], function (tx, results) {
             var len = results.rows.length, i;
             msg = &quot;&amp;lt;p&amp;gt;Found rows: &quot; + len + &quot;&amp;lt;/p&amp;gt;&quot;;
             for(i=0; i&amp;lt;len; i++){
                 msg += &quot;&amp;lt;p&amp;gt;&quot; + results.rows.item(i).log + &quot;&amp;lt;/p&amp;gt;&quot;;
             }
             document.querySelector('#status').innerHTML =  msg;
             }, null);
      });
}

&amp;lt;/script&amp;gt;

&amp;lt;div id=&quot;status&quot; name=&quot;status&quot;&amp;gt;Status Message&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将上面代码复制到 sql_database.html 中，用浏览器打开，可看到下面的内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/204/236/2042368915-56fe438fbfd26_articlex&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;官方建议浏览器在实现时，对每个 HOST 的数据库存储空间作一定限制，建议默认是 5MB（分 HOST）的配额；达到上限后，可以申请更多存储空间。另外，现在主流浏览器 SQL Database 的实现都是基于 SQLite。&lt;/p&gt;

&lt;p&gt;分析：SQL Database 的主要优势在于能够存储结构复杂的数据，能充分利用数据库的优势，可方便对数据进行增加、删除、修改、查询。由于 SQL 语法的复杂性，使用起来麻烦一些。SQL Database 也不太适合做静态文件的缓存。&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;2&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;三移动端-web-加载性能缓存优化&quot;&gt;三、移动端 Web 加载性能（缓存）优化&lt;/h2&gt;

&lt;p&gt;分析完 H5提供的各种缓存机制，回到移动端（针对 Android，可能也适用于 iOS）的场景。现在 Android App大多嵌入了 Webview 的组件（系统 Webview 或 QQ 游览器的 X5组件），通过内嵌Webview 来加载一些H5的运营活动页面或资讯页。这样可充分发挥Web前端的优势：快速开发、发布，灵活上下线。但 Webview 也有一些不可忽视的问题，比较突出的就是加载相对较慢，会相对消耗较多流量。&lt;/p&gt;

&lt;p&gt;通过对一些 H5页面进行调试及抓包发现，每次加载一个 H5页面，都会有较多的请求。除了 HTML 主 URL 自身的请求外，HTML外部引用的 JS、CSS、字体文件、图片都是一个独立的 HTTP 请求，每一个请求都串行的（可能有连接复用）。这么多请求串起来，再加上浏览器解析、渲染的时间，Web 整体的加载时间变得较长；请求文件越多，消耗的流量也会越多。我们可综合使用上面说到几种缓存机制，来帮助我们优化 Web 的加载性能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/129/554/1295547036-56fe42e54e817_articlex&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;结论：综合各种缓存机制比较，对于静态文件，如 JS、CSS、字体、图片等，适合通过浏览器缓存机制来进行缓存，通过缓存文件可大幅提升 Web 的加载速度，且节省流量。但也有一些不足：缓存文件需要首次加载后才会产生；浏览器缓存的存储空间有限，缓存有被清除的可能；缓存的文件没有校验。要解决这些不足，可以参考手 Q 的离线包，它有效的解决了这些不足。&lt;/p&gt;

&lt;p&gt;对于 Web 在本地或服务器获取的数据，可以通过 Dom Storage 和 IndexedDB 进行缓存。也在一定程度上减少和 Server 的交互，提高加载速度，同时节省流量。&lt;/p&gt;

&lt;p&gt;当然 Web 的性能优化，还包括选择合适的图片大小，避免 JS 和 CSS 造成的阻塞等。这就需要 Web 前端的同事根据一些规范和一些调试工具进行优化了。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt; 
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Tue, 18 Jul 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/07/18/web-localstorage-Volume02/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/18/web-localstorage-Volume02/</guid>
        
        <category>笔记</category>
        
        <category>Web前端</category>
        
        
      </item>
    
      <item>
        <title>Web缓存的一些细碎01</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Vue.js 放弃中…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。&lt;/p&gt;

&lt;p&gt;本次从三个方面对学习进行小结。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#0&quot;&gt;一、web缓存的作用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#1&quot;&gt;二、web缓存的类型&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#2&quot;&gt;三、浅析web缓存在浏览器端工作原理&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#3&quot;&gt;四、小结&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我是看不见的分割线&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p id=&quot;0&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一web缓存的作用&quot;&gt;一、web缓存的作用&lt;/h2&gt;

&lt;p&gt;主要三个方面：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;减少网络带宽消耗（当Web缓存副本被使用时，只会产生极小的网络流量，可以有效的降低运营成本。）&lt;/li&gt;
  &lt;li&gt;降低服务器压力（给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，间接降低服务器的压力。同时，搜索引擎的爬虫机器人也能根据过期机制降低爬取的频率，也能有效降低服务器的压力。）&lt;/li&gt;
  &lt;li&gt;减少网络延迟，加开页面打开速度。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;二web缓存的类型&quot;&gt;二、web缓存的类型&lt;/h2&gt;

&lt;p&gt;在Web应用领域，Web缓存大致可以分为以下几种类型：&lt;/p&gt;

&lt;h3 id=&quot;21-数据库数据缓存&quot;&gt;2.1 数据库数据缓存&lt;/h3&gt;

&lt;p&gt;web应用，特别是SNS类型的应用，往往关系比较复杂，数据库表繁多，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，会将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。比如常用的缓存方案有&lt;a href=&quot;http://www.runoob.com/Memcached/Memcached-tutorial.html&quot;&gt;memcached&lt;/a&gt; 等。&lt;/p&gt;

&lt;h3 id=&quot;22-服务器端缓存&quot;&gt;2.2 服务器端缓存&lt;/h3&gt;

&lt;p&gt;服务器端缓存包含代理服务器缓存和CDN缓存:&lt;/p&gt;

&lt;h4 id=&quot;221-代理服务器缓存&quot;&gt;2.2.1 代理服务器缓存&lt;/h4&gt;

&lt;p&gt;代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。可以把它理解为一个共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少相应时间和带宽使用方面很有效，同一个副本会被重用多次。常见代理服务器缓存解决方案有&lt;a href=&quot;http://www.phpfans.net/manu/Squid/&quot;&gt;Squid&lt;/a&gt; 等，这里不再详述。&lt;/p&gt;

&lt;h4 id=&quot;222-cdn缓存&quot;&gt;2.2.2 CDN缓存&lt;/h4&gt;

&lt;p&gt;CDN（Content delivery networks）缓存，也叫网关缓存、反向代理缓存。CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。虽然这种架构负载均衡源服务器之间的缓存没法共享，但却拥有更好的处扩展性。从浏览器角度来看，整个CDN就是一个源服务器。&lt;/p&gt;

&lt;h2 id=&quot;23-浏览器端缓存&quot;&gt;2.3 浏览器端缓存&lt;/h2&gt;

&lt;p&gt;浏览器缓存（Browser Caching）是浏览器端保存数据用于快速读取或避免重复资源请求的优化机制，有效的缓存使用可以避免重复的网络请求和浏览器快速地读取本地数据，整体上加速网页展示给用户。&lt;/p&gt;

&lt;h2 id=&quot;24-web应用层缓存&quot;&gt;2.4 Web应用层缓存&lt;/h2&gt;

&lt;p&gt;应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据，页面，图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;下面着重从浏览器端来看缓存工作机制和原理。&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;2&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;三浅析web缓存在浏览器端工作原理&quot;&gt;三、浅析web缓存在浏览器端工作原理&lt;/h2&gt;

&lt;p&gt;根据标准，到目前为止，H5 一共有6种缓存机制，有些是之前已有，有些是 H5 才新加入的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;浏览器缓存机制；&lt;/li&gt;
    &lt;li&gt;Dom Storgage 存储机制；&lt;/li&gt;
    &lt;li&gt;Web SQL Database 存储机制；&lt;/li&gt;
    &lt;li&gt;ApplicationCach（APPCache）机制；&lt;/li&gt;
    &lt;li&gt;Indexed Database (IndexdDB);&lt;/li&gt;
    &lt;li&gt;File System API;&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;31-浏览器缓存机制&quot;&gt;3.1 浏览器缓存机制&lt;/h3&gt;

&lt;h4 id=&quot;311-非http协议定义的缓存机制&quot;&gt;3.1.1 非HTTP协议定义的缓存机制&lt;/h4&gt;

&lt;p&gt;浏览器缓存机制，其实主要就是HTTP协议定义的缓存机制（如： Expires； Cache-control等）。但是也有非HTTP协议定义的缓存机制，如使用HTML Meta 标签，Web开发者可以在HTML页面的&amp;lt;head&amp;gt;节点中加入&lt;meta /&gt;标签，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;META HTTP-EQUIV=&quot;Pragma&quot; CONTENT=&quot;no-cache&quot;&amp;gt;

&amp;lt;META HTTP-EQUIV=&quot;Expires&quot; CONTENT=&quot;0&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为代理不解析HTML内容本身。下面主要介绍HTTP协议定义的缓存机制。&lt;/p&gt;

&lt;h4 id=&quot;312-http协议定义的缓存机制&quot;&gt;3.1.2 HTTP协议定义的缓存机制&lt;/h4&gt;

&lt;p&gt;通过 HTTP 协议头里的 Cache-Control（或 Expires）和 Last-Modified（或 Etag）等字段来控制文件缓存的机制。这应该是 WEB 中最早的缓存机制了，是在 HTTP 协议中实现的，有点不同于 Dom Storage、AppCache 等缓存机制，但本质上是一样的。可以理解为，一个是协议层实现的，一个是应用层实现的。&lt;/p&gt;

&lt;h4 id=&quot;313-http10时代缓存字段详解&quot;&gt;3.1.3 HTTP1.0时代缓存字段详解&lt;/h4&gt;

&lt;p&gt;2个字段：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Pragma：设置页面是否缓存，为Pragma则缓存，no-cache则不缓存。&lt;/li&gt;
  &lt;li&gt;Expires：有了Pragma来禁用缓存，自然也需要有个东西来启用缓存和定义缓存时间，对HTTP1.0而言，Expires就是做这件事的首部字段。Expires的值对应一个GMT（格林尼治时间），比如Mon, 22 Jul 2002 11:12:01 GMT来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。&lt;br /&gt;
如果Pragma头部和Expires头部同时存在，则起作用的会是Pragma，需要注意的是，响应报文中Expires所定义的缓存时间是相对服务器上的时间而言的，其定义的是资源“失效时刻”，如果客户端上的时间跟服务器上的时间不一致（特别是用户修改了自己电脑的系统时间），那缓存时间可能就没啥意义了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;314-http11-时代缓存字段详解&quot;&gt;3.1.4 HTTP1.1 时代缓存字段详解&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Cache-Control： 针对上述的“Expires时间是相对服务器而言，无法保证和客户端时间统一”的问题，http1.1新增了 Cache-Control 来定义缓存过期时间。&lt;strong&gt;注意：若报文中同时出现了 Expires 和 Cache-Control，则以 Cache-Control 为准。&lt;/strong&gt;
(1) 最常见的，比如服务器回包：Cache-Control:max-age=600 表示文件在本地应该缓存，且有效时长是600秒（从发出请求算起）。在接下来600秒内，如果有请求这个资源，浏览器不会发出 HTTP 请求，而是直接使用本地缓存的文件。
(2) Cache-Control: no-cache；这个很容易让人产生误解，使人误以为是响应不被缓存。实际上她是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。 
(3) Cache-Control: no-store；这个才是响应不被缓存的意思。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Last-Modified/If-Modified-Since：
(1) Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。 
(2) If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Etag/If-None-Match：Etag/If-None-Match也要配合Cache-Control使用。
(1) Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器觉得）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。
(2) If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;既生Last-Modified何生Etag？
你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题： 
(1) Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间。
(2) 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存。
(3) 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。
Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小结&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/web2017-07-17-01.png&quot; alt=&quot;浏览器第一次请求01&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;浏览器第一次请求&lt;/small&gt;
&lt;br /&gt;
&lt;img src=&quot;http://image.lawootrip.com/web-2017-07-17-02.png&quot; alt=&quot;浏览器第一次请求02&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;浏览器第二次请求&lt;/small&gt;&lt;/p&gt;

&lt;h4 id=&quot;32dom-storage-存储机制&quot;&gt;3.2Dom Storage 存储机制&lt;/h4&gt;

&lt;p&gt;DOM Storage 是指 HTML5 的本地存储 API sessionStorage 和 localStorage。在介绍HTML5本地存储之前，先来看一看前面几个存储方式的概念。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/391/641/3916412705-59312d0fceb14_articlex&quot; alt=&quot;Dom Storage&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;HTTP Cookie: Cookie是为了解决HTTP无状态的特性而出现的，也可以叫用户识别机制。常用的用户识别机制包括：
    &lt;ul&gt;
      &lt;li&gt;承载用户信息的HTTP首部&lt;/li&gt;
      &lt;li&gt;客户端IP地址追踪技术，通过用户的IP地址对其进行识别&lt;/li&gt;
      &lt;li&gt;用户登录，用认证机制来识别用户&lt;/li&gt;
      &lt;li&gt;胖URL，一种在URL中嵌入识别信息的技术&lt;/li&gt;
      &lt;li&gt;cookie，一种强大且高效的持久身份识别技术&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于购物网站而言，cookie是非常重要的，为了实现购物车功能，把已选物品加入cookie，可以实现不同页面之间数据的同步，同时在提交订单的时候又会把这些cookie传到后台，大大方便了前后端开发。设置cookie:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function setCookie(name, value, options) {
  var expires = options.expires;
  var path = options.path;
  var domain = options.domain;
  var secure = options.secure;

  // 缓存时间转为日期对象
  if (typeof expires === 'number') {
    expires = new Date(new Date().getTime() + expires * 864e+5); // 缓存时间单位：天
  }
    document.cookie =
    name + '=' + escape(value) +
    (expires ? '; expires=' + expires.toUTCString() : '') +
    (path ? '; path=' + path : '') +
    (domain ? '; domain=' + domain : '') +
    (secure ? '; secure' : '');

  return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;获取cookie:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function getCookie(name) {
  var arr = document.cookie.match(new RegExp('(^| )' + name + '=([^;]*)(;|$)'));
  if (arr !== null) {
    return unescape(arr[2]);
  }

  // return null;
  return '';
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;userData是微软在上世纪90年代的浏览器大战时推出的本地存储方案，借助DHTML的behaviour属性来存储本地数据， 允许每个页面最多存储64K数据，每个站点最多640K数据，userData的缺点显而易见，它不是Web标准的一部分，除非你的程序只需要支持IE， 否则它基本没什么用处。&lt;/li&gt;
  &lt;li&gt;Flash cookie的名字有些误导，它实际上和HTTP cookie并不是一回事，或许它的名字应该叫做”Flash本地存储”，Flash cookie默认允许每个站点存储不超过100K的数据，如果超出了，Flash会自动向用户请求更大的存储空间，借助Flash的 ExternalInterface接口，你可以很轻松地通过Javascript操作Flash的本地存储。Flash的问题很简单，就是因为它是 Flash。&lt;/li&gt;
  &lt;li&gt;Gears是Google在07年发布的一个开源浏览器插件，旨在改进各大浏览器的兼容性，Gears内置了一个基于SQLite的嵌入式 SQL数据库，并提供了统一API对数据库进行访问，在取得用户授权之后，每个站点可以在SQL数据库中存储不限大小的数据，Gears的问题就是 Google自己都已经不用它了。&lt;/li&gt;
  &lt;li&gt;HTML5 的本地存储 API sessionStorage 和 localStorage
Dom Storage 是通过存储字符串的 Key/Value 对来提供的，并提供 5MB （不同浏览器可能不同，分 HOST)的存储空间（Cookies 才 4KB)。另外 Dom Storage 存储的数据在本地，不像 Cookies，每次请求一次页面，Cookies 都会发送给服务器。
DOM Storage 分为 sessionStorage 和 localStorage。localStorage 对象和 sessionStorage 对象使用方法基本相同，它们的区别在于作用的范围不同。sessionStorage 用来存储与页面相关的数据，它在页面关闭后无法使用。而 localStorage 则持久存在，在页面关闭后也可以使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;简单用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var name = sessionStorage.setItem(&quot;name&quot;,&quot;wangjuan&quot;);
alert(sessionStorage.getItem(&quot;name&quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;并不是所有的浏览器都支持这两个对象。在没有原生支持localStorage的浏览器中使用时，MDN给出了兼容代码&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Guide/API/DOM/Storage#localStorage&quot;&gt;戳这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;不同浏览器对于这两种用法的差异的兼容代码可参考:&lt;a href=&quot;https://github.com/mortzdk/localStorage&quot;&gt;戳这里&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;33-web-sql存储机制&quot;&gt;3.3 Web SQL存储机制&lt;/h4&gt;

&lt;p&gt;H5 也提供基于 SQL 的数据库存储机制，用于存储适合数据库的结构化数据。根据官方的标准文档，Web SQL Database 存储机制不再推荐使用，将来也不再维护，而是推荐使用 AppCache 和 IndexedDB。
查看更多：&lt;a href=&quot;http://www.runoob.com/html/html5-web-sql.html&quot;&gt;戳这里&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;34-application-cache-机制&quot;&gt;3.4 Application Cache 机制&lt;/h4&gt;

&lt;p&gt;Application Cache（简称 AppCache)似乎是为支持 Web App 离线使用而开发的缓存机制。它的缓存机制类似于浏览器的缓存（Cache-Control 和 Last-Modified）机制，都是以文件为单位进行缓存，且文件有一定更新机制。但 AppCache 是对浏览器缓存机制的补充，不是替代。
AppCache 的原理有两个关键点：manifest 属性和 manifest 文件。
W3C 官方的一个例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/515/220/515220078-59315a8c9c8a6_articlex&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面 HTML 文档，引用外部一个 JS 文件和一个 GIF 图片文件，在其 HTML 头中通过 manifest 属性引用了一个 appcache 结尾的文件（即manifest文件）。
缓存的结果是：我们在 Google Chrome 浏览器中打开这个 HTML 链接，JS 功能正常，图片也显示正常。禁用网络，关闭浏览器重新打开这个链接，发现 JS 工作正常，图片也显示正常。当然也有可能是浏览缓存起的作用，我们可以在文件的浏览器缓存过期后，禁用网络再试，发现 HTML 页面也是正常的。
manifest 文件就是以 appcache 结尾的文件，是一个普通文件文件，列出了需要缓存的文件。
完整的 manifest 文件，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CACHE MANIFEST
# 2012-02-21 v1.0.0
/theme.css
/logo.gif
/main.js

NETWORK:
login.asp

FALLBACK:
/html/ /offline.html 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;了解更多：&lt;a href=&quot;http://www.cnblogs.com/lovesong/p/5021992.html?utm_medium=referral&quot;&gt;戳我&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;35-indexed-database&quot;&gt;3.5 Indexed Database&lt;/h4&gt;

&lt;p&gt;IndexedDB 也是一种数据库的存储机制，但不同于已经不再支持的 Web SQL Database。IndexedDB 不是传统的关系数据库，indexedDB中没有表的概念，类似于 Dom Storage 的 key-value 的存储方式，但功能更强大，且存储空间更大。它的特点是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;以key-value 的方式存取对象，可以是任何类型值或对象，包括二进制。&lt;/li&gt;
  &lt;li&gt;可以对对象任何属性生成索引，方便查询。&lt;/li&gt;
  &lt;li&gt;较大的存储空间，默认推荐250MB(分 HOST)，比 Dom Storage 的5MB要大的多。&lt;/li&gt;
  &lt;li&gt;通过数据库的事务（tranction）机制进行数据操作，保证数据一致性。&lt;/li&gt;
  &lt;li&gt;异步的 API 调用，避免造成等待而影响体验。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;了解更多：&lt;a href=&quot;http://www.cnblogs.com/dolphinX/p/3415761.html&quot;&gt;戳1&lt;/a&gt;和&lt;a href=&quot;http://www.cnblogs.com/dolphinX/p/3416889.html&quot;&gt;戳2&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;36-file-system-api&quot;&gt;3.6 File System API&lt;/h4&gt;

&lt;p&gt;File System API 是 H5 新加入的存储机制。它为 Web App 提供了一个虚拟的文件系统，就像 Native App 访问本地文件系统一样。由于安全性的考虑，这个虚拟文件系统有一定的限制。Web App 在虚拟的文件系统中，可以进行文件（夹）的创建、读、写、删除、遍历等操作。&lt;/p&gt;

&lt;p&gt;File System API 也是一种可选的缓存机制，和前面的 SQLDatabase、IndexedDB 和 AppCache 等一样。File System API 有自己的一些特定的优势：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以满足大块的二进制数据（ large binary blobs）存储需求。&lt;/li&gt;
  &lt;li&gt;可以通过预加载资源文件来提高性能。&lt;/li&gt;
  &lt;li&gt;可以直接编辑文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p id=&quot;3&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;四小结&quot;&gt;四、小结&lt;/h3&gt;

&lt;p&gt;反正我在放弃中，前端水深请小心。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://jixianqianduan.com/frontend-javascript/2015/12/28/nine-browser-cache-methods.html&quot;&gt;九种浏览器端缓存机制知多少&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/wangpenghui522/p/5498427.html#top&quot;&gt;浏览器缓存原理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.alloyteam.com/2012/03/web-cache-1-web-cache-overview/&quot;&gt;Web缓存机制系列
&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000002701423&quot;&gt;Web 前端实现本地存储&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.lawootrip.com/2017/07/18/web-localstorage-Volume02/&quot;&gt;H5 缓存机制浅析 - 移动端 Web 加载性能优化&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html&quot;&gt;浏览器缓存机制&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://mangguo.org/browser-cache-mechanism-detailed/&quot;&gt;浏览器缓存机制详解&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/skylar/p/browser-http-caching.html&quot;&gt;透过浏览器看HTTP缓存&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/vajoy/p/5341664.html&quot;&gt;浅谈浏览器http的缓存机制&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/zichi/p/4685822.html&quot;&gt;浏览器缓存机制浅析&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt; 
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Mon, 17 Jul 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/07/17/web-localstorage-Volume01/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/17/web-localstorage-Volume01/</guid>
        
        <category>笔记</category>
        
        <category>Web前端</category>
        
        
      </item>
    
      <item>
        <title>关于DNS解析优化的一些细碎</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;DNS优化，从入门到放弃。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;前段时间掉进了网站加载缓慢，数据还会丢包的大坑。&lt;/p&gt;

&lt;p&gt;在产品其他方面加紧优化的基础上，又赶紧研究了一下DNS的工作原理以及通常使用的优化技巧。&lt;/p&gt;

&lt;p&gt;现在从坑里爬出来了。&lt;/p&gt;

&lt;p&gt;喘口气&lt;/p&gt;

&lt;p&gt;本文将从以下六个方面对DNS优化进行了一些细碎的小结。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#0&quot;&gt;一、域名DNS解析原理和过程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#1&quot;&gt;二、浏览器加载网页的基本过程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#2&quot;&gt;三、合理利用DNS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#3&quot;&gt;四、合理使用DNS-prefetch让DNS预读取&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#4&quot;&gt;五、DNS域名解析拆分为多个域名增加并行下载量&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#5&quot;&gt;六、加快域名DNS解析速度方法小结&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;我是看不见的分割线&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p id=&quot;0&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一域名dns解析原理和过程&quot;&gt;一、域名DNS解析原理和过程&lt;/h3&gt;

&lt;h5 id=&quot;dns是怎么来的&quot;&gt;DNS是怎么来的?&lt;/h5&gt;

&lt;p&gt;DNS 是域名系统 (Domain Name System) 的缩写。在Internet上域名与IP地址之间是一对一(或者多对一)的，域名虽然便于人们记忆，但机器之间只能互相认识IP地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS就是进行域名解析的服务器。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-05-15-structure.PNG&quot; alt=&quot;DNS服务结构&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;DNS的树形结构&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，DNS服务器类型主要有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;内部 DNS ：位于内网中，提供内网 DNS 服务，也具备 Internet DNS 缓存与转发能力&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;外部 DNS：位于 Internet 中，提供 Internet 的 DNS 服务（包括 DNS 缓存与转发）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;主 DNS：提供 DNS 服务（包括查询，缓存写入）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;辅 DNS：只提供 DNS 查询服务，与主 DNS 同步数据库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;唯缓存 DNS：自身不具备 DNS 解析能力，但具有 DNS 缓存数据库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;转发 DNS：具备转发特性，能将 DNS 请求转发给其他 DNS 服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;权威 DNS： 自身数据库中存在与 DNS 请求相对应的映射&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;非权威 DNS：不存在相对应的映射，而存在对应缓存查询结果&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-05-15-DNS-process.png&quot; alt=&quot;DNS服务进程&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;DNS解析进程&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;上图的DNS解析过程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;龟龟(192.168.1.1) 在浏览器访问 http://www.lawootrip.com&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;192.168.1.1 检查本地 hosts 文件中是否存在 www.lawootrip.com 对应的 IP&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;若无，192.168.1.1 继续检查本地 DNS 缓存中是否存在 www.lawootrip.com 对应的 IP&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;若无， 192.168.1.1 向本地 DNS 服务器发起 DNS 查询请求&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;路由器接收到 DNS 查询请求后，检查路由器 DNS 缓存&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;若无，路由器以外网地址 202.202.202.202 向本地 DSN 服务器 （ISP DNS）发起 DNS 查询请求&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ISP DNS 接收到 DNS 查询请求后，发现自己不是权威 DNS ，且无对应的缓存数据，于是将请求转发给 其他 DNS 服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其他 DNS 服务器 接收到请求后，一样发现自己不是权威 DNS，且无对应的缓存数据，于是开始进行 DNS 迭代查询：将请求发送给根域名服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;根域名服务器接收到请求后，将顶级域名服务器 (.com) IP 发送给其他 DNS 服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其他 DNS 服务器根据 IP 将 DNS 查询请求发送给 顶级域名服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;顶级域名服务器接收到请求后，将 二级域名服务器 (jianshu.com) IP 发送给其他 DNS 服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其他域名服务器根据 IP 将 DNS 查询请求发送给二级域名服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;二级域名服务器 接收到请求后，发现自己是权威 DNS 服务器，于是将 www.lawootrip.com 映射的 IP 151.101.72.133 发送给其他域名服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其他域名服务器 接收到解析结果后，将 151.101.72.133 逐层返回传递下去，最终直至 192.168.1.1&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;15.192.168.1.1 接收到 www.lawootrip.com 解析结果 151.101.72.133 ，根据 IP 与 www.lawootrip.com 建立 TCP 连接，然后发起 HTTP 请求主页内容&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;二浏览器加载网页的基本过程&quot;&gt;二、浏览器加载网页的基本过程&lt;/h3&gt;

&lt;p&gt;1、从浏览器地址栏的请求链接开始，浏览器通过DNS解析查到域名映射的IP地址，成功之后浏览器端向此IP地址取得连接，成功连接之后，浏览器端将请求头信息通过HTTP协议向此IP地址所在服务器发起请求，服务器接受到请求之后等待处理。&lt;/p&gt;

&lt;p&gt;2、览器加载显示html的顺序是：从上到下，渲染的顺序也是从上到下，下载和渲染是同时进行的。如果遇到语义解释性的标签嵌入文件(JS脚本，CSS 下载过程会启用单独连接进行下载，并且在下载后进行解析，解析过程中，停止页面所有往下元素的下载。&lt;/p&gt;

&lt;p&gt;3、什么原因会导致网页加载过慢?浏览器可以在下载CSS资源的同时，并行解析HTML文件，但是，一旦发现有脚本文件的引用，则必须等待脚本文件完成下载并且执行后才能继续解析。内容下载时间主要取决于用户带宽、服务器带宽、文件大小、文件数量等。一般来说，将静态文件挂在CDN上，甚至全站CDN，往往能较好的解决这类问题。&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;2&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;三合理利用dns-ttl值-增加域名的缓存命中率&quot;&gt;三、合理利用DNS TTL值 增加域名的缓存命中率&lt;/h3&gt;

&lt;p&gt;1、DNS 服务器采用递归或迭代来处理客户端查询时，它们将发现并获得大量有关 DNS 命名空间的重要信息。然后这些信息由服务器缓存。缓存为 DNS 解析流行名称的后续查询提供了加速性能的方法，同时大大减少了网络上与 DNS 相关的查询通信量。&lt;/p&gt;

&lt;p&gt;2、TTL(Time-To-Live)即一条域名解析记录在DNS服务器上缓存时间。当信息缓存时，生存时间 (TTL) 值适用于所有缓存的 RR。只要缓存 RR 的 TTL 没有到期，DNS 服务器就可继续缓存并再次使用 RR 来应答与这些 RR 相匹配的客户端提出的查询。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-05-15-TTL.png&quot; alt=&quot;DNS服务进程&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;TTL设置&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;3、适当地增大TTL值可以让DNS Server缓存该域名更长时间，增加缓存的命中率。TTL一般默认为一小时，可以根据实际情况设为一天甚至一周以上。当然，如果你域名的IP经常变化，则TTL不应过大，否则各地的DNS Server会暂时无法获得新的正确的IP地址。&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;3&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;四合理使用dns-prefetch让dns预读取&quot;&gt;四、合理使用DNS-prefetch让DNS预读取&lt;/h3&gt;

&lt;p&gt;1、从上面浏览器加载网页的过程可以看出，网页的请求是可以多任务同时进行的，对于网页有多个DNS请求的情况，可以让浏览器在后台先把要使用的DNS请求默默地完成，这样当用户在打开新的网页时，就可以节省DNS查询的时间了。&lt;/p&gt;

&lt;p&gt;2、控制浏览器的DNS预读取就是DNS-prefetch标签了，DNS Prefetch应该尽量的放在网页的前面，&lt;/p&gt;

&lt;p&gt;格式类似是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;link rel=&quot;dns-prefetch&quot; href=&quot;//img.lawootrip.com&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;　
很多网站都使用使用百度广告联盟代码，使用这个就可以预读取DNS了。&lt;/p&gt;

&lt;p&gt;3、默认情况下浏览器会有隐式的DNS Prefetch，即会对页面中和当前域名(正在浏览网页的域名)不在同一个域的域名进行预获取，并且缓存结果，我们可以通过下面的标签禁止隐式的DNS Prefetch：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;meta http-equiv=”x-dns-prefetch-control” content=”off”&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4、需要注意的就是，DNS Prefetch只需要在用户在第一次打开网站时使用即可，没有必要每个页面都使用DNS Prefetch，否则就是重复DNS读取了，反而还无形中增加了DNS查询的次数，效果适得其反。&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;4&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;五dns域名解析拆分为多个域名增加并行下载量&quot;&gt;五、DNS域名解析拆分为多个域名增加并行下载量&lt;/h3&gt;

&lt;p&gt;1、一般来说网页的内容加载时会发生多个域名请求服务，如果你的网站JS、CSS、图片等非常多的话，建议将这些文件分别放在不同的域名上，这样浏览器在打开某一个页面时就可以同时向这些域名发送DNS解析请求了，能在一定程度上减少DNS时间。&lt;/p&gt;

&lt;p&gt;2、网页的内容越多，分析的域名应该尽量多一些。例如html、htm，js、css，jpg、png、gif，php、asp都可以放在不同的域名上。在实际应用上，使用全站CDN或者是静态文件CDN就可以实现上述效果，并且结合css sprite一起来使用的。&lt;/p&gt;

&lt;p&gt;3、css sprite(雪碧图)的作用恰恰相反，它不是增加域名请求，而减少域名DNS请求，主要是用在图片上。它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，这样一来，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。&lt;/p&gt;

&lt;hr /&gt;
&lt;p id=&quot;5&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;六加快域名dns解析速度方法小结&quot;&gt;六、加快域名DNS解析速度方法小结&lt;/h3&gt;

&lt;p&gt;1、以上就是一些简单的优化DNS小技巧，即时对个人开发者来说也没有什么门槛和技术难度，但是对提升网站的响应速度却有着明显的功效，大家不妨一试。&lt;/p&gt;

&lt;p&gt;2、除了从网站本身的DNS解析来加快访问速度外，我们平常在选择DNS服务时尽量使用那些稳定可靠的DNS服务，这样的DNS服务响应速度和缓存率都是非常不错的。假如自己的网站分拆了多个二级域名，不妨好好用用CNAME，设置好TTL时间，保证网站的第一次解析，可以直接从运营商的DNS缓存中拿到。&lt;/p&gt;

&lt;p&gt;此处顺便推荐三个神器，两个神服务。&lt;/p&gt;

&lt;p&gt;“DNSpod”作为NS服务商，免费稳定专业。&lt;/p&gt;

&lt;p&gt;“七牛云CDN”作为CDN服务商，免费稳定专业。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/2017-05-15-shenqi.png&quot; alt=&quot;Chrles+Dig+微信web工具&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;Chrles+Dig+微信web工具&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;MAC环境下，推荐 &lt;strong&gt;Charles&lt;/strong&gt;用来进行数据抓包，网络通讯分析；&lt;strong&gt;Dig&lt;/strong&gt;用来检测DNS，GUI界面，简单直观好用；&lt;strong&gt;微信web工具&lt;/strong&gt;作为辅助，尤其是你的产品需要在微信内打开时，必备工具。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt; 
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Mon, 15 May 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/05/15/DNS-optimization/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/05/15/DNS-optimization/</guid>
        
        <category>笔记</category>
        
        <category>DNS</category>
        
        
      </item>
    
      <item>
        <title>浅析微信扫码登陆</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;实现微信登录，不一定要认证微信开放平台。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;话不多说，直接上图。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/25s.png&quot; alt=&quot;25s&quot; /&gt;&lt;/p&gt;

&lt;p&gt;先看登录二维码的分析，可以清楚看到页面先后加载了网页、图片、CSS、Javascript等资源文件，包括二维码图片。&lt;/p&gt;

&lt;p&gt;然后仔细观察会发现，网页会一直在异步请求一个链接，这个链接其实就是在监听服务器，如果有人用微信客户端授权成功，则会返回成功的信息然后跳转；否则继续监听。&lt;/p&gt;

&lt;p&gt;这个过程就是整个网页最重要的部分了，通过不断请求来监听状态。所以需要重点分析此请求。&lt;/p&gt;

&lt;p&gt;从图中我们还可以看到，右侧，每个请求都是用了25s左右。为什么要这么长时间呢？&lt;/p&gt;

&lt;p&gt;由于监听和登录操作肯定是短时间内必须完成的，比如我扫完二维码确认登录了，这个页面就要在短时间内做出响应。如果要做到这样，最简单的方法就是通过Javascript定时器，每隔几秒请求服务器并获取状态（事实上我同时也研究过新浪微博的扫二维码登录，它就是这样做的，每隔3-4秒左右请求一次）。然而这样会直接导致的问题就是，服务器会产生非常高的并发，小用户级别的服务器还没什么，但是像微信这种需要服务庞大用户群的服务器，就必须做这方面的优化。&lt;/p&gt;

&lt;p&gt;所以微信的采用的做法就是减少请求并增加响应时间，实现的原理大概就是在服务器端接收到请求后，内部加个定时器不断检查用户授权的状态，如果检测到用户授权则马上响应给网页端；否则继续检查；当时间累积到25秒左右，不论成不成功都终止检测并立即响应给网页端。&lt;/p&gt;

&lt;p&gt;好了，我们接下来继续观察这个请求的参数：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/17-04-26-query.png&quot; alt=&quot;query&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到总共有五个参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;loginicon ：布尔值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;uuid：字符串&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;tip ：正整数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;r：负整数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;_：正整数&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从字面上来理解的话，&lt;/p&gt;

&lt;p&gt;第一个参数大概意思是，是否要有登录图标（true=&amp;gt;要，false=&amp;gt;不要）；&lt;/p&gt;

&lt;p&gt;第二个参数，是指二维码的值，随便测试下就知道了；&lt;/p&gt;

&lt;p&gt;第三个参数，应该是指是否要提示（1=&amp;gt;要，0=&amp;gt;不要）；&lt;/p&gt;

&lt;p&gt;第四个参数，应该是一个随机数（random）；&lt;/p&gt;

&lt;p&gt;第五个参数，不难看出这是个Unix时间戳。随机数和时间戳跟安全机制有关吧，防止相关的攻击，如重放攻击。&lt;/p&gt;

&lt;p&gt;这几个参数当中，最重要的是当然是uuid了，因为这是用来向服务器请求授权状态的凭借。并且这个uuid必须是唯一不重复的，不然试想下，两个人在不同的电脑下浏览到了同一个二维码，有人授权登录了，可能会是在另一个人电脑上登录微信的网页版。所以说这个唯一的uuid是专门用来绑定一个微信账号的授权的。&lt;/p&gt;

&lt;p&gt;因为uuid一般是随机生成的，但是像这里的这串字符，观察最后两个字符“==”，又像是经过某个加密算法产生的，不过这并不太重要，确保到uuid的唯一不重复性就行了。至于r这个参数，我个人猜测这是个随机数。最后一个参数是用来做超时验证操作的，确保一个uuid只在短时间内有效，如果你仔细观察，会发现二维码登录页在几分钟内不登录，那么它会自动刷新然后更新过另外一个二维码。最后利用这三个进行某种算法之后生成签名（下面提到的ticket值）返回给客户端。&lt;/p&gt;

&lt;p&gt;接下来我们看看这个请求的返回值：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/17-04-26-response.png&quot; alt=&quot;response&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从图中我们可以看到返回的是一条Javascript语句，有个状态码408，这个就是表示用户还没有用微信客户端APP授权，需要继续请求监听状态。如果是授权成功，则返回200，然后登录页会跳转到后台：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;window.code=200;
window.redirect_uri=&quot;https://wx.qq.com/cgi-bin/mmwebwx-bin/webwxnewloginpage?ticket=AV09Uzr8oDEF1xoAcaOdNUi@articket_0&amp;amp;uuid=wdBJJLlfaQ==&amp;amp;lang=zh_CN&amp;amp;scan=1431123223&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;ticket值就是服务器生成的用户签名，理解为access_token即可。&lt;/p&gt;

&lt;p&gt;再来看看微信客户端APP扫描二维码后的页面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/17-04-26-app.PNG&quot; alt=&quot;app&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当扫描成功二维码后，会弹出授权窗口，询问是否授权登录。&lt;/p&gt;

&lt;p&gt;换个二维码扫描软件可以得到登录时候的二维码字符串实际值如图。经过多次试验可以知道前半段不变的，只有后面的参数会变（&lt;strong&gt;即uuid值&lt;/strong&gt;）。&lt;/p&gt;

&lt;p&gt;所以分析得到微信客户端的步骤是这样的：&lt;/p&gt;

&lt;p&gt;1.扫描二维码（扫一扫）&lt;/p&gt;

&lt;p&gt;2.如果字符串前半段是https://login.weixin.qq.com/l/，则弹出授权窗口&lt;/p&gt;

&lt;p&gt;3.如果点击确定，再向服务器请求改变这个uuid的状态&lt;/p&gt;

&lt;p&gt;完整的流程图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/17-04-26-flow-chart.jpg&quot; alt=&quot;flow-chart&quot; /&gt;&lt;/p&gt;

&lt;p&gt;至此，整个的扫二维码登录流程就完成了。&lt;/p&gt;

&lt;p&gt;至于如何利用在此剖析的原理进行二次开发和利用，就尽情发挥你的聪明才智吧。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt; 
&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/0%20%2837%29.gif&quot; /&gt; &lt;/td&gt;
&lt;td&gt;
&lt;img src=&quot;http://image.lawootrip.com/1490924677.png&quot; /&gt;&lt;div&gt;&lt;small class=&quot;img-hint&quot;&gt;这不是收钱的  加个好友而已&lt;/small&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

</description>
        <pubDate>Wed, 26 Apr 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/04/26/https-con/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/26/https-con/</guid>
        
        <category>笔记</category>
        
        <category>微信</category>
        
        
      </item>
    
  </channel>
</rss>
