<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LawooTrip</title>
    <description>龟龟的个人博客</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 21 Feb 2017 12:16:31 +0000</pubDate>
    <lastBuildDate>Tue, 21 Feb 2017 12:16:31 +0000</lastBuildDate>
    <generator>Jekyll v3.4.0</generator>
    
      <item>
        <title>Merge、Rebase的选择</title>
        <description>&lt;blockquote&gt;
&lt;p&gt;BY &lt;a href=&quot;https://github.com/geeeeeeeeek/git-recipes/&quot;&gt;童仲毅geeeeeeeeek@github&lt;/a&gt;——目前看到的关于Merge、Rebase最通俗易懂的wiki。&lt;/p&gt;
&lt;p&gt;这是一篇在原文(&lt;a href=&quot;https://www.atlassian.com/git/tutorials/merging-vs-rebasing&quot;&gt;BY atlassian&lt;/a&gt;)基础上演绎的译文。除非另行注明，页面上所有内容采用知识共享-署名(&lt;a herf=&quot;https://creativecommons.org/licenses/by/2.5/au/deed.en&quot;&gt;CC BY 2.5 AU协议共享。&lt;/a&gt;)&lt;/p&gt; 
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt; 这个命令经常被人认为是一种Git巫术，初学者应该避而远之。但如果使用得当的话，它能给你的团队开发省去太多烦恼。在这篇文章中，我们会比较&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt;和类似的&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt;命令，找到Git工作流中rebase的所有用法。&lt;/p&gt;

&lt;h3 id=&quot;概述&quot;&gt;概述&lt;/h3&gt;
&lt;p&gt;你要知道的第一件事是，&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt; 和&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt; 做的事其实是一样的。它们都被设计来将一个分支的更改并入另一个分支，只不过方式有些不同。&lt;/p&gt;

&lt;p&gt;想象一下，你刚创建了一个专门的分支开发新功能，然后团队中另一个成员在master分支上添加了新的提交。这就会造成提交历史被Fork一份，用Git来协作的开发者应该都很清楚。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/919155232a162011b8a64a84872482034c0ce999/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f6d657267696e672d76732d7265626173696e672f30312e737667&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在，如果master中新的提交和你的工作是相关的。为了将新的提交并入你的分支，你有两个选择：merge或rebase。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;merge&quot;&gt;Merge&lt;/h3&gt;
&lt;p&gt;将master分支合并到feature分支最简单的办法就是用下面这些命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;　　git checkout feature
　　git merge master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者，你也可以把它们压缩在一行里。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git merge master feature
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;feature分支中新的合并提交(merge　commit)将两个分支的历史连在了一起。你会得到下面这样的分支结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/266aef357af48c218b8779cd489bcb8839aa0a25/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f6d657267696e672d76732d7265626173696e672f30322e737667&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Merge好在它是一个安全的操作。现有的分支不会被更改，避免了rebase潜在的缺点（后面会说）。&lt;/p&gt;

&lt;p&gt;另一方面，这同样意味着每次合并上游更改时feature分支都会引入一个外来的合并提交。如果master非常活跃的话，这或多或少会污染你的分支历史。虽然高级的git log 选项可以减轻这个问题，但对于开发者来说，还是会增加理解项目历史的难度。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;rebase&quot;&gt;Rebase&lt;/h3&gt;
&lt;p&gt;作为merge的替代选择，你可以像下面这样将feature分支并入master分支：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git checkout feature
git rebase master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;它会把整个feature分支移动到master分支的后面，有效地把所有master分支上新的提交并入过来。但是，rebase为原分支上每一个提交创建一个新的提交，重写了项目历史，并且不会带来合并提交。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/626197748d8d8493b194ce59874b71897c88c39f/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f6d657267696e672d76732d7265626173696e672f30332e737667&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;rebase最大的好处是你的项目历史会非常整洁。首先，它不像&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt; 那样引入不必要的合并提交。其次，如上图所示，rebase导致最后的项目历史呈现出完美的线性——你可以从项目终点到起点浏览而不需要任何的Fork。这让你更容易使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git log&lt;/code&gt; 、&lt;code class=&quot;highlighter-rouge&quot;&gt;git bisect&lt;/code&gt; 和&lt;code class=&quot;highlighter-rouge&quot;&gt;gitk&lt;/code&gt; 来查看项目历史。&lt;/p&gt;

&lt;p&gt;不过，这种简单的提交历史会带来两个后果：安全性和可跟踪性。如果你违反了Rebase黄金法则，重写项目历史可能会给你的协作工作流带来灾难性的影响。此外，rebase不会有合并提交中附带的信息——你看不到feature分支中并入了上游的哪些更改。&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;交互式的rebase&quot;&gt;交互式的rebase&lt;/h3&gt;
&lt;p&gt;交互式的rebase允许你更改并入新分支的提交。这比自动的rebase更加强大，因为它提供了对分支上提交历史完整的控制。一般来说，这被用于将feature分支并入master分支之前，清理混乱的历史。&lt;/p&gt;

&lt;p&gt;把&lt;code class=&quot;highlighter-rouge&quot;&gt;-i&lt;/code&gt; 传入&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt; 选项来开始一个交互式的rebase过程：
　　&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git checkout feature
git rebase -i master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;它会打开一个文本编辑器，显示所有将被移动的提交：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pick 33d5b7a Message for commit #1
pick 9480b3d Message for commit #2
pick 5c67e61 Message for commit #3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个列表定义了rebase将被执行后分支会是什么样的。更改pick 命令或者重新排序，这个分支的历史就能如你所愿了。比如说，如果第二个提交修复了第一个提交中的小问题，你可以用fixup 命令把它们合到一个提交中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pick 33d5b7a Message for commit #1
fixup 9480b3d Message for commit #2
pick 5c67e61 Message for commit #3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;保存后关闭文件，Git会根据你的指令来执行rebase，项目历史看上去会是这样：
　　
&lt;img src=&quot;https://camo.githubusercontent.com/b685d6f2a7b4ecf6896fa2439e8da2fb958195fd/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f6d657267696e672d76732d7265626173696e672f30342e737667&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　忽略不重要的提交会让你的feature分支的历史更清晰易读。这是git merge 做不到的。
　　&lt;/p&gt;
&lt;h3 id=&quot;rebase的黄金法则&quot;&gt;Rebase的黄金法则&lt;/h3&gt;
&lt;p&gt;当你理解rebase是什么的时候，最重要的就是什么时候 不能 用rebase。git rebase 的黄金法则便是，绝不要在公共的分支上使用它。&lt;/p&gt;

&lt;p&gt;比如说，如果你把master分支rebase到你的feature分支上会发生什么：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/b3d06635fdadff5863f94aa53b16bba69452f04f/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f6d657267696e672d76732d7265626173696e672f30352e737667&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这次rebase将master分支上的所有提交都移到了feature分支后面。问题是它只发生在你的代码仓库中，其他所有的开发者还在原来的master上工作。因为rebase引起了新的提交，Git会认为你的master分支和其他人的master已经分叉了。&lt;/p&gt;

&lt;p&gt;同步两个master分支的唯一办法是把它们merge到一起，导致一个额外的合并提交和两堆包含同样更改的提交。不用说，这会让人非常困惑。&lt;/p&gt;

&lt;p&gt;所以，在你运行git rebase 之前，一定要问问你自己“有没有别人正在这个分支上工作？”。如果答案是肯定的，那么把你的爪子放回去，重新找到一个无害的方式（如git revert）来提交你的更改。不然的话，你可以随心所欲地重写历史。&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;强制推送&quot;&gt;强制推送&lt;/h3&gt;
&lt;p&gt;如果你想把rebase之后的master分支推送到远程仓库，Git会阻止你这么做，因为两个分支包含冲突。但你可以传入&lt;code class=&quot;highlighter-rouge&quot;&gt;--force&lt;/code&gt; 标记来强行推送。就像下面一样：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;小心使用这个命令！！！&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git push --force
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;它会重写远程的master分支来匹配你仓库中rebase之后的master分支，对于团队中其他成员来说这看上去很诡异。所以，务必小心这个命令，只有当你知道你在做什么的时候再使用。&lt;/p&gt;

&lt;p&gt;仅有的几个强制推送的使用场景之一是，当你在想向远程仓库推送了一个私有分支之后，执行了一个本地的清理（比如说为了回滚）。这就像是在说“哦，其实我并不想推送之前那个feature分支的。用我现在的版本替换掉吧。”同样，你要注意没有别人正在这个feature分支上工作。&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;工作流&quot;&gt;工作流&lt;/h3&gt;
&lt;p&gt;rebase可以或多或少应用在你们团队的Git工作流中。在这一节中，我们来看看在feature分支开发的各个阶段中，rebase有哪些好处。&lt;/p&gt;

&lt;p&gt;第一步是在任何和&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt; 有关的工作流中为每一个feature专门创建一个分支。它会给你带来安全使用rebase的分支结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/4b8c7e7855643d46885f8df41b4dc4de11dc89a3/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f6d657267696e672d76732d7265626173696e672f30362e737667&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;本地清理&quot;&gt;本地清理&lt;/h3&gt;
&lt;p&gt;在你工作流中使用rebase最好的用法之一就是清理本地正在开发的分支。隔一段时间执行一次交互式rebase，你可以保证你feature分支中的每一个提交都是专注和有意义的。你在写代码时不用担心造成孤立的提交——因为你后面一定能修复。&lt;/p&gt;

&lt;p&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt; 的时候，你有两个基(base)可以选择：上游分支（比如master）或者你feature分支中早先的一个提交。我们在“交互式rebase”一节看到了第一种的例子。后一种在当你只需要修改最新几次提交时也很有用。比如说，下面的命令对最新的3次提交进行了交互式rebase：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git checkout feature
git rebase -i HEAD~3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过指定&lt;code class=&quot;highlighter-rouge&quot;&gt;HEAD~3&lt;/code&gt;作为新的基提交，你实际上没有移动分支——你只是将之后的3次提交重写了。注意它不会把上游分支的更改并入到feature分支中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/890e91bbd54876ff01865403164de70fe47b555b/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f6d657267696e672d76732d7265626173696e672f30372e737667&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果你想用这个方法重写整个feature分支，&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge-base&lt;/code&gt; 命令非常方便地找出feature分支开始分叉的基。下面这段命令返回基提交的ID，你可以接下来将它传给&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git merge-base feature master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;交互式rebase是在你工作流中引入git rebase 的的好办法，因为它只影响本地分支。其他开发者只能看到你已经完成的结果，那就是一个非常整洁、易于追踪的分支历史。&lt;/p&gt;

&lt;p&gt;但同样的，这只能用在私有分支上。如果你在同一个feature分支和其他开发者合作的话，这个分支是公开的，你不能重写这个历史。&lt;/p&gt;

&lt;p&gt;用带有交互式的rebase清理本地提交，这是无法用&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt; 命令代替的。&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;将上游分支上的更改并入feature分支&quot;&gt;将上游分支上的更改并入feature分支&lt;/h3&gt;
&lt;p&gt;在概览一节，我们看到了feature分支如何通过&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt; 或&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt; 来并入上游分支。merge是保留你完整历史的安全选择，rebase将你的feature分支移动到master分支后面，创建一个线性的历史。&lt;/p&gt;

&lt;p&gt;git rebase 的用法和本地清理非常类似（而且可以同时使用），但之间并入了master上的上游更改。&lt;/p&gt;

&lt;p&gt;记住，rebase到远程分支而不是master也是完全合法的。当你和另一个开发者在同一个feature分之上协作的时候，你会用到这个用法，将他们的更改并入你的项目。&lt;/p&gt;

&lt;p&gt;比如说，如果你和另一个开发者——John——往feature分支上添加了几个提交，在从John的仓库中fetch之后，你的仓库可能会像下面这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/6758dd2be664491c52dc4c246939f1ad5a14fba9/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f6d657267696e672d76732d7265626173696e672f30382e737667&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;就和并入master上的上游更改一样，你可以这样解决这个Fork：要么merge你的本地分支和John的分支，要不把你的本地分支rebase到John的分支后面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/c45e2609be5941aaedac397b08770be35d490db7/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f6d657267696e672d76732d7265626173696e672f30392e737667&quot; alt=&quot;此处输入图片的描述&quot; /&gt;
&lt;img src=&quot;https://camo.githubusercontent.com/c45e2609be5941aaedac397b08770be35d490db7/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f6d657267696e672d76732d7265626173696e672f30392e737667&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意，这里的rebase没有违反Rebase黄金法则，因为只有你的本地分支上的commit被移动了，之前的所有东西都没有变。这就像是在说“把我的改动加到John的后面去”。在大多数情况下，这比通过合并提交来同步远程分支更符合直觉。&lt;/p&gt;

&lt;p&gt;默认情况下，&lt;code class=&quot;highlighter-rouge&quot;&gt;git pull&lt;/code&gt; 命令会执行一次merge，但你可以传入&lt;code class=&quot;highlighter-rouge&quot;&gt;--rebase&lt;/code&gt; 来强制它通过rebase来整合远程分支。&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;通过pull-request进行审查&quot;&gt;通过Pull Request进行审查&lt;/h3&gt;
&lt;p&gt;如果你将pull request作为你代码审查过程中的一环，你需要避免在创建pull request之后使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt;。只要你发起了pull request，其他开发者能看到你的代码，也就是说这个分支变成了公共分支。重写历史会造成Git和你的同事难以找到这个分支接下来的任何提交。&lt;/p&gt;

&lt;p&gt;来自其他开发者的任何更改都应该用&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt; 而不是&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt; 来并入。&lt;/p&gt;

&lt;p&gt;因此，在提交pull request前用交互式的rebase进行代码清理通常是一个好的做法。&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;并入通过的功能分支&quot;&gt;并入通过的功能分支&lt;/h3&gt;

&lt;p&gt;如果某个功能被你们团队通过了，你可以选择将这个分支rebase到master分支之后，或是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt; 来将这个功能并入主代码库中。&lt;/p&gt;

&lt;p&gt;这和将上游改动并入feature分支很相似，但是你不可以在master分支重写提交，你最后需要用&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt; 来并入这个feature。但是，在merge之前执行一次rebase，你可以确保merge是一直向前的，最后生成的是一个完全线性的提交历史。这样你还可以加入pull request之后的提交。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/7a158568c55aa3b65bc58a648aabb17b36573eaa/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f6d657267696e672d76732d7265626173696e672f31302e737667&quot; alt=&quot;此处输入图片的描述&quot; /&gt;
&lt;img src=&quot;https://camo.githubusercontent.com/7a158568c55aa3b65bc58a648aabb17b36573eaa/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f6d657267696e672d76732d7265626173696e672f31302e737667&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果你还没有完全熟悉git rebase，你还可以在一个临时分支中执行&lt;code class=&quot;highlighter-rouge&quot;&gt;rebase&lt;/code&gt;。这样的话，如果你意外地弄乱了你feature分支的历史，你还可以查看原来的分支然后重试。&lt;/p&gt;

&lt;p&gt;比如说：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git checkout feature
git checkout -b temporary-branch
git rebase -i master
# [清理目录]
git checkout master
git merge temporary-branch
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;你使用rebase之前需要知道的知识点都在这了。如果你想要一个干净的、线性的提交历史，没有不必要的合并提交，你应该使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt; 而不是&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt; 来并入其他分支上的更改。&lt;/p&gt;

&lt;p&gt;另一方面，如果你想要保存项目完整的历史，并且避免重写公共分支上的commit， 你可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt;。两种选项都很好用，但至少你现在多了&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt;这个选择。&lt;/p&gt;
</description>
        <pubDate>Tue, 21 Feb 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/02/21/github-rebase-merge.markup/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/02/21/github-rebase-merge.markup/</guid>
        
        <category>github</category>
        
        <category>笔记</category>
        
        
      </item>
    
      <item>
        <title>土耳其图集</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“Türk Marşı”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://image.lawootrip.com/WechatIMG5.jpeg&quot; alt=&quot;烤肉！烤肉！烤肉！&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 19 Feb 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/02/19/turkey.markup/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/02/19/turkey.markup/</guid>
        
        <category>图集</category>
        
        
      </item>
    
      <item>
        <title>克什米尔之殇</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“اپ سے مل کر خوشی ہوی ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;缘起&quot;&gt;缘起&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://p1.bqimg.com/567571/f6b44c6abca1eb36.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　这里的房屋大多是木质结构，尖顶，条件好的人家还带有一个进行穆斯林祈祷仪式的砖砌塔楼。Ghulam家算条件好的，但家中家具很少，客厅几乎没有家具，只有一张五米见方精致的手工地毯铺满房间，他们平常就在这里看书看报、吃饭喝茶，我们也都席地坐在地毯上，面前摆着克什米尔藏红花茶，醇香扑鼻。&lt;/p&gt;

&lt;p&gt;　　克什米尔传统大袍套在老人的身上，两只袖子总是空空的耷拉着，隐藏在袍子里的手握着肚子前的特色火炉——藤蔓编制而成的篮子，盛着些许燃着的炭灰用来取暖。
老人吸了一口水烟，往事立马随着烟气将我们笼罩。
&lt;img src=&quot;http://p1.bqimg.com/567571/cac33d40135de4f6.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;http://i1.piimg.com/567571/5fdacaed4f06ab67.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;过去即他乡&quot;&gt;过去即他乡&lt;/h3&gt;

&lt;p&gt;　　1965年一颗炮弹落到他家的祈祷塔楼上，门窗都被炸飞了。这被认为是真主不满的表示，他们延长了每天祈祷的时间。几天后，他的母亲去邻居家借纺轮，在回来的路上被流弹击中后脑，于是他在剩下的岁月里只能依靠照片来怀念母亲。没过多久，印巴实现第二次停火，克什米尔迎来了短暂的和平期，印度兵的吉普车和坦克从南边开进了克什米尔，七岁的Ghulam对他们并无厌恶，成年人的恐惧在孩子们看来无法理解，他甚至有些庆幸，因为印度军方禁止他们每天五次的礼拜，这给了他更多玩耍的时间，但“好景”不长，十岁开始他就被送进了老师家学习制作披肩。
&lt;img src=&quot;http://p1.bpimg.com/567571/f8c0edb5bea2054e.png&quot; alt=&quot;&quot; /&gt;
　　在那个年代里，每个人的睡眠时间都很少，每天要劳动，要打扫院子，要种地，学习披肩技艺和印度语，吃的是万变不离其宗的菜汤米饭，冬天异常寒冷，屋子里没有取暖的设备，在零下十几度的房间学习织作，一坐就是十个小时，不能燃炭炉，因为那样会烤坏羊绒，只能靠手指不停的穿梭织作，一天下来，总是要花一个多小时让自己已经被冻紫的脚恢复知觉。
问他为什么在那种时候还要学习做披肩，长达数十年的战乱把这里变成贸易和旅游的禁地，披肩又能卖给谁呢？
　　老人说克什米尔人做披肩不是为了赚钱，这是很多很多年前波斯居鲁士大帝的带来的文明，我们要传承下去，这是我们的命。
老人说我们跟谁都不争，双手烤着生命之火取暖；火萎了，我就准备走了，但披肩的手艺还有我的儿子传下去。&lt;/p&gt;

&lt;p&gt;　　57岁的Ghulam看起来像古稀之年的老人，满脸沟壑却的他似乎已不太认识几十年前那个在夹缝中长大的自己。不过对于那个十几岁的少年来说，也许并不觉得苦。对于一辈子只做一件事的人来说，还有什么苦难可以打败他呢？&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;方生方死&quot;&gt;方生方死&lt;/h3&gt;
&lt;p&gt;　　这块美丽土地曾享受过长时间的和平，但早在印度、巴基斯坦为之大肆操戈前，它已受到各类争斗的蹂躏。
　　早在公元前300年波斯人就武力打通了外界到克什米尔的通路，同时带来披肩的原始工艺，公元326年亚历山大大帝沿着波斯人的轨迹来到克什米尔，怀着解救被缚普罗米修斯之心的亚历山大终究没能杀死啃噬其肝脏的秃鹰，饱受痢疾之苦的马其顿人在征服了克什米尔后回到巴比伦不久就病逝了。
接下来到达克什米尔的是自东土大唐而来的唐僧，唐僧在古称迦湿弥罗的克什米尔学习三年，孙悟空显然没对师傅的高反帮上什么忙，法师用了一年时间才适应高海拔地区的环境。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“此北二千余里，经途艰阻，寒风飞雪，至秣逻娑国。”——《大唐西域记》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　此后的一千年只能用混战概括。8世纪开始阿拉伯势力进入克什米尔，克什米尔开始穆斯林化，17世纪因为佛教天主教之争，克什米尔的拉达克人和现今西藏阿里扎达县的古格人发生战争，最终古格王朝一夜之间被屠城，古格宏伟的宫殿和华美的壁画，直到20世纪才被意大利人杜奇教授重新发现。
古格王朝的惨败传到北京，康熙震怒，增派2500蒙古骑兵支援吐蕃，又在克什米尔的土地上同拉达克背后的莫卧儿王朝鏖战连年。
　　尚未得到片刻喘气，1829年英国人在克什米尔宣布殖民，接下来的近代史更是被接连不断的暴力和恐怖事件充斥，三次印巴战争受伤最深的总是克什米尔，就在我写下这篇文章的时候克什米尔的朋友告诉我他们那里又发生了一次大规模罢工，人们向印度军警投掷石块，被暴力镇压…
&lt;img src=&quot;http://i1.piimg.com/567571/d31f4a653ff1efe7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;何去何从&quot;&gt;何去何从？&lt;/h3&gt;

&lt;p&gt;　　一千个克什米尔人有一千个答案，年轻人如Asif说我们只是要和平，上了年纪的人如Ghulam说我只希望手艺传下去。但对于地处大国文明交汇地带的克什米尔来说，和平很可能是永远的奢望。正如法国学者鲁保罗所说，自波斯以降，克什米尔人习惯了一个帝国的存在。
聊到这里，城里每日五次响彻全城的祷告声准时响起，他们放下手中的事情全身心的投入礼拜的状态。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ghulam给我讲过《古兰经》关于末日的描述：“或如重重黑暗﹐笼罩着汪洋大海﹐波涛澎湃﹐上有黑云﹐黑暗重重迭迭﹐观者伸出手来时﹐几乎不见五指。 真主没有给谁光明﹐谁就绝无光明。”(古兰经﹐24﹕40)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;后记&quot;&gt;后记&lt;/h3&gt;
&lt;p&gt;　　好像看一部规模宏大的电影，居鲁士时代的坟墓、丝绸之路的商队、唐朝的高僧、阿拉伯人的征伐、印巴的战俘营，被污染但依然壮丽的风光。在影片最后，男主人公站在克什米尔最高的山峰上，影片没有告诉我们他是否能够活着下山。
住在地球小屋里的人们，烧漆黑的松枝照明，从前的一场场雪，炭火之光和燃烧的松枝——夜晚说故事，无需太亮。
&lt;img src=&quot;http://p1.bqimg.com/567571/e18f0ca8b67baf1e.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 15 Feb 2017 19:05:00 +0000</pubDate>
        <link>http://localhost:4000/2017/02/15/Kashmir-tear/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/02/15/Kashmir-tear/</guid>
        
        <category>生活</category>
        
        
      </item>
    
      <item>
        <title>Welcome to LawooTrip</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“Yeah It’s on. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;龟龟 的 Blog 就这么开通了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#build&quot;&gt;跳过废话，直接看技术实现 &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2017 年，龟龟 总算有个地方可以好好写点东西了。&lt;/p&gt;

&lt;p&gt;历时大半个月，断断续续的，终于把个人站搭建起来。&lt;/p&gt;

&lt;p id=&quot;build&quot;&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;接下来说说搭建这个博客的技术细节。&lt;/p&gt;

&lt;p&gt;正好之前就有关注过 &lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt; + &lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt; 快速 Building Blog 的技术方案，非常轻松时尚。&lt;/p&gt;

&lt;p&gt;其优点非常明显：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Markdown&lt;/strong&gt; 带来的优雅写作体验&lt;/li&gt;
  &lt;li&gt;非常便捷的 Git workflow ，&lt;strong&gt;Git Commit 即 Blog Post&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机
    &lt;ul&gt;
      &lt;li&gt;如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Jekyll 的自定制非常容易，基本就是个模版引擎&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本来觉得最大的缺点可能是 GitHub 在国内访问起来太慢，所以第二天一起床就到 GitCafe(Chinese GitHub Copy) 迁移了一个&lt;a href=&quot;http://SIGAOYI.gitcafe.io&quot;&gt;镜像&lt;/a&gt;出来，结果还是巨慢。&lt;/p&gt;

&lt;p&gt;果断开 &lt;strong&gt;Charles&lt;/strong&gt;查了下网络请求，原来是 &lt;strong&gt;pending 在了 Google Fonts&lt;/strong&gt; 上，页面渲染一直被阻塞到请求超时为止，难怪这么慢。&lt;br /&gt;
忍痛割爱，只好把 Web Fonts 去了（反正超时看到的也只能是 fallback ），果然一下就正常了，而且 GitHub 和 GitCafe 对比并没有感受到明显的速度差异，虽然 github 的 ping 值明显要高一些，达到了 300ms，于是用 DNSPOD 优化了一下速度。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;配置的过程中遇到了不少坑，毕竟不是码农，git从零入手，遇到了merge、fetch各种branch傻傻分不清楚。几度几乎放弃，缺总是被一丝丝的曙光召唤着继续研究。）&lt;/p&gt;

&lt;p&gt;本地调试环境需要 &lt;code class=&quot;highlighter-rouge&quot;&gt;gem install jekyll&lt;/code&gt;，结果 rubygem 的源居然被墙了……后来手动改成了我大淘宝的镜像源才成功&lt;/p&gt;

&lt;p&gt;Theme 的 CSS 是基于 Bootstrap 定制的，看得不爽的地方直接在 Less 里改就好了（平时更习惯 SCSS 些），&lt;strong&gt;不过其实我一直觉得 Bootstrap 在移动端的体验做得相当一般，比我在淘宝参与的团队 CSS 框架差多了……&lt;/strong&gt;所以为了体验，也补了不少 CSS 进去&lt;/p&gt;

&lt;p&gt;最后就进入了耗时反而最长的&lt;strong&gt;做图、写字&lt;/strong&gt;阶段，也算是进入了&lt;strong&gt;写博客&lt;/strong&gt;的正轨，因为是类似 Hack Day 的方式去搭这个站的，所以折腾折腾着大半夜就过去了。&lt;/p&gt;

&lt;p&gt;第二天考虑中文字体的渲染，fork 了 &lt;a href=&quot;http://www.typeisbeautiful.com/&quot;&gt;Type is Beautiful&lt;/a&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;font&lt;/code&gt; CSS，调整了字号，适配了 Win 的渣渲染，中英文混排效果好多了。&lt;/p&gt;

&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;回顾这个博客的诞生，纯粹是出于个人兴趣。&lt;/p&gt;

&lt;p&gt;我不是程序猿，也不是Github的重度用户，只是在找一些产品源码的时候偶遇了GitPages，前几次的碰壁愈发激起了我要攻克他的信念。&lt;/p&gt;

&lt;p&gt;今日终于&lt;/p&gt;

&lt;p&gt;跑起来了&lt;/p&gt;

&lt;p&gt;—— 龟龟 后记于 2017.02&lt;/p&gt;
</description>
        <pubDate>Wed, 15 Feb 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/02/15/hello-2017.markup/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/02/15/hello-2017.markup/</guid>
        
        <category>生活</category>
        
        
      </item>
    
  </channel>
</rss>
